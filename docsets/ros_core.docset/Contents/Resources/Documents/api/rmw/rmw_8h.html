<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rmw: include/rmw/rmw.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rmw
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C API providing a middleware abstraction layer which is used to implement the rest of ROS.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_f1863b20b54cc3d25893e93314d6cb7b.html">rmw</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rmw.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;<a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/allocator_8h.html">rcutils/allocator.h</a>&quot;</code><br />
<code>#include &quot;<a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/macros_8h.html">rcutils/macros.h</a>&quot;</code><br />
<code>#include &quot;<a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/types_8h.html">rcutils/types.h</a>&quot;</code><br />
<code>#include &quot;rosidl_runtime_c/message_type_support_struct.h&quot;</code><br />
<code>#include &quot;rosidl_runtime_c/service_type_support_struct.h&quot;</code><br />
<code>#include &quot;rosidl_runtime_c/sequence_bound.h&quot;</code><br />
<code>#include &quot;<a class="el" href="event_8h_source.html">rmw/event.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="init_8h_source.html">rmw/init.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="event__callback__type_8h_source.html">rmw/event_callback_type.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="macros_8h_source.html">rmw/macros.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="message__sequence_8h_source.html">rmw/message_sequence.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="publisher__options_8h_source.html">rmw/publisher_options.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="qos__profiles_8h_source.html">rmw/qos_profiles.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="subscription__options_8h_source.html">rmw/subscription_options.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="types_8h_source.html">rmw/types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="visibility__control_8h_source.html">rmw/visibility_control.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for rmw.h:</div>
<div class="dyncontent">
<div class="center"><img src="rmw_8h__incl.png" border="0" usemap="#ainclude_2rmw_2rmw_8h" alt=""/></div>
<map name="ainclude_2rmw_2rmw_8h" id="ainclude_2rmw_2rmw_8h">
<area shape="rect" title=" " alt="" coords="1960,5,2107,32"/>
<area shape="rect" title=" " alt="" coords="296,527,379,553"/>
<area shape="rect" title=" " alt="" coords="3227,527,3301,553"/>
<area shape="rect" title=" " alt="" coords="583,623,654,650"/>
<area shape="rect" target="_parent" href="http://docs.ros2.org/humble/api/rcutils/allocator_8h.html.html" title=" " alt="" coords="2005,527,2139,553"/>
<area shape="rect" href="macros_8h.html" title=" " alt="" coords="2910,623,3037,650"/>
<area shape="rect" target="_parent" href="http://docs.ros2.org/humble/api/rcutils/macros_8h.html.html" title=" " alt="" coords="1395,705,1522,732"/>
<area shape="rect" href="visibility__control_8h.html" title=" " alt="" coords="1933,616,2056,657"/>
<area shape="rect" target="_parent" href="http://docs.ros2.org/humble/api/rcutils/types_8h.html.html" title=" " alt="" coords="656,527,771,553"/>
<area shape="rect" title=" " alt="" coords="1725,80,1918,121"/>
<area shape="rect" title=" " alt="" coords="1943,80,2124,121"/>
<area shape="rect" title=" " alt="" coords="2149,80,2345,121"/>
<area shape="rect" href="event_8h.html" title=" " alt="" coords="229,87,333,114"/>
<area shape="rect" href="types_8h.html" title=" " alt="" coords="1679,177,1782,203"/>
<area shape="rect" href="init_8h.html" title=" " alt="" coords="947,259,1035,285"/>
<area shape="rect" href="event__callback__type_8h.html" title=" " alt="" coords="3378,169,3531,211"/>
<area shape="rect" href="message__sequence_8h.html" title=" " alt="" coords="3108,87,3303,114"/>
<area shape="rect" href="publisher__options_8h.html" title=" " alt="" coords="2369,87,2551,114"/>
<area shape="rect" href="qos__profiles_8h.html" title=" " alt="" coords="2575,87,2721,114"/>
<area shape="rect" href="subscription__options_8h.html" title=" " alt="" coords="1447,87,1649,114"/>
<area shape="rect" href="ret__types_8h.html" title=" " alt="" coords="453,527,581,553"/>
<area shape="rect" target="_parent" href="http://docs.ros2.org/humble/api/rcutils/logging_8h.html.html" title=" " alt="" coords="2797,341,2923,367"/>
<area shape="rect" href="time_8h.html" title=" " alt="" coords="2127,430,2235,457"/>
<area shape="rect" href="events__statuses_8h.html" title=" " alt="" coords="1473,333,1634,375"/>
<area shape="rect" href="init__options_8h.html" title=" " alt="" coords="1110,341,1253,367"/>
<area shape="rect" href="security__options_8h.html" title=" " alt="" coords="707,430,882,457"/>
<area shape="rect" href="serialized__message_8h.html" title=" " alt="" coords="1991,259,2187,285"/>
<area shape="rect" href="subscription__content__filter__options_8h.html" title=" " alt="" coords="1658,423,1849,464"/>
<area shape="rect" href="error__handling_8h.html" title="Functions and macros to interact with error handling mechanisms." alt="" coords="2877,430,3049,457"/>
<area shape="rect" target="_parent" href="http://docs.ros2.org/humble/api/rcutils/error__handling_8h.html.html" title=" " alt="" coords="2826,527,2998,553"/>
<area shape="rect" target="_parent" href="http://docs.ros2.org/humble/api/rcutils/time_8h.html.html" title=" " alt="" coords="2694,527,2802,553"/>
<area shape="rect" href="incompatible__qos_8h.html" title=" " alt="" coords="1473,423,1634,464"/>
<area shape="rect" href="liveliness__changed_8h.html" title=" " alt="" coords="795,519,957,561"/>
<area shape="rect" href="liveliness__lost_8h.html" title=" " alt="" coords="1235,519,1397,561"/>
<area shape="rect" href="message__lost_8h.html" title=" " alt="" coords="2311,423,2473,464"/>
<area shape="rect" href="offered__deadline__missed_8h.html" title=" " alt="" coords="2549,423,2750,464"/>
<area shape="rect" href="requested__deadline__missed_8h.html" title=" " alt="" coords="1421,512,1582,568"/>
<area shape="rect" href="qos__policy__kind_8h.html" title=" " alt="" coords="1708,527,1879,553"/>
<area shape="rect" href="domain__id_8h.html" title=" " alt="" coords="958,430,1093,457"/>
<area shape="rect" href="localhost_8h.html" title=" " alt="" coords="1219,430,1346,457"/>
<area shape="rect" target="_parent" href="http://docs.ros2.org/humble/api/rcutils/uint8__array_8h.html.html" title=" " alt="" coords="2020,333,2159,375"/>
</map>
</div>
</div>
<p><a href="rmw_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6dfb314c4e5edf3c28b1fb1ffe992b0c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a6dfb314c4e5edf3c28b1fb1ffe992b0c">rmw_get_implementation_identifier</a> (void)</td></tr>
<tr class="memdesc:a6dfb314c4e5edf3c28b1fb1ffe992b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the rmw implementation being used.  <a href="rmw_8h.html#a6dfb314c4e5edf3c28b1fb1ffe992b0c">More...</a><br /></td></tr>
<tr class="separator:a6dfb314c4e5edf3c28b1fb1ffe992b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d6ce17ee198857a68292a73016f6a4"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a77d6ce17ee198857a68292a73016f6a4">rmw_get_serialization_format</a> (void)</td></tr>
<tr class="memdesc:a77d6ce17ee198857a68292a73016f6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique serialization format for this middleware.  <a href="rmw_8h.html#a77d6ce17ee198857a68292a73016f6a4">More...</a><br /></td></tr>
<tr class="separator:a77d6ce17ee198857a68292a73016f6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb06f551db3cbcd6298ed8f20e3ed8d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#aeb06f551db3cbcd6298ed8f20e3ed8d2">rmw_create_node</a> (<a class="el" href="init_8h.html#a60d257a0cc981fb8961bcb0d613f3f2a">rmw_context_t</a> *context, const char *name, const char *namespace_)</td></tr>
<tr class="memdesc:aeb06f551db3cbcd6298ed8f20e3ed8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a node and return a handle to that node.  <a href="rmw_8h.html#aeb06f551db3cbcd6298ed8f20e3ed8d2">More...</a><br /></td></tr>
<tr class="separator:aeb06f551db3cbcd6298ed8f20e3ed8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2c3d9d51ebf753d6c531ab3b42253b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a0a2c3d9d51ebf753d6c531ab3b42253b">rmw_destroy_node</a> (<a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *node)</td></tr>
<tr class="memdesc:a0a2c3d9d51ebf753d6c531ab3b42253b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a given node handle, reclaim the resources, and deallocate the node handle.  <a href="rmw_8h.html#a0a2c3d9d51ebf753d6c531ab3b42253b">More...</a><br /></td></tr>
<tr class="separator:a0a2c3d9d51ebf753d6c531ab3b42253b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43ddabd6febd7b1ba0ea60a1a61498f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#ab43ddabd6febd7b1ba0ea60a1a61498f">rmw_node_assert_liveliness</a> (const <a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *node)</td></tr>
<tr class="separator:ab43ddabd6febd7b1ba0ea60a1a61498f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ca2bdd798c7b8f69da46d85e8d0fb9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="types_8h.html#a81b00c2cb16d5a51f37315c9f708b491">rmw_guard_condition_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a52ca2bdd798c7b8f69da46d85e8d0fb9">rmw_node_get_graph_guard_condition</a> (const <a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *node)</td></tr>
<tr class="memdesc:a52ca2bdd798c7b8f69da46d85e8d0fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a guard condition which is triggered when the ROS graph changes.  <a href="rmw_8h.html#a52ca2bdd798c7b8f69da46d85e8d0fb9">More...</a><br /></td></tr>
<tr class="separator:a52ca2bdd798c7b8f69da46d85e8d0fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d45143cc18afb6dfbeb7abf7c99b8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#af8d45143cc18afb6dfbeb7abf7c99b8e">rmw_init_publisher_allocation</a> (const rosidl_message_type_support_t *type_support, const rosidl_runtime_c__Sequence__bound *message_bounds, <a class="el" href="types_8h.html#aee0478e5575d3206d00dea884c18b6bd">rmw_publisher_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:af8d45143cc18afb6dfbeb7abf7c99b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a publisher allocation to be used with later publications.  <a href="rmw_8h.html#af8d45143cc18afb6dfbeb7abf7c99b8e">More...</a><br /></td></tr>
<tr class="separator:af8d45143cc18afb6dfbeb7abf7c99b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8ee7b6eef8d2b843484e77ead4992f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a1a8ee7b6eef8d2b843484e77ead4992f">rmw_fini_publisher_allocation</a> (<a class="el" href="types_8h.html#aee0478e5575d3206d00dea884c18b6bd">rmw_publisher_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:a1a8ee7b6eef8d2b843484e77ead4992f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a publisher allocation object.  <a href="rmw_8h.html#a1a8ee7b6eef8d2b843484e77ead4992f">More...</a><br /></td></tr>
<tr class="separator:a1a8ee7b6eef8d2b843484e77ead4992f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74022d90eb22d95b082d4808670f8a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#acb16586307694dcc71965aacaba5ae98">rmw_publisher_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#ac74022d90eb22d95b082d4808670f8a9">rmw_create_publisher</a> (const <a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *node, const rosidl_message_type_support_t *type_support, const char *topic_name, const <a class="el" href="types_8h.html#a6f1f6c7a61a3d276ea2758ce2d5ac9c5">rmw_qos_profile_t</a> *qos_profile, const <a class="el" href="types_8h.html#a27c4c36f4d58a0bd0834a27fba8af2bf">rmw_publisher_options_t</a> *publisher_options)</td></tr>
<tr class="memdesc:ac74022d90eb22d95b082d4808670f8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a publisher and return a handle to that publisher.  <a href="rmw_8h.html#ac74022d90eb22d95b082d4808670f8a9">More...</a><br /></td></tr>
<tr class="separator:ac74022d90eb22d95b082d4808670f8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297f8ae702c5f1eb51c40928e735de74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a297f8ae702c5f1eb51c40928e735de74">rmw_destroy_publisher</a> (<a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *node, <a class="el" href="types_8h.html#acb16586307694dcc71965aacaba5ae98">rmw_publisher_t</a> *publisher)</td></tr>
<tr class="memdesc:a297f8ae702c5f1eb51c40928e735de74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a given publisher handle, reclaim the resources, and deallocate the publisher handle.  <a href="rmw_8h.html#a297f8ae702c5f1eb51c40928e735de74">More...</a><br /></td></tr>
<tr class="separator:a297f8ae702c5f1eb51c40928e735de74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0768752013e0a1ee2776a303d3fc074"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#ae0768752013e0a1ee2776a303d3fc074">rmw_borrow_loaned_message</a> (const <a class="el" href="types_8h.html#acb16586307694dcc71965aacaba5ae98">rmw_publisher_t</a> *publisher, const rosidl_message_type_support_t *type_support, void **ros_message)</td></tr>
<tr class="memdesc:ae0768752013e0a1ee2776a303d3fc074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Borrow a loaned ROS message.  <a href="rmw_8h.html#ae0768752013e0a1ee2776a303d3fc074">More...</a><br /></td></tr>
<tr class="separator:ae0768752013e0a1ee2776a303d3fc074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd05b65f77e840f7276397fdbf64894"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#abbd05b65f77e840f7276397fdbf64894">rmw_return_loaned_message_from_publisher</a> (const <a class="el" href="types_8h.html#acb16586307694dcc71965aacaba5ae98">rmw_publisher_t</a> *publisher, void *loaned_message)</td></tr>
<tr class="memdesc:abbd05b65f77e840f7276397fdbf64894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a loaned message previously borrowed from a publisher.  <a href="rmw_8h.html#abbd05b65f77e840f7276397fdbf64894">More...</a><br /></td></tr>
<tr class="separator:abbd05b65f77e840f7276397fdbf64894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab625a62ba2f32e3d3a7c7ca1f6e0dbd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#ab625a62ba2f32e3d3a7c7ca1f6e0dbd6">rmw_publish</a> (const <a class="el" href="types_8h.html#acb16586307694dcc71965aacaba5ae98">rmw_publisher_t</a> *publisher, const void *ros_message, <a class="el" href="types_8h.html#aee0478e5575d3206d00dea884c18b6bd">rmw_publisher_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:ab625a62ba2f32e3d3a7c7ca1f6e0dbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish a ROS message.  <a href="rmw_8h.html#ab625a62ba2f32e3d3a7c7ca1f6e0dbd6">More...</a><br /></td></tr>
<tr class="separator:ab625a62ba2f32e3d3a7c7ca1f6e0dbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01da69d8613952343abd5d65107399a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#ab01da69d8613952343abd5d65107399a">rmw_publish_loaned_message</a> (const <a class="el" href="types_8h.html#acb16586307694dcc71965aacaba5ae98">rmw_publisher_t</a> *publisher, void *ros_message, <a class="el" href="types_8h.html#aee0478e5575d3206d00dea884c18b6bd">rmw_publisher_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:ab01da69d8613952343abd5d65107399a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish a loaned ROS message.  <a href="rmw_8h.html#ab01da69d8613952343abd5d65107399a">More...</a><br /></td></tr>
<tr class="separator:ab01da69d8613952343abd5d65107399a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046ba6f8ff184ebb01ab269b31a49f33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a046ba6f8ff184ebb01ab269b31a49f33">rmw_publisher_count_matched_subscriptions</a> (const <a class="el" href="types_8h.html#acb16586307694dcc71965aacaba5ae98">rmw_publisher_t</a> *publisher, size_t *subscription_count)</td></tr>
<tr class="memdesc:a046ba6f8ff184ebb01ab269b31a49f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of matched subscriptions to a publisher.  <a href="rmw_8h.html#a046ba6f8ff184ebb01ab269b31a49f33">More...</a><br /></td></tr>
<tr class="separator:a046ba6f8ff184ebb01ab269b31a49f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809010ecc3e404d8880382e2d4b35976"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a809010ecc3e404d8880382e2d4b35976">rmw_publisher_get_actual_qos</a> (const <a class="el" href="types_8h.html#acb16586307694dcc71965aacaba5ae98">rmw_publisher_t</a> *publisher, <a class="el" href="types_8h.html#a6f1f6c7a61a3d276ea2758ce2d5ac9c5">rmw_qos_profile_t</a> *qos)</td></tr>
<tr class="memdesc:a809010ecc3e404d8880382e2d4b35976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the actual qos settings of the publisher.  <a href="rmw_8h.html#a809010ecc3e404d8880382e2d4b35976">More...</a><br /></td></tr>
<tr class="separator:a809010ecc3e404d8880382e2d4b35976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca69c33387b6185146c3f115ec2a24a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#abca69c33387b6185146c3f115ec2a24a">rmw_publish_serialized_message</a> (const <a class="el" href="types_8h.html#acb16586307694dcc71965aacaba5ae98">rmw_publisher_t</a> *publisher, const <a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *serialized_message, <a class="el" href="types_8h.html#aee0478e5575d3206d00dea884c18b6bd">rmw_publisher_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:abca69c33387b6185146c3f115ec2a24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish a ROS message as a byte stream.  <a href="rmw_8h.html#abca69c33387b6185146c3f115ec2a24a">More...</a><br /></td></tr>
<tr class="separator:abca69c33387b6185146c3f115ec2a24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c172e30e87562f7f7ad25bae8b0ec8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a0c172e30e87562f7f7ad25bae8b0ec8b">rmw_get_serialized_message_size</a> (const rosidl_message_type_support_t *type_support, const rosidl_runtime_c__Sequence__bound *message_bounds, size_t *size)</td></tr>
<tr class="memdesc:a0c172e30e87562f7f7ad25bae8b0ec8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size of a serialized message.  <a href="rmw_8h.html#a0c172e30e87562f7f7ad25bae8b0ec8b">More...</a><br /></td></tr>
<tr class="separator:a0c172e30e87562f7f7ad25bae8b0ec8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4025992c2194103d3fe417d2373e95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a1e4025992c2194103d3fe417d2373e95">rmw_publisher_assert_liveliness</a> (const <a class="el" href="types_8h.html#acb16586307694dcc71965aacaba5ae98">rmw_publisher_t</a> *publisher)</td></tr>
<tr class="memdesc:a1e4025992c2194103d3fe417d2373e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually assert that this Publisher is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC)  <a href="rmw_8h.html#a1e4025992c2194103d3fe417d2373e95">More...</a><br /></td></tr>
<tr class="separator:a1e4025992c2194103d3fe417d2373e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4a6bedeecb634f1226df03c53f5238"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#abf4a6bedeecb634f1226df03c53f5238">rmw_publisher_wait_for_all_acked</a> (const <a class="el" href="types_8h.html#acb16586307694dcc71965aacaba5ae98">rmw_publisher_t</a> *publisher, <a class="el" href="time_8h.html#ad4459bc766d7eeca0c324c4650128686">rmw_time_t</a> wait_timeout)</td></tr>
<tr class="memdesc:abf4a6bedeecb634f1226df03c53f5238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until all published message data is acknowledged or until the specified timeout elapses.  <a href="rmw_8h.html#abf4a6bedeecb634f1226df03c53f5238">More...</a><br /></td></tr>
<tr class="separator:abf4a6bedeecb634f1226df03c53f5238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787c040bb59b0470ba51eee7e2bc04cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a787c040bb59b0470ba51eee7e2bc04cd">rmw_serialize</a> (const void *ros_message, const rosidl_message_type_support_t *type_support, <a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *serialized_message)</td></tr>
<tr class="memdesc:a787c040bb59b0470ba51eee7e2bc04cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a ROS message into a rmw_serialized_message_t.  <a href="rmw_8h.html#a787c040bb59b0470ba51eee7e2bc04cd">More...</a><br /></td></tr>
<tr class="separator:a787c040bb59b0470ba51eee7e2bc04cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dee9c2eed962055a68febe9622f807c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a9dee9c2eed962055a68febe9622f807c">rmw_deserialize</a> (const <a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *serialized_message, const rosidl_message_type_support_t *type_support, void *ros_message)</td></tr>
<tr class="memdesc:a9dee9c2eed962055a68febe9622f807c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize a ROS message.  <a href="rmw_8h.html#a9dee9c2eed962055a68febe9622f807c">More...</a><br /></td></tr>
<tr class="separator:a9dee9c2eed962055a68febe9622f807c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68cb3b9b96efa6d370257d83598d4bed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a68cb3b9b96efa6d370257d83598d4bed">rmw_init_subscription_allocation</a> (const rosidl_message_type_support_t *type_support, const rosidl_runtime_c__Sequence__bound *message_bounds, <a class="el" href="types_8h.html#a74a8ca7ddfdd8734690fe56d8afe9fd2">rmw_subscription_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:a68cb3b9b96efa6d370257d83598d4bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a subscription allocation to be used with later <code>take</code>s.  <a href="rmw_8h.html#a68cb3b9b96efa6d370257d83598d4bed">More...</a><br /></td></tr>
<tr class="separator:a68cb3b9b96efa6d370257d83598d4bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e2408746a0e03bdaa290ef32780253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a26e2408746a0e03bdaa290ef32780253">rmw_fini_subscription_allocation</a> (<a class="el" href="types_8h.html#a74a8ca7ddfdd8734690fe56d8afe9fd2">rmw_subscription_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:a26e2408746a0e03bdaa290ef32780253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a publisher allocation object.  <a href="rmw_8h.html#a26e2408746a0e03bdaa290ef32780253">More...</a><br /></td></tr>
<tr class="separator:a26e2408746a0e03bdaa290ef32780253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a864d424c6aa5fc57b1ca3dbe19a697"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a3a864d424c6aa5fc57b1ca3dbe19a697">rmw_create_subscription</a> (const <a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *node, const rosidl_message_type_support_t *type_support, const char *topic_name, const <a class="el" href="types_8h.html#a6f1f6c7a61a3d276ea2758ce2d5ac9c5">rmw_qos_profile_t</a> *qos_policies, const <a class="el" href="types_8h.html#a3f24759469ff4dc82f5315e19ba2faee">rmw_subscription_options_t</a> *subscription_options)</td></tr>
<tr class="memdesc:a3a864d424c6aa5fc57b1ca3dbe19a697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a subscription and return a handle to that subscription.  <a href="rmw_8h.html#a3a864d424c6aa5fc57b1ca3dbe19a697">More...</a><br /></td></tr>
<tr class="separator:a3a864d424c6aa5fc57b1ca3dbe19a697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606270f7d253dba6eb9c279061bd2b6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a606270f7d253dba6eb9c279061bd2b6c">rmw_destroy_subscription</a> (<a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *node, <a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *subscription)</td></tr>
<tr class="separator:a606270f7d253dba6eb9c279061bd2b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f83284d1a1a2de0cbbc270fab7e2254"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a7f83284d1a1a2de0cbbc270fab7e2254">rmw_subscription_count_matched_publishers</a> (const <a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *subscription, size_t *publisher_count)</td></tr>
<tr class="memdesc:a7f83284d1a1a2de0cbbc270fab7e2254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of matched publishers to a subscription.  <a href="rmw_8h.html#a7f83284d1a1a2de0cbbc270fab7e2254">More...</a><br /></td></tr>
<tr class="separator:a7f83284d1a1a2de0cbbc270fab7e2254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2db56457082adaf379577e4f963bce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a1b2db56457082adaf379577e4f963bce">rmw_subscription_get_actual_qos</a> (const <a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *subscription, <a class="el" href="types_8h.html#a6f1f6c7a61a3d276ea2758ce2d5ac9c5">rmw_qos_profile_t</a> *qos)</td></tr>
<tr class="memdesc:a1b2db56457082adaf379577e4f963bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the actual qos settings of the subscription.  <a href="rmw_8h.html#a1b2db56457082adaf379577e4f963bce">More...</a><br /></td></tr>
<tr class="separator:a1b2db56457082adaf379577e4f963bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061635ca547422e597f3c084d0f67c4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a061635ca547422e597f3c084d0f67c4d">rmw_subscription_set_content_filter</a> (<a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *subscription, const <a class="el" href="subscription__content__filter__options_8h.html#a8e46bff7989aa4f5f0d02124bffbf0e8">rmw_subscription_content_filter_options_t</a> *options)</td></tr>
<tr class="memdesc:a061635ca547422e597f3c084d0f67c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the content filter options for the subscription.  <a href="rmw_8h.html#a061635ca547422e597f3c084d0f67c4d">More...</a><br /></td></tr>
<tr class="separator:a061635ca547422e597f3c084d0f67c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1d9a5acc817f2e6d84f9136b06a8cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a8a1d9a5acc817f2e6d84f9136b06a8cd">rmw_subscription_get_content_filter</a> (const <a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *subscription, <a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/allocator_8h.html#a2b0c5a16a0401a4afb39d352ff999019">rcutils_allocator_t</a> *allocator, <a class="el" href="subscription__content__filter__options_8h.html#a8e46bff7989aa4f5f0d02124bffbf0e8">rmw_subscription_content_filter_options_t</a> *options)</td></tr>
<tr class="memdesc:a8a1d9a5acc817f2e6d84f9136b06a8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the content filter options of the subscription.  <a href="rmw_8h.html#a8a1d9a5acc817f2e6d84f9136b06a8cd">More...</a><br /></td></tr>
<tr class="separator:a8a1d9a5acc817f2e6d84f9136b06a8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bf29af7069593e2f8dfa2296710080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#af9bf29af7069593e2f8dfa2296710080">rmw_take</a> (const <a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *subscription, void *ros_message, bool *taken, <a class="el" href="types_8h.html#a74a8ca7ddfdd8734690fe56d8afe9fd2">rmw_subscription_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:af9bf29af7069593e2f8dfa2296710080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take an incoming ROS message.  <a href="rmw_8h.html#af9bf29af7069593e2f8dfa2296710080">More...</a><br /></td></tr>
<tr class="separator:af9bf29af7069593e2f8dfa2296710080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8498c763a02e0fe9203ab6c9dfba0408"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a8498c763a02e0fe9203ab6c9dfba0408">rmw_take_with_info</a> (const <a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *subscription, void *ros_message, bool *taken, <a class="el" href="types_8h.html#abc926cd584b2ce189a89ae20aaab817b">rmw_message_info_t</a> *message_info, <a class="el" href="types_8h.html#a74a8ca7ddfdd8734690fe56d8afe9fd2">rmw_subscription_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:a8498c763a02e0fe9203ab6c9dfba0408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take an incoming ROS message with its metadata.  <a href="rmw_8h.html#a8498c763a02e0fe9203ab6c9dfba0408">More...</a><br /></td></tr>
<tr class="separator:a8498c763a02e0fe9203ab6c9dfba0408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec493534247a1c57a1a0579b0f4120ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#aec493534247a1c57a1a0579b0f4120ef">rmw_take_sequence</a> (const <a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *subscription, size_t count, <a class="el" href="message__sequence_8h.html#a3be13b9e5823fd79af65b8b88703e3d8">rmw_message_sequence_t</a> *message_sequence, <a class="el" href="message__sequence_8h.html#ab92d652720f24191259da0237ff9639e">rmw_message_info_sequence_t</a> *message_info_sequence, size_t *taken, <a class="el" href="types_8h.html#a74a8ca7ddfdd8734690fe56d8afe9fd2">rmw_subscription_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:aec493534247a1c57a1a0579b0f4120ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take multiple incoming ROS messages with their metadata.  <a href="rmw_8h.html#aec493534247a1c57a1a0579b0f4120ef">More...</a><br /></td></tr>
<tr class="separator:aec493534247a1c57a1a0579b0f4120ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef04c20dab1bc6cdb27343046ccab28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a8ef04c20dab1bc6cdb27343046ccab28">rmw_take_serialized_message</a> (const <a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *subscription, <a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *serialized_message, bool *taken, <a class="el" href="types_8h.html#a74a8ca7ddfdd8734690fe56d8afe9fd2">rmw_subscription_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:a8ef04c20dab1bc6cdb27343046ccab28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take an incoming ROS message as a byte stream.  <a href="rmw_8h.html#a8ef04c20dab1bc6cdb27343046ccab28">More...</a><br /></td></tr>
<tr class="separator:a8ef04c20dab1bc6cdb27343046ccab28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a8f380a5f4a5b37a48396a74a3238c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a16a8f380a5f4a5b37a48396a74a3238c">rmw_take_serialized_message_with_info</a> (const <a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *subscription, <a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *serialized_message, bool *taken, <a class="el" href="types_8h.html#abc926cd584b2ce189a89ae20aaab817b">rmw_message_info_t</a> *message_info, <a class="el" href="types_8h.html#a74a8ca7ddfdd8734690fe56d8afe9fd2">rmw_subscription_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:a16a8f380a5f4a5b37a48396a74a3238c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take an incoming ROS message as a byte stream with its metadata.  <a href="rmw_8h.html#a16a8f380a5f4a5b37a48396a74a3238c">More...</a><br /></td></tr>
<tr class="separator:a16a8f380a5f4a5b37a48396a74a3238c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95da7643ef0f44a457361151bf6cbc3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a95da7643ef0f44a457361151bf6cbc3c">rmw_take_loaned_message</a> (const <a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *subscription, void **loaned_message, bool *taken, <a class="el" href="types_8h.html#a74a8ca7ddfdd8734690fe56d8afe9fd2">rmw_subscription_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:a95da7643ef0f44a457361151bf6cbc3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take an incoming ROS message, loaned by the middleware.  <a href="rmw_8h.html#a95da7643ef0f44a457361151bf6cbc3c">More...</a><br /></td></tr>
<tr class="separator:a95da7643ef0f44a457361151bf6cbc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163d11727369827302b7f021cea837d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a163d11727369827302b7f021cea837d4">rmw_take_loaned_message_with_info</a> (const <a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *subscription, void **loaned_message, bool *taken, <a class="el" href="types_8h.html#abc926cd584b2ce189a89ae20aaab817b">rmw_message_info_t</a> *message_info, <a class="el" href="types_8h.html#a74a8ca7ddfdd8734690fe56d8afe9fd2">rmw_subscription_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:a163d11727369827302b7f021cea837d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a loaned message and with its additional message information.  <a href="rmw_8h.html#a163d11727369827302b7f021cea837d4">More...</a><br /></td></tr>
<tr class="separator:a163d11727369827302b7f021cea837d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c931744261eaa9d362e145193cf7d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#ae1c931744261eaa9d362e145193cf7d8">rmw_return_loaned_message_from_subscription</a> (const <a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *subscription, void *loaned_message)</td></tr>
<tr class="memdesc:ae1c931744261eaa9d362e145193cf7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a loaned ROS message previously taken from a subscription.  <a href="rmw_8h.html#ae1c931744261eaa9d362e145193cf7d8">More...</a><br /></td></tr>
<tr class="separator:ae1c931744261eaa9d362e145193cf7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208bb1dd4d3c77cceee53ceba7abb8ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#afc04b99b504df3d1dfc167c4a46214a2">rmw_client_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a208bb1dd4d3c77cceee53ceba7abb8ac">rmw_create_client</a> (const <a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *node, const rosidl_service_type_support_t *type_support, const char *service_name, const <a class="el" href="types_8h.html#a6f1f6c7a61a3d276ea2758ce2d5ac9c5">rmw_qos_profile_t</a> *qos_policies)</td></tr>
<tr class="memdesc:a208bb1dd4d3c77cceee53ceba7abb8ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a service client that can send requests to and receive replies from a service server.  <a href="rmw_8h.html#a208bb1dd4d3c77cceee53ceba7abb8ac">More...</a><br /></td></tr>
<tr class="separator:a208bb1dd4d3c77cceee53ceba7abb8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da675215fe98e4bcb8cf202c3503c5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a3da675215fe98e4bcb8cf202c3503c5e">rmw_destroy_client</a> (<a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *node, <a class="el" href="types_8h.html#afc04b99b504df3d1dfc167c4a46214a2">rmw_client_t</a> *client)</td></tr>
<tr class="memdesc:a3da675215fe98e4bcb8cf202c3503c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy and unregister a service client from its node.  <a href="rmw_8h.html#a3da675215fe98e4bcb8cf202c3503c5e">More...</a><br /></td></tr>
<tr class="separator:a3da675215fe98e4bcb8cf202c3503c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abc3e631cd2529f168d04be97f1db29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a9abc3e631cd2529f168d04be97f1db29">rmw_send_request</a> (const <a class="el" href="types_8h.html#afc04b99b504df3d1dfc167c4a46214a2">rmw_client_t</a> *client, const void *ros_request, int64_t *sequence_id)</td></tr>
<tr class="memdesc:a9abc3e631cd2529f168d04be97f1db29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a ROS service request.  <a href="rmw_8h.html#a9abc3e631cd2529f168d04be97f1db29">More...</a><br /></td></tr>
<tr class="separator:a9abc3e631cd2529f168d04be97f1db29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31be4bb944b42b553a700a762d789dee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a31be4bb944b42b553a700a762d789dee">rmw_take_response</a> (const <a class="el" href="types_8h.html#afc04b99b504df3d1dfc167c4a46214a2">rmw_client_t</a> *client, <a class="el" href="types_8h.html#a8ba466b6297af05b5e02bb764e59d81a">rmw_service_info_t</a> *request_header, void *ros_response, bool *taken)</td></tr>
<tr class="memdesc:a31be4bb944b42b553a700a762d789dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take an incoming ROS service response.  <a href="rmw_8h.html#a31be4bb944b42b553a700a762d789dee">More...</a><br /></td></tr>
<tr class="separator:a31be4bb944b42b553a700a762d789dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6177c1ef618162fc58c453b5486e882c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a6177c1ef618162fc58c453b5486e882c">rmw_client_request_publisher_get_actual_qos</a> (const <a class="el" href="types_8h.html#afc04b99b504df3d1dfc167c4a46214a2">rmw_client_t</a> *client, <a class="el" href="types_8h.html#a6f1f6c7a61a3d276ea2758ce2d5ac9c5">rmw_qos_profile_t</a> *qos)</td></tr>
<tr class="memdesc:a6177c1ef618162fc58c453b5486e882c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the actual qos settings of the client's request publisher.  <a href="rmw_8h.html#a6177c1ef618162fc58c453b5486e882c">More...</a><br /></td></tr>
<tr class="separator:a6177c1ef618162fc58c453b5486e882c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7edd7850ffb8ea6247f680664cfda84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#ad7edd7850ffb8ea6247f680664cfda84">rmw_client_response_subscription_get_actual_qos</a> (const <a class="el" href="types_8h.html#afc04b99b504df3d1dfc167c4a46214a2">rmw_client_t</a> *client, <a class="el" href="types_8h.html#a6f1f6c7a61a3d276ea2758ce2d5ac9c5">rmw_qos_profile_t</a> *qos)</td></tr>
<tr class="memdesc:ad7edd7850ffb8ea6247f680664cfda84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the actual qos settings of the client's response subscription.  <a href="rmw_8h.html#ad7edd7850ffb8ea6247f680664cfda84">More...</a><br /></td></tr>
<tr class="separator:ad7edd7850ffb8ea6247f680664cfda84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea67119f9c74f8804e80c887488bd1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a562ff74fd2c35c006bac0f8a98dabd7e">rmw_service_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a5ea67119f9c74f8804e80c887488bd1e">rmw_create_service</a> (const <a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *node, const rosidl_service_type_support_t *type_support, const char *service_name, const <a class="el" href="types_8h.html#a6f1f6c7a61a3d276ea2758ce2d5ac9c5">rmw_qos_profile_t</a> *qos_profile)</td></tr>
<tr class="memdesc:a5ea67119f9c74f8804e80c887488bd1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a service server that can receive requests from and send replies to a service client.  <a href="rmw_8h.html#a5ea67119f9c74f8804e80c887488bd1e">More...</a><br /></td></tr>
<tr class="separator:a5ea67119f9c74f8804e80c887488bd1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39dc6f857dfa69a69bb198dc7fa96fed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a39dc6f857dfa69a69bb198dc7fa96fed">rmw_destroy_service</a> (<a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *node, <a class="el" href="types_8h.html#a562ff74fd2c35c006bac0f8a98dabd7e">rmw_service_t</a> *service)</td></tr>
<tr class="memdesc:a39dc6f857dfa69a69bb198dc7fa96fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy and unregister a service server from its node.  <a href="rmw_8h.html#a39dc6f857dfa69a69bb198dc7fa96fed">More...</a><br /></td></tr>
<tr class="separator:a39dc6f857dfa69a69bb198dc7fa96fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fdf79993ad434417b5edabe2023813"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#af5fdf79993ad434417b5edabe2023813">rmw_take_request</a> (const <a class="el" href="types_8h.html#a562ff74fd2c35c006bac0f8a98dabd7e">rmw_service_t</a> *service, <a class="el" href="types_8h.html#a8ba466b6297af05b5e02bb764e59d81a">rmw_service_info_t</a> *request_header, void *ros_request, bool *taken)</td></tr>
<tr class="memdesc:af5fdf79993ad434417b5edabe2023813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take an incoming ROS service request.  <a href="rmw_8h.html#af5fdf79993ad434417b5edabe2023813">More...</a><br /></td></tr>
<tr class="separator:af5fdf79993ad434417b5edabe2023813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb55ba2b2a957cefb0a77b77ddc5afda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#abb55ba2b2a957cefb0a77b77ddc5afda">rmw_send_response</a> (const <a class="el" href="types_8h.html#a562ff74fd2c35c006bac0f8a98dabd7e">rmw_service_t</a> *service, <a class="el" href="types_8h.html#a06165095338e08315047c7fde7537f03">rmw_request_id_t</a> *request_header, void *ros_response)</td></tr>
<tr class="memdesc:abb55ba2b2a957cefb0a77b77ddc5afda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a ROS service response.  <a href="rmw_8h.html#abb55ba2b2a957cefb0a77b77ddc5afda">More...</a><br /></td></tr>
<tr class="separator:abb55ba2b2a957cefb0a77b77ddc5afda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d49673ef022bafb982bcd2ee17c4bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#aa3d49673ef022bafb982bcd2ee17c4bb">rmw_service_request_subscription_get_actual_qos</a> (const <a class="el" href="types_8h.html#a562ff74fd2c35c006bac0f8a98dabd7e">rmw_service_t</a> *service, <a class="el" href="types_8h.html#a6f1f6c7a61a3d276ea2758ce2d5ac9c5">rmw_qos_profile_t</a> *qos)</td></tr>
<tr class="memdesc:aa3d49673ef022bafb982bcd2ee17c4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the actual qos settings of the service's request subscription.  <a href="rmw_8h.html#aa3d49673ef022bafb982bcd2ee17c4bb">More...</a><br /></td></tr>
<tr class="separator:aa3d49673ef022bafb982bcd2ee17c4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923323faee41f087cd9f3ecc6ec135e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a923323faee41f087cd9f3ecc6ec135e9">rmw_service_response_publisher_get_actual_qos</a> (const <a class="el" href="types_8h.html#a562ff74fd2c35c006bac0f8a98dabd7e">rmw_service_t</a> *service, <a class="el" href="types_8h.html#a6f1f6c7a61a3d276ea2758ce2d5ac9c5">rmw_qos_profile_t</a> *qos)</td></tr>
<tr class="memdesc:a923323faee41f087cd9f3ecc6ec135e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the actual qos settings of the service's response publisher.  <a href="rmw_8h.html#a923323faee41f087cd9f3ecc6ec135e9">More...</a><br /></td></tr>
<tr class="separator:a923323faee41f087cd9f3ecc6ec135e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6994bb0042f3a057aa2657149b9f79b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a81b00c2cb16d5a51f37315c9f708b491">rmw_guard_condition_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a6994bb0042f3a057aa2657149b9f79b4">rmw_create_guard_condition</a> (<a class="el" href="init_8h.html#a60d257a0cc981fb8961bcb0d613f3f2a">rmw_context_t</a> *context)</td></tr>
<tr class="memdesc:a6994bb0042f3a057aa2657149b9f79b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a guard condition and return a handle to that guard condition.  <a href="rmw_8h.html#a6994bb0042f3a057aa2657149b9f79b4">More...</a><br /></td></tr>
<tr class="separator:a6994bb0042f3a057aa2657149b9f79b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbd5e36cc0c98e9ab4b018d3a13dfe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#acdbd5e36cc0c98e9ab4b018d3a13dfe2">rmw_destroy_guard_condition</a> (<a class="el" href="types_8h.html#a81b00c2cb16d5a51f37315c9f708b491">rmw_guard_condition_t</a> *guard_condition)</td></tr>
<tr class="memdesc:acdbd5e36cc0c98e9ab4b018d3a13dfe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a given guard condition handle, reclaim the resources, and deallocate the handle.  <a href="rmw_8h.html#acdbd5e36cc0c98e9ab4b018d3a13dfe2">More...</a><br /></td></tr>
<tr class="separator:acdbd5e36cc0c98e9ab4b018d3a13dfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c06507746a703e9a053c87c4a711fdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a2c06507746a703e9a053c87c4a711fdc">rmw_trigger_guard_condition</a> (const <a class="el" href="types_8h.html#a81b00c2cb16d5a51f37315c9f708b491">rmw_guard_condition_t</a> *guard_condition)</td></tr>
<tr class="separator:a2c06507746a703e9a053c87c4a711fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29d471adffff01c7738ec165f571aca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa2c45fd1040f6af3af5a9fbd241a5665">rmw_wait_set_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#ac29d471adffff01c7738ec165f571aca">rmw_create_wait_set</a> (<a class="el" href="init_8h.html#a60d257a0cc981fb8961bcb0d613f3f2a">rmw_context_t</a> *context, size_t max_conditions)</td></tr>
<tr class="memdesc:ac29d471adffff01c7738ec165f571aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a wait set to store conditions that the middleware can wait on.  <a href="rmw_8h.html#ac29d471adffff01c7738ec165f571aca">More...</a><br /></td></tr>
<tr class="separator:ac29d471adffff01c7738ec165f571aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42465b1d9fddb3556a1a9f5d44d60b6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a42465b1d9fddb3556a1a9f5d44d60b6c">rmw_destroy_wait_set</a> (<a class="el" href="types_8h.html#aa2c45fd1040f6af3af5a9fbd241a5665">rmw_wait_set_t</a> *wait_set)</td></tr>
<tr class="memdesc:a42465b1d9fddb3556a1a9f5d44d60b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a wait set.  <a href="rmw_8h.html#a42465b1d9fddb3556a1a9f5d44d60b6c">More...</a><br /></td></tr>
<tr class="separator:a42465b1d9fddb3556a1a9f5d44d60b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f480dd59075e80288fb596b2951be2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a5f480dd59075e80288fb596b2951be2b">rmw_wait</a> (<a class="el" href="types_8h.html#a1e3560769fa878a826745ee204f75965">rmw_subscriptions_t</a> *subscriptions, <a class="el" href="types_8h.html#a6489030799d6e0b70a6ffe602dbd318b">rmw_guard_conditions_t</a> *guard_conditions, <a class="el" href="types_8h.html#aacbcb015e95c5b007475b6fc2bb00445">rmw_services_t</a> *services, <a class="el" href="types_8h.html#a53491c1cb3622c7e6ca4a553e2c2d222">rmw_clients_t</a> *clients, <a class="el" href="types_8h.html#a44a5648706e809f9641af439d2a0a4a6">rmw_events_t</a> *events, <a class="el" href="types_8h.html#aa2c45fd1040f6af3af5a9fbd241a5665">rmw_wait_set_t</a> *wait_set, const <a class="el" href="time_8h.html#ad4459bc766d7eeca0c324c4650128686">rmw_time_t</a> *wait_timeout)</td></tr>
<tr class="memdesc:a5f480dd59075e80288fb596b2951be2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits on sets of different entities and returns when one is ready.  <a href="rmw_8h.html#a5f480dd59075e80288fb596b2951be2b">More...</a><br /></td></tr>
<tr class="separator:a5f480dd59075e80288fb596b2951be2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a897976680c178e0be5ef4d4a17f9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a64a897976680c178e0be5ef4d4a17f9f">rmw_get_node_names</a> (const <a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *node, <a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/string__array_8h.html#a3673fe65386e017b265debee5fab5cda">rcutils_string_array_t</a> *node_names, <a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/string__array_8h.html#a3673fe65386e017b265debee5fab5cda">rcutils_string_array_t</a> *node_namespaces)</td></tr>
<tr class="memdesc:a64a897976680c178e0be5ef4d4a17f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name and namespace of all nodes in the ROS graph.  <a href="rmw_8h.html#a64a897976680c178e0be5ef4d4a17f9f">More...</a><br /></td></tr>
<tr class="separator:a64a897976680c178e0be5ef4d4a17f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9388d5cc9d2cb460e48f4212735c935"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#aa9388d5cc9d2cb460e48f4212735c935">rmw_get_node_names_with_enclaves</a> (const <a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *node, <a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/string__array_8h.html#a3673fe65386e017b265debee5fab5cda">rcutils_string_array_t</a> *node_names, <a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/string__array_8h.html#a3673fe65386e017b265debee5fab5cda">rcutils_string_array_t</a> *node_namespaces, <a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/string__array_8h.html#a3673fe65386e017b265debee5fab5cda">rcutils_string_array_t</a> *enclaves)</td></tr>
<tr class="memdesc:aa9388d5cc9d2cb460e48f4212735c935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name, namespae, and enclave name of all nodes in the ROS graph.  <a href="rmw_8h.html#aa9388d5cc9d2cb460e48f4212735c935">More...</a><br /></td></tr>
<tr class="separator:aa9388d5cc9d2cb460e48f4212735c935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c761fb53a29f44b41fc299ffbb9cb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a83c761fb53a29f44b41fc299ffbb9cb4">rmw_count_publishers</a> (const <a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *node, const char *topic_name, size_t *count)</td></tr>
<tr class="memdesc:a83c761fb53a29f44b41fc299ffbb9cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of known publishers matching a topic name.  <a href="rmw_8h.html#a83c761fb53a29f44b41fc299ffbb9cb4">More...</a><br /></td></tr>
<tr class="separator:a83c761fb53a29f44b41fc299ffbb9cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d48df829636837092ef47f91514675e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a3d48df829636837092ef47f91514675e">rmw_count_subscribers</a> (const <a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *node, const char *topic_name, size_t *count)</td></tr>
<tr class="memdesc:a3d48df829636837092ef47f91514675e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of known subscribers matching a topic name.  <a href="rmw_8h.html#a3d48df829636837092ef47f91514675e">More...</a><br /></td></tr>
<tr class="separator:a3d48df829636837092ef47f91514675e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846898b23af992f7f3eaa17eaf741e9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a846898b23af992f7f3eaa17eaf741e9f">rmw_get_gid_for_publisher</a> (const <a class="el" href="types_8h.html#acb16586307694dcc71965aacaba5ae98">rmw_publisher_t</a> *publisher, <a class="el" href="types_8h.html#a5be70c7256d63d47870e13224ee1dc57">rmw_gid_t</a> *gid)</td></tr>
<tr class="memdesc:a846898b23af992f7f3eaa17eaf741e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique identifier (gid) of a publisher.  <a href="rmw_8h.html#a846898b23af992f7f3eaa17eaf741e9f">More...</a><br /></td></tr>
<tr class="separator:a846898b23af992f7f3eaa17eaf741e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280fd9c0cf4fc49fbe6786b64b835194"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a280fd9c0cf4fc49fbe6786b64b835194">rmw_compare_gids_equal</a> (const <a class="el" href="types_8h.html#a5be70c7256d63d47870e13224ee1dc57">rmw_gid_t</a> *gid1, const <a class="el" href="types_8h.html#a5be70c7256d63d47870e13224ee1dc57">rmw_gid_t</a> *gid2, bool *result)</td></tr>
<tr class="memdesc:a280fd9c0cf4fc49fbe6786b64b835194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two unique identifiers (gids) are equal.  <a href="rmw_8h.html#a280fd9c0cf4fc49fbe6786b64b835194">More...</a><br /></td></tr>
<tr class="separator:a280fd9c0cf4fc49fbe6786b64b835194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cec9687e5e4738aba7e061014eb3d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#af0cec9687e5e4738aba7e061014eb3d5">rmw_service_server_is_available</a> (const <a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *node, const <a class="el" href="types_8h.html#afc04b99b504df3d1dfc167c4a46214a2">rmw_client_t</a> *client, bool *is_available)</td></tr>
<tr class="memdesc:af0cec9687e5e4738aba7e061014eb3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a service server is available for the given service client.  <a href="rmw_8h.html#af0cec9687e5e4738aba7e061014eb3d5">More...</a><br /></td></tr>
<tr class="separator:af0cec9687e5e4738aba7e061014eb3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95cc3dd8de47abb8a105d0b8a30419c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a95cc3dd8de47abb8a105d0b8a30419c9">rmw_set_log_severity</a> (<a class="el" href="types_8h.html#a607a331d0f863b03e03c892ab45a03a0">rmw_log_severity_t</a> severity)</td></tr>
<tr class="memdesc:a95cc3dd8de47abb8a105d0b8a30419c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current log severity.  <a href="rmw_8h.html#a95cc3dd8de47abb8a105d0b8a30419c9">More...</a><br /></td></tr>
<tr class="separator:a95cc3dd8de47abb8a105d0b8a30419c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea20ab8bae7e3085de0cbe06564b4e93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#aea20ab8bae7e3085de0cbe06564b4e93">rmw_subscription_set_on_new_message_callback</a> (<a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *subscription, <a class="el" href="event__callback__type_8h.html#a1333e7f82698dd85b57c1852c2f090c0">rmw_event_callback_t</a> callback, const void *user_data)</td></tr>
<tr class="memdesc:aea20ab8bae7e3085de0cbe06564b4e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the on new message callback function for the subscription.  <a href="rmw_8h.html#aea20ab8bae7e3085de0cbe06564b4e93">More...</a><br /></td></tr>
<tr class="separator:aea20ab8bae7e3085de0cbe06564b4e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d8166fcd185bb40fa4b316f422e896"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a16d8166fcd185bb40fa4b316f422e896">rmw_service_set_on_new_request_callback</a> (<a class="el" href="types_8h.html#a562ff74fd2c35c006bac0f8a98dabd7e">rmw_service_t</a> *service, <a class="el" href="event__callback__type_8h.html#a1333e7f82698dd85b57c1852c2f090c0">rmw_event_callback_t</a> callback, const void *user_data)</td></tr>
<tr class="memdesc:a16d8166fcd185bb40fa4b316f422e896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the on new request callback function for the service.  <a href="rmw_8h.html#a16d8166fcd185bb40fa4b316f422e896">More...</a><br /></td></tr>
<tr class="separator:a16d8166fcd185bb40fa4b316f422e896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2195fea162b6f4b30f2d7bdd00a56401"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a2195fea162b6f4b30f2d7bdd00a56401">rmw_client_set_on_new_response_callback</a> (<a class="el" href="types_8h.html#afc04b99b504df3d1dfc167c4a46214a2">rmw_client_t</a> *client, <a class="el" href="event__callback__type_8h.html#a1333e7f82698dd85b57c1852c2f090c0">rmw_event_callback_t</a> callback, const void *user_data)</td></tr>
<tr class="memdesc:a2195fea162b6f4b30f2d7bdd00a56401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the on new response callback function for the client.  <a href="rmw_8h.html#a2195fea162b6f4b30f2d7bdd00a56401">More...</a><br /></td></tr>
<tr class="separator:a2195fea162b6f4b30f2d7bdd00a56401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94efb0cd4a8f8b4568eeec1a2e51161"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#af94efb0cd4a8f8b4568eeec1a2e51161">rmw_event_set_callback</a> (<a class="el" href="event_8h.html#a43057ed2076d1cf5a7fa7dda1fd84f47">rmw_event_t</a> *event, <a class="el" href="event__callback__type_8h.html#a1333e7f82698dd85b57c1852c2f090c0">rmw_event_callback_t</a> callback, const void *user_data)</td></tr>
<tr class="memdesc:af94efb0cd4a8f8b4568eeec1a2e51161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback function for the event.  <a href="rmw_8h.html#af94efb0cd4a8f8b4568eeec1a2e51161">More...</a><br /></td></tr>
<tr class="separator:af94efb0cd4a8f8b4568eeec1a2e51161"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6dfb314c4e5edf3c28b1fb1ffe992b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dfb314c4e5edf3c28b1fb1ffe992b0c">&#9670;&nbsp;</a></span>rmw_get_implementation_identifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rmw_get_implementation_identifier </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the rmw implementation being used. </p>
<dl class="section return"><dt>Returns</dt><dd>Name of rmw implementation </dd></dl>

</div>
</div>
<a id="a77d6ce17ee198857a68292a73016f6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d6ce17ee198857a68292a73016f6a4">&#9670;&nbsp;</a></span>rmw_get_serialization_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rmw_get_serialization_format </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the unique serialization format for this middleware. </p>
<p>Return the format in which binary data is serialized. One middleware can only have one encoding. In contrast to the implementation identifier, the serialization format can be equal between multiple RMW implementations. This means, that the same binary messages can be deserialized by RMW implementations with the same format. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rmw_8h.html#a787c040bb59b0470ba51eee7e2bc04cd" title="Serialize a ROS message into a rmw_serialized_message_t.">rmw_serialize</a> </dd>
<dd>
<a class="el" href="rmw_8h.html#a9dee9c2eed962055a68febe9622f807c" title="Deserialize a ROS message.">rmw_deserialize</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>serialization format </dd></dl>

</div>
</div>
<a id="aeb06f551db3cbcd6298ed8f20e3ed8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb06f551db3cbcd6298ed8f20e3ed8d2">&#9670;&nbsp;</a></span>rmw_create_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a>* rmw_create_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="init_8h.html#a60d257a0cc981fb8961bcb0d613f3f2a">rmw_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>namespace_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a node and return a handle to that node. </p>
<p>This function can fail, and therefore return <code>NULL</code>, if:</p><ul>
<li>name is not a valid non-null node name</li>
<li>namespace_ is not a valid non-null namespace</li>
<li>context is not valid i.e. it is zero-initialized, or its implementation identifier does not match that of this API implementation, or has been invalidated by <code><a class="el" href="init_8h.html#a36ece6fcb6294f21a0b69cb091e3ee5a" title="Shutdown the middleware for a given context.">rmw_shutdown()</a></code></li>
<li>memory allocation fails during node creation</li>
<li>an unspecified error occurs</li>
</ul>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">No [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">No [1]   </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<p>This should be defined by the rmw implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>init context that this node should be associated with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the node name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">namespace_</td><td>the node namespace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rmw node handle, or <code>NULL</code> if there was an error </dd></dl>

</div>
</div>
<a id="a0a2c3d9d51ebf753d6c531ab3b42253b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2c3d9d51ebf753d6c531ab3b42253b">&#9670;&nbsp;</a></span>rmw_destroy_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_destroy_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a given node handle, reclaim the resources, and deallocate the node handle. </p>
<p>This function will return early if a logical error, such as <code>RMW_RET_INVALID_ARGUMENT</code> or <code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code>, ensues, leaving the given node handle unchanged. Otherwise, it will proceed despite errors, freeing as many resources as it can, including the node handle. Usage of a deallocated node handle is undefined behavior.</p>
<dl class="section pre"><dt>Precondition</dt><dd>All publishers, subscribers, services, and clients created from this node must have been destroyed prior to this call. Some rmw implementations may verify this, returning <code>RMW_RET_ERROR</code> and setting a human readable error message if any entity created from this node has not yet been destroyed. However, this is not guaranteed and so callers should ensure that this is the case before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>the node handle to be destroyed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if node is invalid, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the implementation identifier does not match, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="ab43ddabd6febd7b1ba0ea60a1a61498f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43ddabd6febd7b1ba0ea60a1a61498f">&#9670;&nbsp;</a></span>rmw_node_assert_liveliness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_node_assert_liveliness </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd><code>rmw_node_assert_liveliness</code> implementation was removed. If manual liveliness assertion is needed, use MANUAL_BY_TOPIC. </dd></dl>

</div>
</div>
<a id="a52ca2bdd798c7b8f69da46d85e8d0fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ca2bdd798c7b8f69da46d85e8d0fb9">&#9670;&nbsp;</a></span>rmw_node_get_graph_guard_condition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="types_8h.html#a81b00c2cb16d5a51f37315c9f708b491">rmw_guard_condition_t</a>* rmw_node_get_graph_guard_condition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a guard condition which is triggered when the ROS graph changes. </p>
<p>The guard condition will be triggered anytime a change to the ROS graph occurs. A ROS graph change occurs whenever:</p><ul>
<li>A node joins or leaves the ROS graph. This change will be reflected in <a class="el" href="rmw_8h.html#a64a897976680c178e0be5ef4d4a17f9f" title="Return the name and namespace of all nodes in the ROS graph.">rmw_get_node_names()</a> and <a class="el" href="rmw_8h.html#aa9388d5cc9d2cb460e48f4212735c935" title="Return the name, namespae, and enclave name of all nodes in the ROS graph.">rmw_get_node_names_with_enclaves()</a> outcome.</li>
<li>A topic subscription joins or leaves the ROS graph. This change will be reflected in <a class="el" href="get__topic__names__and__types_8h.html#a2186a91a382110bdab089f8e4d4d732a" title="Return all topic names and types in the ROS graph.">rmw_get_topic_names_and_types()</a>, <a class="el" href="get__node__info__and__types_8h.html#a51617d9d0dae2fff1af895e40dc96543" title="Return all topic names and types for which a given remote node has subscriptions.">rmw_get_subscriber_names_and_types_by_node()</a>, and <a class="el" href="get__topic__endpoint__info_8h.html#a90ca0ada6a0d95c860d599fd878075f4" title="Retrieve endpoint information for each known subscription of a given topic.">rmw_get_subscriptions_info_by_topic()</a> outcome.</li>
<li>A topic publisher joins or leaves the ROS graph. This change will be reflected in <a class="el" href="get__topic__names__and__types_8h.html#a2186a91a382110bdab089f8e4d4d732a" title="Return all topic names and types in the ROS graph.">rmw_get_topic_names_and_types()</a>, <a class="el" href="get__node__info__and__types_8h.html#aa041b344dc311e73b23dc499e48c5134" title="Return all topic names and types for which a given remote node has publishers.">rmw_get_publisher_names_and_types_by_node()</a>, and <a class="el" href="get__topic__endpoint__info_8h.html#a7b6838a24b048f92d6dc2ba89c20fcf1" title="Retrieve endpoint information for each known publisher of a given topic.">rmw_get_publishers_info_by_topic()</a> outcome.</li>
<li>A topic subscription matches a topic publisher with compatible QoS policies. This change will be reflected in <a class="el" href="rmw_8h.html#a7f83284d1a1a2de0cbbc270fab7e2254" title="Retrieve the number of matched publishers to a subscription.">rmw_subscription_count_matched_publishers()</a> outcome.</li>
<li>A topic publisher matches a topic subscription with compatible QoS policies. This change will be reflected in <a class="el" href="rmw_8h.html#a046ba6f8ff184ebb01ab269b31a49f33" title="Retrieve the number of matched subscriptions to a publisher.">rmw_publisher_count_matched_subscriptions()</a> outcome.</li>
<li>A service server joins or leaves the ROS graph. This change will be reflected in <a class="el" href="get__service__names__and__types_8h.html#abf495afaafacac33473d5f6c9c451ab4" title="Return all service names and types in the ROS graph.">rmw_get_service_names_and_types()</a> and <a class="el" href="get__node__info__and__types_8h.html#a0df0aeec53af4a3fd7096dfe725925d5" title="Return all service names and types for which a given remote node has servers.">rmw_get_service_names_and_types_by_node()</a> outcome.</li>
<li>A service client joins or leaves the ROS graph. This change will be reflected in <a class="el" href="get__service__names__and__types_8h.html#abf495afaafacac33473d5f6c9c451ab4" title="Return all service names and types in the ROS graph.">rmw_get_service_names_and_types()</a> and <a class="el" href="get__node__info__and__types_8h.html#ad8b37cd14eb28137004bb9a8bbd98312" title="Return all service names and types for which a given remote node has clients.">rmw_get_client_names_and_types_by_node()</a> outcome.</li>
<li>A service client matches a service server with compatible QoS policies. This change will be reflected in <a class="el" href="rmw_8h.html#af0cec9687e5e4738aba7e061014eb3d5" title="Check if a service server is available for the given service client.">rmw_service_server_is_available()</a> outcome.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The state of the ROS graph, and any changes that may take place, are reported as seen by the associated <code>node</code>.</dd></dl>
<p>The guard condition is owned and internally held by the <code>node</code>. It will be invalidated if <code>node</code> is finalized using <a class="el" href="rmw_8h.html#a0a2c3d9d51ebf753d6c531ab3b42253b" title="Finalize a given node handle, reclaim the resources, and deallocate the node handle.">rmw_destroy_node()</a>. It is undefined behavior to use an invalidated guard condition.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>node</code> must be a valid node handle, as returned by <a class="el" href="rmw_8h.html#aeb06f551db3cbcd6298ed8f20e3ed8d2" title="Create a node and return a handle to that node.">rmw_create_node()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Node to retrieve the guard condition from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Guard condition if successful, or <code>NULL</code> if <code>node</code> is <code>NULL</code>, or an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="af8d45143cc18afb6dfbeb7abf7c99b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d45143cc18afb6dfbeb7abf7c99b8e">&#9670;&nbsp;</a></span>rmw_init_publisher_allocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_init_publisher_allocation </td>
          <td>(</td>
          <td class="paramtype">const rosidl_message_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_runtime_c__Sequence__bound *&#160;</td>
          <td class="paramname"><em>message_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aee0478e5575d3206d00dea884c18b6bd">rmw_publisher_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a publisher allocation to be used with later publications. </p>
<p>This creates an allocation object that can be used in conjunction with the rmw_publish method to perform more carefully control memory allocations.</p>
<p>This will allow the middleware to preallocate the correct amount of memory for a given message type and message bounds. As allocation is performed in this method, it will not be necessary to allocate in the <code>rmw_publish</code> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_support</td><td>Type support of the message to be preallocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message_bounds</td><td>Bounds structure of the message to be preallocated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">allocation</td><td>Allocation structure to be passed to <code>rmw_publish</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if it's unimplemented </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if an argument is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a1a8ee7b6eef8d2b843484e77ead4992f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8ee7b6eef8d2b843484e77ead4992f">&#9670;&nbsp;</a></span>rmw_fini_publisher_allocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_fini_publisher_allocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#aee0478e5575d3206d00dea884c18b6bd">rmw_publisher_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a publisher allocation object. </p>
<p>This deallocates any memory allocated by <code>rmw_init_publisher_allocation</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Allocation object to be destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if it's unimplemented </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if argument is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="ac74022d90eb22d95b082d4808670f8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74022d90eb22d95b082d4808670f8a9">&#9670;&nbsp;</a></span>rmw_create_publisher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#acb16586307694dcc71965aacaba5ae98">rmw_publisher_t</a>* rmw_create_publisher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_message_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a6f1f6c7a61a3d276ea2758ce2d5ac9c5">rmw_qos_profile_t</a> *&#160;</td>
          <td class="paramname"><em>qos_profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a27c4c36f4d58a0bd0834a27fba8af2bf">rmw_publisher_options_t</a> *&#160;</td>
          <td class="paramname"><em>publisher_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a publisher and return a handle to that publisher. </p>
<p>This function can fail, and therefore return <code>NULL</code>, if:</p><ul>
<li>node is not a valid non-null handle for this rmw implementation, as returned by <code><a class="el" href="rmw_8h.html#aeb06f551db3cbcd6298ed8f20e3ed8d2" title="Create a node and return a handle to that node.">rmw_create_node()</a></code></li>
<li>type_support is a not valid non-null message type support, as returned by <code>ROSIDL_GET_MSG_TYPE_SUPPORT()</code></li>
<li>topic_name is not a valid non-null topic name, according to <code><a class="el" href="validate__full__topic__name_8h.html#a5bf7cd29da7f1c6c28bff9e24fa8328d" title="Determine if a given fully qualified topic name is valid.">rmw_validate_full_topic_name()</a></code></li>
<li>qos_profile is not a fully specified non-null profile i.e. no UNKNOWN policies</li>
<li>publisher_options is not a valid non-null option set, as returned by <code><a class="el" href="publisher__options_8h.html#af88f271e589b70ac0084488281f4637d" title="Return a rmw_publisher_options_t initialized with default values.">rmw_get_default_publisher_options()</a></code></li>
<li>memory allocation fails during publisher creation</li>
<li>an unspecified error occurs</li>
</ul>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Handle to node with which to register this publisher </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_support</td><td>Type support for the messages to be published </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topic_name</td><td>Name of the topic to publish to, often a fully qualified topic name unless <code>qos_profile</code> is configured to avoid ROS namespace conventions i.e. to create a native topic publisher </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qos_profile</td><td>QoS policies for this publisher </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher_options</td><td>Options to configure this publisher </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rmw publisher handle, or <code>NULL</code> if there was an error </dd></dl>

</div>
</div>
<a id="a297f8ae702c5f1eb51c40928e735de74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297f8ae702c5f1eb51c40928e735de74">&#9670;&nbsp;</a></span>rmw_destroy_publisher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_destroy_publisher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#acb16586307694dcc71965aacaba5ae98">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a given publisher handle, reclaim the resources, and deallocate the publisher handle. </p>
<p>This function will return early if a logical error, such as <code>RMW_RET_INVALID_ARGUMENT</code> or <code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code>, ensues, leaving the given publisher handle unchanged. Otherwise, it will proceed despite errors, freeing as many resources as it can, including the publisher handle. Usage of a deallocated publisher handle is undefined behavior.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Given node must be the one the publisher was registered with.</dd></dl>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Handle to node with which the given publisher is registered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>Handle to publisher to be finalized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if node or publisher is <code>NULL</code>, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if node or publisher implementation identifier does not match, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="ae0768752013e0a1ee2776a303d3fc074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0768752013e0a1ee2776a303d3fc074">&#9670;&nbsp;</a></span>rmw_borrow_loaned_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_borrow_loaned_message </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#acb16586307694dcc71965aacaba5ae98">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_message_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ros_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Borrow a loaned ROS message. </p>
<p>This ROS message is owned by the middleware, that will keep it alive (i.e. in valid memory space) until the caller publishes it using <a class="el" href="rmw_8h.html#ab01da69d8613952343abd5d65107399a" title="Publish a loaned ROS message.">rmw_publish_loaned_message()</a> or returns it using <a class="el" href="rmw_8h.html#abbd05b65f77e840f7276397fdbf64894" title="Return a loaned message previously borrowed from a publisher.">rmw_return_loaned_message_from_publisher()</a>.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check implementation documentation.</em></p>
<dl class="section user"><dt>Runtime behavior</dt><dd>To borrow a ROS message is a synchronous operation. It is also non-blocking, but it is not guaranteed to be lock-free. Generally speaking, implementations may synchronize access to internal resources using locks but are not allowed to wait for events with no guaranteed time bound (barring the effects of starvation due to OS scheduling).</dd></dl>
<dl class="section user"><dt>Memory allocation</dt><dd>It is implementation defined whether memory will be allocated on borrow or not. Check the implementation documentation to learn about memory allocation guarantees when using ROS message loaning support.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Publishers are thread-safe objects, and so are all operations on them except for finalization. Therefore, it is safe to borrow ROS messages from the same publisher concurrently.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>publisher</code> must be a valid publisher, as returned by <a class="el" href="rmw_8h.html#ac74022d90eb22d95b082d4808670f8a9" title="Create a publisher and return a handle to that publisher.">rmw_create_publisher()</a>. </dd>
<dd>
Given <code>type_support</code> must be a valid <code>rosidl</code> message type support, matching the one registered with the <code>publisher</code> on creation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>Publisher to which the loaned ROS message will be associated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_support</td><td>Message type support of the loaned ROS message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ros_message</td><td>Pointer to type erased ROS message loaned by the middleware. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation fails, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>publisher</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>type_support</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>ros_message</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>*ros_message</code> is not NULL (to prevent leaks), or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if <code>publisher</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if the implementation does not support ROS message loaning, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occured. </dd></dl>

</div>
</div>
<a id="abbd05b65f77e840f7276397fdbf64894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd05b65f77e840f7276397fdbf64894">&#9670;&nbsp;</a></span>rmw_return_loaned_message_from_publisher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_return_loaned_message_from_publisher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#acb16586307694dcc71965aacaba5ae98">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>loaned_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a loaned message previously borrowed from a publisher. </p>
<p>Tells the middleware that a borrowed ROS message is no longer needed by the caller. Ownership of the ROS message is given back to the middleware. If this function fails early due to a logical error, such as an invalid argument, the loaned ROS message will be left unchanged. Otherwise, ownership of the ROS message will be given back to the middleware. It is up to the middleware what will be made of the returned ROS message. It is undefined behavior to use a loaned ROS message after returning it.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check implementation documentation.</em></p>
<dl class="section user"><dt>Runtime behavior</dt><dd>To return a ROS message is a synchronous operation. It is also non-blocking, but it is not guaranteed to be lock-free. Generally speaking, implementations may synchronize access to internal resources using locks but are not allowed to wait for events with no guaranteed time bound (barring the effects of starvation due to OS scheduling).</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Publishers are thread-safe objects, and so are all operations on them except for finalization. Therefore, it is safe to return borrowed ROS messages to the same publisher concurrently. However, since ownership of the loaned ROS message is given back to the middleware and this transfer is not synchronized, it is not safe to return the same loaned ROS message concurrently.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>publisher</code> must be a valid publisher, as returned by <a class="el" href="rmw_8h.html#ac74022d90eb22d95b082d4808670f8a9" title="Create a publisher and return a handle to that publisher.">rmw_create_publisher()</a>. </dd>
<dd>
Given <code>loaned_message</code> must have been previously borrowed from the same publisher using <a class="el" href="rmw_8h.html#ae0768752013e0a1ee2776a303d3fc074" title="Borrow a loaned ROS message.">rmw_borrow_loaned_message()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>Publisher to which the loaned ROS message is associated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">loaned_message</td><td>Type erased loaned ROS message to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>publisher</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>loaned_message</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if <code>publisher</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if the implementation does not support ROS message loaning, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs and no message can be initialized. </dd></dl>

</div>
</div>
<a id="ab625a62ba2f32e3d3a7c7ca1f6e0dbd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab625a62ba2f32e3d3a7c7ca1f6e0dbd6">&#9670;&nbsp;</a></span>rmw_publish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_publish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#acb16586307694dcc71965aacaba5ae98">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ros_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aee0478e5575d3206d00dea884c18b6bd">rmw_publisher_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publish a ROS message. </p>
<p>Send a ROS message to all subscriptions with matching QoS policies using the given publisher.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check implementation documentation.</em></p>
<dl class="section user"><dt>Runtime behavior</dt><dd>It is implementation defined whether to publish a ROS message is a synchronous or asynchronous, blocking or non-blocking operation. However, asynchronous implementations are not allowed to access the given ROS message after this function returns. Check the implementation documentation to learn about publish behavior.</dd></dl>
<dl class="section user"><dt>Memory allocation</dt><dd>It is implementation defined whether memory will be allocated on publish or not. For instance, implementations that serialize ROS messages to send it over the wire may need to perform additional memory allocations when dealing with unbounded (dynamically-sized) fields. A publisher allocation, if provided, may or may not be used. Check the implementation documentation to learn about memory allocation guarantees when publishing ROS messages with and without publisher allocations.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Publishers are thread-safe objects, and so are all operations on them except for finalization. Therefore, it is safe to publish using the same publisher concurrently. However, when publishing regular ROS messages:<ul>
<li>Access to the ROS message is read-only but it is not synchronized. Concurrent <code>ros_message</code> reads are safe, but concurrent reads and writes are not.</li>
<li>Access to the publisher allocation is not synchronized, unless specifically stated otherwise by the implementation. Thus, it is generally not safe to read or write <code>allocation</code> while <a class="el" href="rmw_8h.html#ab625a62ba2f32e3d3a7c7ca1f6e0dbd6" title="Publish a ROS message.">rmw_publish()</a> uses it. Check the implementation documentation to learn about publisher allocations' thread-safety.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>publisher</code> must be a valid publisher, as returned by <a class="el" href="rmw_8h.html#ac74022d90eb22d95b082d4808670f8a9" title="Create a publisher and return a handle to that publisher.">rmw_create_publisher()</a>. </dd>
<dd>
Given <code>ros_message</code> must be a valid message, whose type matches the message type support the <code>publisher</code> was registered with on creation. </dd>
<dd>
If not NULL, given <code>allocation</code> must be a valid publisher allocation, initialized with rmw_publisher_allocation_init() with a message type support that matches the one registered with <code>publisher</code> on creation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>Publisher to be used to send message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ros_message</td><td>Type erased ROS message to be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Pre-allocated memory to be used. May be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>publisher</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>ros_message</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if <code>publisher</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="ab01da69d8613952343abd5d65107399a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01da69d8613952343abd5d65107399a">&#9670;&nbsp;</a></span>rmw_publish_loaned_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_publish_loaned_message </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#acb16586307694dcc71965aacaba5ae98">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ros_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aee0478e5575d3206d00dea884c18b6bd">rmw_publisher_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publish a loaned ROS message. </p>
<p>Send a previously borrowed ROS message to all subscriptions with matching QoS policies using the given publisher, then return ROS message ownership to the middleware.</p>
<p>If this function fails early due to a logical error, such as an invalid argument, the loaned ROS message will be left unchanged. Otherwise, ownership of the ROS message will be given back to the middleware. It is up to the middleware what will be made of the returned ROS message. It is undefined behavior to use a loaned ROS message after publishing it.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check the implementation documentation.</em></p>
<dl class="section user"><dt>Runtime behavior</dt><dd>It is implementation defined whether to publish a loaned ROS message is a synchronous or asynchronous, blocking or non-blocking operation. Check the implementation documentation to learn about publish behavior.</dd></dl>
<dl class="section user"><dt>Memory allocation</dt><dd>It is implementation defined whether memory will be allocated on publish or not. For instance, implementations that serialize ROS messages to send it over the wire may need to perform additional memory allocations when dealing with unbounded (dynamically-sized) fields. A publisher allocation, if provided, may or may not be used. Check the implementation documentation to learn about memory allocation guarantees when publishing loaned ROS messages with and without publisher allocations.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Publishers are thread-safe objects, and so are all operations on them except for finalization. Therefore, it is safe to publish using the same publisher concurrently. However, when publishing loaned ROS messages:<ul>
<li>Ownership of the loaned ROS message is given back to the middleware. This transfer is not synchronized, and thus it is not safe to publish the same loaned ROS message concurrently.</li>
<li>Access to the publisher allocation is not synchronized, unless specifically stated otherwise by the implementation. Thus, it is generally not safe to read or write <code>allocation</code> while <a class="el" href="rmw_8h.html#ab625a62ba2f32e3d3a7c7ca1f6e0dbd6" title="Publish a ROS message.">rmw_publish()</a> uses it. Check the implementation documentation to learn about publisher allocations' thread-safety.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>publisher</code> must be a valid publisher, as returned by <a class="el" href="rmw_8h.html#ac74022d90eb22d95b082d4808670f8a9" title="Create a publisher and return a handle to that publisher.">rmw_create_publisher()</a>. </dd>
<dd>
Given <code>ros_message</code> must be a valid message, borrowed from the same publisher using <a class="el" href="rmw_8h.html#ae0768752013e0a1ee2776a303d3fc074" title="Borrow a loaned ROS message.">rmw_borrow_loaned_message()</a>. </dd>
<dd>
If not NULL, given <code>allocation</code> must be a valid publisher allocation, initialized with rmw_publisher_allocation_init() with a message type support that matches the one registered with <code>publisher</code> on creation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>Publisher to be used to send message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ros_message</td><td>Loaned type erased ROS message to be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Pre-allocated memory to be used. May be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>publisher</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>ros_message</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if <code>publisher</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if the implementation does not support ROS message loaning, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a046ba6f8ff184ebb01ab269b31a49f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a046ba6f8ff184ebb01ab269b31a49f33">&#9670;&nbsp;</a></span>rmw_publisher_count_matched_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_publisher_count_matched_subscriptions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#acb16586307694dcc71965aacaba5ae98">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>subscription_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the number of matched subscriptions to a publisher. </p>
<p>Query the underlying middleware to determine how many subscriptions are matched to a given publisher.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>the publisher object to inspect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">subscription_count</td><td>the number of subscriptions matched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if either argument is null, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if publisher implementation identifier does not match, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a809010ecc3e404d8880382e2d4b35976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a809010ecc3e404d8880382e2d4b35976">&#9670;&nbsp;</a></span>rmw_publisher_get_actual_qos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_publisher_get_actual_qos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#acb16586307694dcc71965aacaba5ae98">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a6f1f6c7a61a3d276ea2758ce2d5ac9c5">rmw_qos_profile_t</a> *&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the actual qos settings of the publisher. </p>
<p>Query the underlying middleware to determine the qos settings of the publisher. The actual configuration applied when using RMW_*_SYSTEM_DEFAULT can only be resolved after the creation of the publisher, and it depends on the underlying rmw implementation. If the underlying setting in use can't be represented in ROS terms, it will be set to RMW_*_UNKNOWN.</p>
<dl class="section note"><dt>Note</dt><dd>The value of avoid_ros_namespace_conventions field is not resolved with this function. The rcl function <code>rcl_publisher_get_actual_qos()</code> resolves it.</dd></dl>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>the publisher object to inspect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qos</td><td>the actual qos settings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if either argument is null, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if publisher implementation identifier does not match, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="abca69c33387b6185146c3f115ec2a24a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca69c33387b6185146c3f115ec2a24a">&#9670;&nbsp;</a></span>rmw_publish_serialized_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_publish_serialized_message </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#acb16586307694dcc71965aacaba5ae98">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *&#160;</td>
          <td class="paramname"><em>serialized_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aee0478e5575d3206d00dea884c18b6bd">rmw_publisher_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publish a ROS message as a byte stream. </p>
<p>Send a ROS message serialized as a byte stream to all subscriptions with matching QoS policies using the given publisher. A ROS message can be serialized manually using <a class="el" href="rmw_8h.html#a787c040bb59b0470ba51eee7e2bc04cd" title="Serialize a ROS message into a rmw_serialized_message_t.">rmw_serialize()</a>.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check the implementation documentation.</em></p>
<dl class="section user"><dt>Runtime behavior</dt><dd>It is implementation defined whether to publish a loaned ROS message is a synchronous or asynchronous, blocking or non-blocking operation. However, asynchronous implementations are not allowed to access the given byte stream after this function returns. Check the implementation documentation to learn about publish behavior.</dd></dl>
<dl class="section user"><dt>Memory allocation</dt><dd>It is implementation defined whether memory will be allocated on publish or not. Even if a publisher allocation is provided, an implementation may ignore it. Check the implementation documentation to learn about memory allocation guarantees when publishing serialized messages with and without publisher allocations.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Publishers are thread-safe objects, and so are all operations on them except for finalization. Therefore, it is safe to publish using the same publisher concurrently. However, when publishing serialized ROS messages:<ul>
<li>Access to the byte stream is read-only but it is not synchronized. Concurrent <code>serialized_message</code> reads are safe, but concurrent reads and writes are not.</li>
<li>Access to the publisher allocation is not synchronized, unless specifically stated otherwise by the implementation. Thus, it is generally not safe to read or write <code>allocation</code> while <a class="el" href="rmw_8h.html#ab625a62ba2f32e3d3a7c7ca1f6e0dbd6" title="Publish a ROS message.">rmw_publish()</a> uses it. Check the implementation documentation to learn about publisher allocations' thread-safety.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>publisher</code> must be a valid publisher, as returned by <a class="el" href="rmw_8h.html#ac74022d90eb22d95b082d4808670f8a9" title="Create a publisher and return a handle to that publisher.">rmw_create_publisher()</a>. </dd>
<dd>
Given <code>serialized_message</code> must be a valid serialized message, initialized by <a class="el" href="serialized__message_8h.html#afeb4d43a474541ae2ec82f797dc99573" title="Initialize a serialized message, zero initializing its contents.">rmw_serialized_message_init()</a> and containing the serialization of a ROS message whose type matches the message type support the <code>publisher</code> was registered with on creation. </dd>
<dd>
If not NULL, given <code>allocation</code> must be a valid publisher allocation, initialized with rmw_publisher_allocation_init() with a message type support that matches the one registered with <code>publisher</code> on creation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>Publisher to be used to send message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">serialized_message</td><td>Serialized ROS message to be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Pre-allocated memory to be used. May be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>publisher</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>serialized_message</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if <code>publisher</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a0c172e30e87562f7f7ad25bae8b0ec8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c172e30e87562f7f7ad25bae8b0ec8b">&#9670;&nbsp;</a></span>rmw_get_serialized_message_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_get_serialized_message_size </td>
          <td>(</td>
          <td class="paramtype">const rosidl_message_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_runtime_c__Sequence__bound *&#160;</td>
          <td class="paramname"><em>message_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the size of a serialized message. </p>
<p>Given a message definition and bounds, compute the serialized size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_support</td><td>The type support of the message to compute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message_bounds</td><td>Artifical bounds to use on unbounded fields. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>The computed size of the serialized message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if either argument is null, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if it's unimplemented, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a1e4025992c2194103d3fe417d2373e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4025992c2194103d3fe417d2373e95">&#9670;&nbsp;</a></span>rmw_publisher_assert_liveliness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_publisher_assert_liveliness </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#acb16586307694dcc71965aacaba5ae98">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manually assert that this Publisher is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC) </p>
<p>If the rmw Liveliness policy is set to RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC, the creator of this publisher may manually call <code>assert_liveliness</code> at some point in time to signal to the rest of the system that this Node is still alive.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>handle to the publisher that needs liveliness to be asserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if the liveliness assertion was completed successfully, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unspecified error occurs, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if the rmw implementation does not support asserting liveliness. </dd></dl>

</div>
</div>
<a id="abf4a6bedeecb634f1226df03c53f5238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4a6bedeecb634f1226df03c53f5238">&#9670;&nbsp;</a></span>rmw_publisher_wait_for_all_acked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_publisher_wait_for_all_acked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#acb16586307694dcc71965aacaba5ae98">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="time_8h.html#ad4459bc766d7eeca0c324c4650128686">rmw_time_t</a>&#160;</td>
          <td class="paramname"><em>wait_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until all published message data is acknowledged or until the specified timeout elapses. </p>
<p>This function waits until all published message data were acknowledged by peer node or timeout.</p>
<p>This function only works effectively while QOS profile of publisher is set to RELIABLE. Otherwise this function will immediately return RMW_RET_OK.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<dl class="section user"><dt>Runtime behavior</dt><dd>Waiting for all acknowledgments is synchronous operation. So the calling thread is blocked until all published message data is acknowledged or specified duration elapses.</dd></dl>
<dl class="section user"><dt>Thread-Safety</dt><dd>Publishers are thread-safe objects, and so are all operations on them except for finalization. Therefore, it is safe to call this function using the same publisher concurrently.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>publisher</code> must be a valid publisher, as returned by <a class="el" href="rmw_8h.html#ac74022d90eb22d95b082d4808670f8a9" title="Create a publisher and return a handle to that publisher.">rmw_create_publisher()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>handle to the publisher that needs to wait for all acked. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_timeout</td><td>represents the maximum amount of time to wait for all published message data were acknowledged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_TIMEOUT</code> if wait timed out, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>publisher</code> is <code>NULL</code>, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>publisher</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unspecified error occurs, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if the rmw implementation is unimplemented. </dd></dl>

</div>
</div>
<a id="a787c040bb59b0470ba51eee7e2bc04cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787c040bb59b0470ba51eee7e2bc04cd">&#9670;&nbsp;</a></span>rmw_serialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_serialize </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ros_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_message_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *&#160;</td>
          <td class="paramname"><em>serialized_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize a ROS message into a rmw_serialized_message_t. </p>
<p>The ROS message is serialized into a byte stream contained within the rmw_serialized_message_t structure. The serialization format depends on the underlying implementation.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Given ROS message must be a valid non-null instance, initialized by the caller and matching the provided typesupport. </dd>
<dd>
Given typesupport must be a valid non-null instance, as provided by <code>rosidl</code> APIs. </dd>
<dd>
Given serialized message must be a valid non-null instance, initialized by the caller.</dd></dl>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [2]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [2]   </td></tr>
</table>
<p><em>[1] if the given serialized message does not have enough capacity to hold the ROS message serialization</em> <em>[2] rmw implementation defined, check the implementation documentation</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ros_message</td><td>the typed ROS message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_support</td><td>the typesupport for the ROS message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">serialized_message</td><td>the destination for the serialize ROS message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation failed, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a9dee9c2eed962055a68febe9622f807c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dee9c2eed962055a68febe9622f807c">&#9670;&nbsp;</a></span>rmw_deserialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_deserialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *&#160;</td>
          <td class="paramname"><em>serialized_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_message_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ros_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialize a ROS message. </p>
<p>The given rmw_serialized_message_t's internal byte stream buffer is deserialized into the given ROS message. The serialization format expected in the rmw_serialized_message_t depends on the underlying implementation.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Given serialized message must be a valid non-null instance, such as that returned by <code><a class="el" href="rmw_8h.html#a787c040bb59b0470ba51eee7e2bc04cd" title="Serialize a ROS message into a rmw_serialized_message_t.">rmw_serialize()</a></code>, matching provided typesupport and ROS message. </dd>
<dd>
Given typesupport must be a valid non-null instance, as provided by <code>rosidl</code> APIs. </dd>
<dd>
Given ROS message must be a valid non-null instance, initialized by the caller.</dd></dl>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [2]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [2]   </td></tr>
</table>
<p><em>[1] if the given ROS message contains unbounded fields</em> <em>[2] rmw implementation defined, check the implementation documentation</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">serialized_message</td><td>the serialized message holding the byte stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_support</td><td>the typesupport for the typed ros message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ros_message</td><td>destination for the deserialized ROS message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation failed, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a68cb3b9b96efa6d370257d83598d4bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68cb3b9b96efa6d370257d83598d4bed">&#9670;&nbsp;</a></span>rmw_init_subscription_allocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_init_subscription_allocation </td>
          <td>(</td>
          <td class="paramtype">const rosidl_message_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_runtime_c__Sequence__bound *&#160;</td>
          <td class="paramname"><em>message_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a74a8ca7ddfdd8734690fe56d8afe9fd2">rmw_subscription_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a subscription allocation to be used with later <code>take</code>s. </p>
<p>This creates an allocation object that can be used in conjunction with the rmw_take method to perform more carefully control memory allocations.</p>
<p>This will allow the middleware to preallocate the correct amount of memory for a given message type and message bounds. As allocation is performed in this method, it will not be necessary to allocate in the <code>rmw_take</code> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_support</td><td>Type support of the message to be preallocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message_bounds</td><td>Bounds structure of the message to be preallocated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">allocation</td><td>Allocation structure to be passed to <code>rmw_take</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if it's unimplemented </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if an argument is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a26e2408746a0e03bdaa290ef32780253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e2408746a0e03bdaa290ef32780253">&#9670;&nbsp;</a></span>rmw_fini_subscription_allocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_fini_subscription_allocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a74a8ca7ddfdd8734690fe56d8afe9fd2">rmw_subscription_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a publisher allocation object. </p>
<p>This deallocates memory allocated by <code>rmw_init_subscription_allocation</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Allocation object to be destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if it's unimplemented </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if argument is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a3a864d424c6aa5fc57b1ca3dbe19a697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a864d424c6aa5fc57b1ca3dbe19a697">&#9670;&nbsp;</a></span>rmw_create_subscription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a>* rmw_create_subscription </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_message_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a6f1f6c7a61a3d276ea2758ce2d5ac9c5">rmw_qos_profile_t</a> *&#160;</td>
          <td class="paramname"><em>qos_policies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a3f24759469ff4dc82f5315e19ba2faee">rmw_subscription_options_t</a> *&#160;</td>
          <td class="paramname"><em>subscription_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a subscription and return a handle to that subscription. </p>
<p>This function can fail, and therefore return <code>NULL</code>, if:</p><ul>
<li>node is not a valid non-null handle for this rmw implementation, as returned by <code><a class="el" href="rmw_8h.html#aeb06f551db3cbcd6298ed8f20e3ed8d2" title="Create a node and return a handle to that node.">rmw_create_node()</a></code></li>
<li>type_support is a not valid non-null message type support, as returned by <code>ROSIDL_GET_MSG_TYPE_SUPPORT()</code></li>
<li>topic_name is not a valid non-null topic name, according to <code><a class="el" href="validate__full__topic__name_8h.html#a5bf7cd29da7f1c6c28bff9e24fa8328d" title="Determine if a given fully qualified topic name is valid.">rmw_validate_full_topic_name()</a></code> if ROS namespace conventions apply</li>
<li>qos_profile is not a fully specified non-null profile i.e. no UNKNOWN policies</li>
<li>subscription_options is not a valid non-null option set, such as the one returned by <code><a class="el" href="subscription__options_8h.html#a79563bc123e118fe93c9ce1b63c78b55" title="Return a rmw_subscription_options_t initialized with default values.">rmw_get_default_subscription_options()</a></code></li>
<li>memory allocation fails during subscription creation</li>
<li>an unspecified error occurs</li>
</ul>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Handle to node with which to register this subscription </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_support</td><td>Type support for the messages to be subscribed to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topic_name</td><td>Name of the topic to subscribe to, often a fully qualified topic name unless <code>qos_profile</code> is configured to avoid ROS namespace conventions i.e. to create a native topic subscription </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qos_policies</td><td>QoS policies for this subscription </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription_options</td><td>Options for configuring this subscription </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rmw subscription handle, or <code>NULL</code> if there was an error </dd></dl>

</div>
</div>
<a id="a606270f7d253dba6eb9c279061bd2b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606270f7d253dba6eb9c279061bd2b6c">&#9670;&nbsp;</a></span>rmw_destroy_subscription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_destroy_subscription </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finalize a given subscription handle, reclaim the resources, and deallocate the subscription handle. This function will return early if a logical error, namely <code>RMW_RET_INVALID_ARGUMENT</code> or <code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code>, ensues, leaving the given subscription handle unchanged. Otherwise, it will proceed despite errors, freeing as many resources as it can, including the subscription handle, and return <code>RMW_RET_ERROR</code>. Usage of a deallocated subscription handle is undefined behavior.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Given node must be the one the subscription was registered with.</dd></dl>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Handle to node with which the given subscription is registered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>Handle to subscription to be finalized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if node or subscription is <code>NULL</code>, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if node or subscription implementation identifier does not match, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a7f83284d1a1a2de0cbbc270fab7e2254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f83284d1a1a2de0cbbc270fab7e2254">&#9670;&nbsp;</a></span>rmw_subscription_count_matched_publishers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_subscription_count_matched_publishers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>publisher_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the number of matched publishers to a subscription. </p>
<p>Query the underlying middleware to determine how many publishers are matched to a given subscription.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>the subscription object to inspect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">publisher_count</td><td>the number of publishers matched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if either argument is null, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if subscription implementation identifier does not match, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a1b2db56457082adaf379577e4f963bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2db56457082adaf379577e4f963bce">&#9670;&nbsp;</a></span>rmw_subscription_get_actual_qos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_subscription_get_actual_qos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a6f1f6c7a61a3d276ea2758ce2d5ac9c5">rmw_qos_profile_t</a> *&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the actual qos settings of the subscription. </p>
<p>Query the underlying middleware to determine the qos settings of the subscription. The actual configuration applied when using RMW_*_SYSTEM_DEFAULT can only be resolved after the creation of the subscription, and it depends on the underlying rmw implementation. If the underlying setting in use can't be represented in ROS terms, it will be set to RMW_*_UNKNOWN.</p>
<dl class="section note"><dt>Note</dt><dd>The value of avoid_ros_namespace_conventions field is not resolved with this function. The rcl function <code>rcl_subscription_get_actual_qos()</code> resolves it.</dd></dl>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>the subscription object to inspect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qos</td><td>the actual qos settings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if either argument is null, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if subscription implementation identifier does not match, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a061635ca547422e597f3c084d0f67c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a061635ca547422e597f3c084d0f67c4d">&#9670;&nbsp;</a></span>rmw_subscription_set_content_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_subscription_set_content_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="subscription__content__filter__options_8h.html#a8e46bff7989aa4f5f0d02124bffbf0e8">rmw_subscription_content_filter_options_t</a> *&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the content filter options for the subscription. </p>
<p>This function will set a filter expression and an array of expression parameters for the given subscription.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check the implementation documentation</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>The subscription to set content filter options. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>The content filter options. Use <code>options.filter_expression</code> with an empty("") string to reset/clean content filtered topic for the subscription. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if an argument is null, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>subscription</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if the implementation does not support content filtered topic, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a8a1d9a5acc817f2e6d84f9136b06a8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1d9a5acc817f2e6d84f9136b06a8cd">&#9670;&nbsp;</a></span>rmw_subscription_get_content_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_subscription_get_content_filter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/allocator_8h.html#a2b0c5a16a0401a4afb39d352ff999019">rcutils_allocator_t</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="subscription__content__filter__options_8h.html#a8e46bff7989aa4f5f0d02124bffbf0e8">rmw_subscription_content_filter_options_t</a> *&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the content filter options of the subscription. </p>
<p>This function will return a content filter options by the given subscription.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check the implementation documentation</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>The subscription object to inspect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Allocator to be used when populating the content filter options. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">options</td><td>The content filter options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if an argument is null, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>subscription</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation fails, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if the implementation does not support content filtered topic, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="af9bf29af7069593e2f8dfa2296710080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bf29af7069593e2f8dfa2296710080">&#9670;&nbsp;</a></span>rmw_take()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_take </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ros_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>taken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a74a8ca7ddfdd8734690fe56d8afe9fd2">rmw_subscription_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take an incoming ROS message. </p>
<p>Take a ROS message already received by the given subscription, removing it from internal queues. This function will succeed even if no ROS message was received, but <code>taken</code> will be false.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The same ROS message cannot be taken twice. Callers do not have to deal with duplicates.</dd></dl>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check implementation documentation.</em></p>
<dl class="section user"><dt>Runtime behavior</dt><dd>To take a ROS message is a synchronous operation. It is also non-blocking, to the extent it will not wait for new ROS messages to arrive, but it is not guaranteed to be lock-free. Generally speaking, implementations may synchronize access to internal resources using locks but are not allowed to wait for events with no guaranteed time bound (barring the effects of starvation due to OS scheduling).</dd></dl>
<dl class="section user"><dt>Memory allocation</dt><dd>It is implementation defined whether memory will be allocated on take or not. For instance, implementations that deserialize ROS messages received over the wire may need to perform additional memory allocations when dealing with unbounded (dynamically-sized) fields. A subscription allocation, if provided, may or may not be used. Check the implementation documentation to learn about memory allocation guarantees when taking ROS messages with and without subscription allocations.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Subscriptions are thread-safe objects, and so are all operations on them except for finalization. Therefore, it is safe to take from the same subscription concurrently. However, when taking regular ROS messages:<ul>
<li>Access to the given ROS message is not synchronized. It is not safe to read or write <code>ros_message</code> while <a class="el" href="rmw_8h.html#af9bf29af7069593e2f8dfa2296710080" title="Take an incoming ROS message.">rmw_take()</a> uses it.</li>
<li>Access to given primitive data-type arguments is not synchronized. It is not safe to read or write <code>taken</code> while <a class="el" href="rmw_8h.html#af9bf29af7069593e2f8dfa2296710080" title="Take an incoming ROS message.">rmw_take()</a> uses it.</li>
<li>Access to the given subscription allocation is not synchronized, unless specifically stated otherwise by the implementation. Thus, it is generally not safe to read or write <code>allocation</code> while <a class="el" href="rmw_8h.html#af9bf29af7069593e2f8dfa2296710080" title="Take an incoming ROS message.">rmw_take()</a> uses it. Check the implementation documentation to learn about subscription allocations' thread-safety.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>subscription</code> must be a valid subscription, as returned by <a class="el" href="rmw_8h.html#a3a864d424c6aa5fc57b1ca3dbe19a697" title="Create a subscription and return a handle to that subscription.">rmw_create_subscription()</a>. </dd>
<dd>
Given <code>ros_message</code> must be a valid message, whose type matches the message type support registered with the <code>subscription</code> on creation. </dd>
<dd>
If not NULL, given <code>allocation</code> must be a valid subscription allocation initialized with rmw_subscription_allocation_init() with a message type support that matches the one registered with the <code>subscription</code> on creation. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Given <code>ros_message</code> will remain a valid message. It will be left unchanged if this function fails early due to a logical error, such as an invalid argument, or in an unknown yet valid state if it fails due to a runtime error. It will also be left unchanged if this function succeeds but <code>taken</code> is false.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>Subscription to take message from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ros_message</td><td>Type erased ROS message to write to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taken</td><td>Boolean flag indicating if a ROS message was taken or not. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Pre-allocated memory to be used. May be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation fails, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>subscription</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>ros_message</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>taken</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>subscription</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a8498c763a02e0fe9203ab6c9dfba0408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8498c763a02e0fe9203ab6c9dfba0408">&#9670;&nbsp;</a></span>rmw_take_with_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_take_with_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ros_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>taken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#abc926cd584b2ce189a89ae20aaab817b">rmw_message_info_t</a> *&#160;</td>
          <td class="paramname"><em>message_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a74a8ca7ddfdd8734690fe56d8afe9fd2">rmw_subscription_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take an incoming ROS message with its metadata. </p>
<p>Same as <a class="el" href="rmw_8h.html#af9bf29af7069593e2f8dfa2296710080" title="Take an incoming ROS message.">rmw_take()</a>, except it also takes ROS message metadata.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check implementation documentation.</em></p>
<dl class="section user"><dt>Runtime behavior</dt><dd>To take a ROS message with its metadata is a synchronous operation. It is also non-blocking, to the extent it will not wait for new ROS messages to arrive, but it is not guaranteed to be lock-free. Generally speaking, implementations may synchronize access to internal resources using locks but are not allowed to wait for events with no guaranteed time bound (barring the effects of starvation due to OS scheduling).</dd></dl>
<dl class="section user"><dt>Memory allocation</dt><dd>It is implementation defined whether memory will be allocated on take or not. For instance, implementations that deserialize ROS messages received over the wire may need to perform additional memory allocations when dealing with unbounded (dynamically-sized) fields. A subscription allocation, if provided, may or may not be used. Check the implementation documentation to learn about memory allocation guarantees when taking ROS messages with and without subscription allocations.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Subscriptions are thread-safe objects, and so are all operations on them except for finalization. Therefore, it is safe to take from the same subscription concurrently. However, when taking regular ROS messages with metadata:<ul>
<li>Access to the given ROS message is not synchronized. It is not safe to read or write <code>ros_message</code> while <a class="el" href="rmw_8h.html#a8498c763a02e0fe9203ab6c9dfba0408" title="Take an incoming ROS message with its metadata.">rmw_take_with_info()</a> uses it.</li>
<li>Access to given primitive data-type arguments is not synchronized. It is not safe to read or write <code>taken</code> while <a class="el" href="rmw_8h.html#a8498c763a02e0fe9203ab6c9dfba0408" title="Take an incoming ROS message with its metadata.">rmw_take_with_info()</a> uses it.</li>
<li>Access to the given ROS message metadata is not synchronized. It is not safe to read or write <code>message_info</code> while <a class="el" href="rmw_8h.html#a8498c763a02e0fe9203ab6c9dfba0408" title="Take an incoming ROS message with its metadata.">rmw_take_with_info()</a> uses it.</li>
<li>Access to the given subscription allocation is not synchronized, unless specifically stated otherwise by the implementation. Thus, it is generally not safe to read or write <code>allocation</code> while <a class="el" href="rmw_8h.html#a8498c763a02e0fe9203ab6c9dfba0408" title="Take an incoming ROS message with its metadata.">rmw_take_with_info()</a> uses it. Check the implementation documentation to learn about subscription allocations' thread-safety.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>subscription</code> must be a valid subscription, as returned by <a class="el" href="rmw_8h.html#a3a864d424c6aa5fc57b1ca3dbe19a697" title="Create a subscription and return a handle to that subscription.">rmw_create_subscription()</a>. </dd>
<dd>
Given <code>ros_message</code> must be a valid message, whose type matches the message type support registered with the <code>subscription</code> on creation. </dd>
<dd>
If not NULL, given <code>allocation</code> must be a valid subscription allocation initialized with rmw_subscription_allocation_init() with a message type support that matches the one registered with the <code>subscription</code> on creation. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Given <code>ros_message</code> will remain a valid message, and <code>message_info</code>, valid message metadata. Both will be left unchanged if this function fails early due to a logical error, such as an invalid argument, or in an unknown yet valid state if it fails due to a runtime error. Both will also be left unchanged if this function succeeds but <code>taken</code> is false.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>Subscription to take ROS message from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ros_message</td><td>Type erased ROS message to write to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taken</td><td>Boolean flag indicating if a ROS message was taken or not. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message_info</td><td>Taken ROS message metadata. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Pre-allocated memory to be used. May be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation fails, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>subscription</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>ros_message</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>taken</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>message_info</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>subscription</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="aec493534247a1c57a1a0579b0f4120ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec493534247a1c57a1a0579b0f4120ef">&#9670;&nbsp;</a></span>rmw_take_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_take_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="message__sequence_8h.html#a3be13b9e5823fd79af65b8b88703e3d8">rmw_message_sequence_t</a> *&#160;</td>
          <td class="paramname"><em>message_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="message__sequence_8h.html#ab92d652720f24191259da0237ff9639e">rmw_message_info_sequence_t</a> *&#160;</td>
          <td class="paramname"><em>message_info_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>taken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a74a8ca7ddfdd8734690fe56d8afe9fd2">rmw_subscription_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take multiple incoming ROS messages with their metadata. </p>
<p>Take a sequence of consecutive ROS messages already received by the given subscription, removing them from internal queues. While <code>count</code> ROS messages may be requested, fewer messages may have been received by the subscription. This function will only take what has been already received, and it will succeed even if fewer (or zero) messages were received. In this case, only currently available messages will be returned. The <code>taken</code> output variable indicates the number of ROS messages actually taken.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Once taken, ROS messages in the sequence cannot be taken again. Callers do not have to deal with duplicates.</dd></dl>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check implementation documentation.</em></p>
<dl class="section user"><dt>Runtime behavior</dt><dd>To take a sequence of ROS messages is a synchronous operation. It is also non-blocking, to the extent it will not wait for new ROS messages to arrive, but it is not guaranteed to be lock-free. Generally speaking, implementations may synchronize access to internal resources using locks but are not allowed to wait for events with no guaranteed time bound (barring the effects of starvation due to OS scheduling).</dd></dl>
<dl class="section user"><dt>Memory allocation</dt><dd>It is implementation defined whether memory will be allocated on take or not. For instance, implementations that deserialize ROS messages received over the wire may need to perform additional memory allocations when dealing with unbounded (dynamically-sized) fields. A subscription allocation, if provided, may or may not be used. Check the implementation documentation to learn about memory allocation guarantees when taking ROS messages with and without subscription allocations.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Subscriptions are thread-safe objects, and so are all operations on them except for finalization. Therefore, it is safe to take from the same subscription concurrently. Moreover, the sequence of ROS messages taken is guaranteed to be consecutive and to preserve the order in the subscription queues, despite any concurrent takes. However, when taking a sequence of ROS messages with metadata:<ul>
<li>Access to the given ROS message sequence is not synchronized. It is not safe to read or write <code>message_sequence</code> while <a class="el" href="rmw_8h.html#aec493534247a1c57a1a0579b0f4120ef" title="Take multiple incoming ROS messages with their metadata.">rmw_take_sequence()</a> uses it.</li>
<li>Access to the given ROS message metadata sequence is not synchronized. It is not safe to read or write <code>message_info_sequence</code> while <a class="el" href="rmw_8h.html#aec493534247a1c57a1a0579b0f4120ef" title="Take multiple incoming ROS messages with their metadata.">rmw_take_sequence()</a> uses it.</li>
<li>Access to given primitive data-type arguments is not synchronized. It is not safe to read or write <code>taken</code> while <a class="el" href="rmw_8h.html#aec493534247a1c57a1a0579b0f4120ef" title="Take multiple incoming ROS messages with their metadata.">rmw_take_sequence()</a> uses it.</li>
<li>Access to the given subscription allocation is not synchronized, unless specifically stated otherwise by the implementation. Thus, it is generally not safe to read or write <code>allocation</code> while <a class="el" href="rmw_8h.html#aec493534247a1c57a1a0579b0f4120ef" title="Take multiple incoming ROS messages with their metadata.">rmw_take_sequence()</a> uses it. Check the implementation documentation to learn about subscription allocations' thread-safety.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>subscription</code> must be a valid subscription, as returned by <a class="el" href="rmw_8h.html#a3a864d424c6aa5fc57b1ca3dbe19a697" title="Create a subscription and return a handle to that subscription.">rmw_create_subscription()</a>. </dd>
<dd>
Given <code>message_sequence</code> must be a valid message sequence, initialized by <a class="el" href="message__sequence_8h.html#a80d62c5d17da678e60768f84d88ef0fa" title="Initialize an rmw_message_sequence_t object.">rmw_message_sequence_init()</a> and populated with ROS messages whose type matches the message type support registered with the <code>subscription</code> on creation. </dd>
<dd>
Given <code>message_info_sequence</code> must be a valid message metadata sequence, initialized by <a class="el" href="message__sequence_8h.html#a478d42fcbeb15524e9b56fec712fbfc4" title="Initialize an rmw_message_info_sequence_t object.">rmw_message_info_sequence_init()</a>. </dd>
<dd>
If not NULL, given <code>allocation</code> must be a valid subscription allocation initialized with rmw_subscription_allocation_init() with a message type support that matches the one registered with <code>subscription</code> on creation. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Given <code>message_sequence</code> will remain a valid message sequence, and <code>message_info_sequence</code>, a valid message metadata sequence. Both will be left unchanged if this function fails early due to a logical error, such as an invalid argument, or in an unknown yet valid state if it fails due to a runtime error. Both will also be left unchanged if this function succeeds but <code>taken</code> is zero.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>Subscription to take ROS message from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of messages to attempt to take. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message_sequence</td><td>Sequence of type erase ROS messages to write to. Message sequence capacity has to be enough to hold all requested messages i.e. capacity has to be equal or greater than <code>count</code>. It does not have to match that of <code>message_info_sequence</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message_info_sequence</td><td>Sequence of additional message metadata. Message info sequence capacity has to be enough to hold all requested messages metadata i.e. capacity has to be equal or greater than <code>count</code>. It does not have to match that of <code>message_sequence</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taken</td><td>Number of messages actually taken from subscription. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Pre-allocated memory to use. May be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation fails, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>subscription</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>message_sequence</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>message_info_sequence</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>taken</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>count</code> is 0, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>message_sequence</code> capacity is less than <code>count</code>, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>message_info_sequence</code> capacity is less than <code>count</code>, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>subscription</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a8ef04c20dab1bc6cdb27343046ccab28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef04c20dab1bc6cdb27343046ccab28">&#9670;&nbsp;</a></span>rmw_take_serialized_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_take_serialized_message </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *&#160;</td>
          <td class="paramname"><em>serialized_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>taken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a74a8ca7ddfdd8734690fe56d8afe9fd2">rmw_subscription_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take an incoming ROS message as a byte stream. </p>
<p>Take a ROS message already received by the given subscription, removing it from internal queues. This function will succeed even if no ROS message was received, but <code>taken</code> will be false. Unlike <a class="el" href="rmw_8h.html#af9bf29af7069593e2f8dfa2296710080" title="Take an incoming ROS message.">rmw_take()</a>, the ROS message is taken in its serialized form, as a byte stream. If needed, this byte stream can then be deserialized into a ROS message with <a class="el" href="rmw_8h.html#a9dee9c2eed962055a68febe9622f807c" title="Deserialize a ROS message.">rmw_deserialize()</a>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The same ROS message, serialized or not, cannot be taken twice. Callers do not have to deal with duplicates.</dd></dl>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check implementation documentation.</em></p>
<dl class="section user"><dt>Runtime behavior</dt><dd>To take a ROS message a byte stream is a synchronous operation. It is also non-blocking, to the extent it will not wait for new ROS messages to arrive, but it is not guaranteed to be lock-free. Generally speaking, implementations may synchronize access to internal resources using locks but are not allowed to wait for events with no guaranteed time bound (barring the effects of starvation due to OS scheduling).</dd></dl>
<dl class="section user"><dt>Memory allocation</dt><dd>It is implementation defined whether memory will be allocated on take or not. For instance, implementations may have to perform additional memory allocations when dealing with ROS messages that contain unbounded (dynamically-sized) fields i.e. these implementations may have to resize the given byte stream. A subscription allocation, if provided, may or may not be used. Check the implementation documentation to learn about memory allocation guarantees when taking serialized ROS messages with and without subscription allocations. </dd></dl>
<dl class="section user"><dt></dt><dd>For ROS messages that only contain bounded (fixed-size) fields, callers can query their size using <a class="el" href="rmw_8h.html#a0c172e30e87562f7f7ad25bae8b0ec8b" title="Compute the size of a serialized message.">rmw_get_serialized_message_size()</a> and resize <code>serialized_message</code> using <a class="el" href="serialized__message_8h.html#ad76aba01a068773f6be5706d2e2b2750" title="Resize the internal buffer of the serialized message.">rmw_serialized_message_resize()</a> accordingly to prevent byte stream resizing on take. Nonetheless, byte stream resizing is not guaranteed to be the sole memory operation.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Subscriptions are thread-safe objects, and so are all operations on them except for finalization. Therefore, it is safe to take from the same subscription concurrently. However, when taking serialized ROS messages:<ul>
<li>Access to the given byte stream for serialized ROS messages is not synchronized. It is not safe to read or write <code>serialized_message</code> while <a class="el" href="rmw_8h.html#a8ef04c20dab1bc6cdb27343046ccab28" title="Take an incoming ROS message as a byte stream.">rmw_take_serialized_message()</a> uses it.</li>
<li>Access to given primitive data-type arguments is not synchronized. It is not safe to read or write <code>taken</code> while <a class="el" href="rmw_8h.html#a8ef04c20dab1bc6cdb27343046ccab28" title="Take an incoming ROS message as a byte stream.">rmw_take_serialized_message()</a> uses it.</li>
<li>Access to the given subscription allocation is not synchronized, unless specifically stated otherwise by the implementation. Thus, it is generally not safe to read or write <code>allocation</code> while <a class="el" href="rmw_8h.html#a8ef04c20dab1bc6cdb27343046ccab28" title="Take an incoming ROS message as a byte stream.">rmw_take_serialized_message()</a> uses it. Check the implementation documentation to learn about subscription allocations' thread-safety.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>subscription</code> must be a valid subscription, as returned by <a class="el" href="rmw_8h.html#a3a864d424c6aa5fc57b1ca3dbe19a697" title="Create a subscription and return a handle to that subscription.">rmw_create_subscription()</a>. </dd>
<dd>
Given <code>serialized_message</code> must be a valid serialized message, initialized by <a class="el" href="serialized__message_8h.html#afeb4d43a474541ae2ec82f797dc99573" title="Initialize a serialized message, zero initializing its contents.">rmw_serialized_message_init()</a>. </dd>
<dd>
If not NULL, given <code>allocation</code> must be a valid subscription allocation initialized with rmw_subscription_allocation_init() with a message type support that matches the one registered with <code>subscription</code> on creation. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Given <code>serialized_message</code> will remain a valid serialized message. It will be left unchanged if this function fails early due to a logical error, such as an invalid argument, or in an unknown yet valid state if it fails due to a runtime error. It will also be left unchanged if this function succeeds but <code>taken</code> is false.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>Subscription to take ROS message from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">serialized_message</td><td>Byte stream to write to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taken</td><td>Boolean flag indicating if a ROS message was taken or not. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Pre-allocated memory to use. May be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation fails, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>subscription</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>serialized_message</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>taken</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>subscription</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a16a8f380a5f4a5b37a48396a74a3238c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a8f380a5f4a5b37a48396a74a3238c">&#9670;&nbsp;</a></span>rmw_take_serialized_message_with_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_take_serialized_message_with_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *&#160;</td>
          <td class="paramname"><em>serialized_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>taken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#abc926cd584b2ce189a89ae20aaab817b">rmw_message_info_t</a> *&#160;</td>
          <td class="paramname"><em>message_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a74a8ca7ddfdd8734690fe56d8afe9fd2">rmw_subscription_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take an incoming ROS message as a byte stream with its metadata. </p>
<p>Same as <a class="el" href="rmw_8h.html#a8ef04c20dab1bc6cdb27343046ccab28" title="Take an incoming ROS message as a byte stream.">rmw_take_serialized_message()</a>, except it also takes ROS message metadata.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check implementation documentation.</em></p>
<dl class="section user"><dt>Runtime behavior</dt><dd>To take a ROS message a byte stream with its metadata is a synchronous operation. It is also non-blocking, to the extent it will not wait for new ROS messages to arrive, but it is not guaranteed to be lock-free. Generally speaking, implementations may synchronize access to internal resources using locks but are not allowed to wait for events with no guaranteed time bound (barring the effects of starvation due to OS scheduling).</dd></dl>
<dl class="section user"><dt>Memory allocation</dt><dd>It is implementation defined whether memory will be allocated on take or not. For instance, implementations may have to perform additional memory allocations when dealing with ROS messages that contain unbounded (dynamically-sized) fields i.e. these implementations may have to resize the given byte stream. A subscription allocation, if provided, may or may not be used. Check the implementation documentation to learn about memory allocation guarantees when taking serialized ROS messages with and without subscription allocations. </dd></dl>
<dl class="section user"><dt></dt><dd>For ROS messages that only contain bounded (fixed-size) fields, callers can query their size using <a class="el" href="rmw_8h.html#a0c172e30e87562f7f7ad25bae8b0ec8b" title="Compute the size of a serialized message.">rmw_get_serialized_message_size()</a> and resize <code>serialized_message</code> using <a class="el" href="serialized__message_8h.html#ad76aba01a068773f6be5706d2e2b2750" title="Resize the internal buffer of the serialized message.">rmw_serialized_message_resize()</a> accordingly to prevent byte stream resizing on take. Nonetheless, byte stream resizing is not guaranteed to be the sole memory operation.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Subscriptions are thread-safe objects, and so are all operations on them except for finalization. Therefore, it is safe to take from the same subscription concurrently. However, when taking serialized ROS messages with metadata:<ul>
<li>Access to the given byte stream for serialized ROS messages is not synchronized. It is not safe to read or write <code>serialized_message</code> while <a class="el" href="rmw_8h.html#a16a8f380a5f4a5b37a48396a74a3238c" title="Take an incoming ROS message as a byte stream with its metadata.">rmw_take_serialized_message_with_info()</a> uses it.</li>
<li>Access to the given ROS message metadata is not synchronized. It is not safe to read or write <code>message_info</code> while <a class="el" href="rmw_8h.html#a16a8f380a5f4a5b37a48396a74a3238c" title="Take an incoming ROS message as a byte stream with its metadata.">rmw_take_serialized_message_with_info()</a> uses it.</li>
<li>Access to given primitive data-type arguments is not synchronized. It is not safe to read or write <code>taken</code> while <a class="el" href="rmw_8h.html#a16a8f380a5f4a5b37a48396a74a3238c" title="Take an incoming ROS message as a byte stream with its metadata.">rmw_take_serialized_message_with_info()</a> uses it.</li>
<li>Access to the given subscription allocation is not synchronized, unless specifically stated otherwise by the implementation. Thus, it is generally not safe to read or write <code>allocation</code> while <a class="el" href="rmw_8h.html#a16a8f380a5f4a5b37a48396a74a3238c" title="Take an incoming ROS message as a byte stream with its metadata.">rmw_take_serialized_message_with_info()</a> uses it. Check the implementation documentation to learn about subscription allocations' thread-safety.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>serialized_message</code> must be a valid serialized message, initialized by <a class="el" href="serialized__message_8h.html#afeb4d43a474541ae2ec82f797dc99573" title="Initialize a serialized message, zero initializing its contents.">rmw_serialized_message_init()</a>. </dd>
<dd>
If not NULL, given <code>allocation</code> must be a valid subscription allocation initialized with rmw_subscription_allocation_init() with a message type support that matches the one registered with <code>subscription</code> on creation. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Given <code>serialized_message</code> will remain a valid serialized message, and <code>message_info</code>, valid message metadata. Both will be left unchanged if this function fails early due to a logical error, such as an invalid argument, or in an unknown yet valid state if it fails due to a runtime error. It will also be left unchanged if this function succeeds but <code>taken</code> is false.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>Subscription to take ROS message from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">serialized_message</td><td>Byte stream to write to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taken</td><td>Boolean flag indicating if a ROS message was taken or not. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message_info</td><td>Taken ROS message metadata. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Pre-allocated memory to use. May be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation fails, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>subscription</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>serialized_message</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>taken</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>message_info</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>subscription</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a95da7643ef0f44a457361151bf6cbc3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95da7643ef0f44a457361151bf6cbc3c">&#9670;&nbsp;</a></span>rmw_take_loaned_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_take_loaned_message </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>loaned_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>taken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a74a8ca7ddfdd8734690fe56d8afe9fd2">rmw_subscription_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take an incoming ROS message, loaned by the middleware. </p>
<p>Take a ROS message already received by the given subscription, removing it from internal queues. This function will succeed even if no ROS message was received, but <code>taken</code> will be false. The loaned ROS message is owned by the middleware, which will keep it alive (i.e. in valid memory space) until the caller returns it using <a class="el" href="rmw_8h.html#ae1c931744261eaa9d362e145193cf7d8" title="Return a loaned ROS message previously taken from a subscription.">rmw_return_loaned_message_from_subscription()</a>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The same ROS message, loaned or not, cannot be taken twice. Callers do not have to deal with duplicates.</dd></dl>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check implementation documentation.</em></p>
<dl class="section user"><dt>Runtime behavior</dt><dd>To take a loaned ROS message is a synchronous operation. It is also non-blocking, to the extent it will not wait for new ROS messages to arrive nor for internal memory loaning pools, if any, to be replenished, but it is not guaranteed to be lock-free. Generally speaking, implementations may synchronize access to internal resources using locks but are not allowed to wait for events with no guaranteed time bound (barring the effects of starvation due to OS scheduling).</dd></dl>
<dl class="section user"><dt>Memory allocation</dt><dd>It is implementation defined whether memory will be allocated on take or not. For instance, implementations that deserialize ROS messages received over the wire may need to perform additional memory allocations when dealing with unbounded (dynamically-sized) fields. A subscription allocation, if provided, may or may not be used. Check the implementation documentation to learn about memory allocation guarantees when taking loaned ROS messages with and without subscription allocations.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Subscriptions are thread-safe objects, and so are all operations on them except for finalization. Therefore, it is safe to take from the same subscription concurrently. However, when taking loaned ROS messages:<ul>
<li>Access to given primitive data-type arguments is not synchronized. It is not safe to read or write <code>taken</code> nor <code>loaned_message</code> while <a class="el" href="rmw_8h.html#a95da7643ef0f44a457361151bf6cbc3c" title="Take an incoming ROS message, loaned by the middleware.">rmw_take_loaned_message()</a> uses them.</li>
<li>Access to the given subscription allocation is not synchronized, unless specifically stated otherwise by the implementation. Thus, it is generally not safe to read or write <code>allocation</code> while <a class="el" href="rmw_8h.html#a95da7643ef0f44a457361151bf6cbc3c" title="Take an incoming ROS message, loaned by the middleware.">rmw_take_loaned_message()</a> uses it. Check the implementation documentation to learn about subscription allocations' thread-safety.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>subscription</code> must be a valid subscription, as returned by <a class="el" href="rmw_8h.html#a3a864d424c6aa5fc57b1ca3dbe19a697" title="Create a subscription and return a handle to that subscription.">rmw_create_subscription()</a>. </dd>
<dd>
If not NULL, given <code>allocation</code> must be a valid subscription allocation initialized with rmw_subscription_allocation_init() with a message type support that matches the one registered with <code>subscription</code> on creation. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Given <code>loaned_message</code> will remain unchanged, or point to a valid message if this function was successful and <code>taken</code> is true.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>Subscription to take ROS message from. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">loaned_message</td><td>Pointer to type erased ROS message taken and loaned by the middleware. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taken</td><td>Boolean flag indicating if a ROS message was taken or not. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Pre-allocated memory to use. May be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation fails, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>subscription</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>loaned_message</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>*loaned_message</code> is not NULL (to prevent leaks), or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>taken</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>subscription</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if the implementation does not support loaned ROS messages, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a163d11727369827302b7f021cea837d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163d11727369827302b7f021cea837d4">&#9670;&nbsp;</a></span>rmw_take_loaned_message_with_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_take_loaned_message_with_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>loaned_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>taken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#abc926cd584b2ce189a89ae20aaab817b">rmw_message_info_t</a> *&#160;</td>
          <td class="paramname"><em>message_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a74a8ca7ddfdd8734690fe56d8afe9fd2">rmw_subscription_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a loaned message and with its additional message information. </p>
<p>Same as <a class="el" href="rmw_8h.html#a95da7643ef0f44a457361151bf6cbc3c" title="Take an incoming ROS message, loaned by the middleware.">rmw_take_loaned_message()</a>, except it also takes ROS message metadata.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check implementation documentation.</em></p>
<dl class="section user"><dt>Runtime behavior</dt><dd>To take a loaned ROS message with its metadata is a synchronous operation. It is also non-blocking, to the extent it will not wait for new ROS messages to arrive nor for internal memory loaning pools, if any, to be replenished, but it is not guaranteed to be lock-free. Generally speaking, implementations may synchronize access to internal resources using locks but are not allowed to wait for events with no guaranteed time bound (barring the effects of starvation due to OS scheduling).</dd></dl>
<dl class="section user"><dt>Memory allocation</dt><dd>It is implementation defined whether memory will be allocated on take or not. For instance, implementations that deserialize ROS messages received over the wire may need to perform additional memory allocations when dealing with unbounded (dynamically-sized) fields. A subscription allocation, if provided, may or may not be used. Check the implementation documentation to learn about memory allocation guarantees when taking loaned ROS messages with and without subscription allocations.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Subscriptions are thread-safe objects, and so are all operations on them except for finalization. Therefore, it is safe to take from the same subscription concurrently. However, when taking loaned ROS messages with metadata:<ul>
<li>Access to given primitive data-type arguments is not synchronized. It is not safe to read or write <code>taken</code> nor <code>loaned_message</code> while <a class="el" href="rmw_8h.html#a163d11727369827302b7f021cea837d4" title="Take a loaned message and with its additional message information.">rmw_take_loaned_message_with_info()</a> uses them.</li>
<li>Access to the given ROS message metadata is not synchronized. It is not safe to read or write <code>message_info</code> while <a class="el" href="rmw_8h.html#a163d11727369827302b7f021cea837d4" title="Take a loaned message and with its additional message information.">rmw_take_loaned_message_with_info()</a> uses it.</li>
<li>Access to the given subscription allocation is not synchronized, unless specifically stated otherwise by the implementation. Thus, it is generally not safe to read or write <code>allocation</code> while <a class="el" href="rmw_8h.html#a163d11727369827302b7f021cea837d4" title="Take a loaned message and with its additional message information.">rmw_take_loaned_message_with_info()</a> uses it. Check the implementation documentation to learn about subscription allocations' thread-safety.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>subscription</code> must be a valid subscription, as returned by <a class="el" href="rmw_8h.html#a3a864d424c6aa5fc57b1ca3dbe19a697" title="Create a subscription and return a handle to that subscription.">rmw_create_subscription()</a>. </dd>
<dd>
If not NULL, given <code>allocation</code> must be a valid subscription allocation initialized with rmw_subscription_allocation_init() with a message type support that matches the one registered with <code>subscription</code> on creation. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Given <code>loaned_message</code> will remain unchanged, or point to a valid message if this function was successful and <code>taken</code> is true. </dd>
<dd>
Given <code>message_info</code> will remain valid message metadata. It will be left unchanged if this function fails early due to a logical error, such as an invalid argument, or in an unknown yet valid state if it fails due to a runtime error. It will also be left unchanged if this function succeeds but <code>taken</code> is false.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>Subscription to take ROS message from. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">loaned_message</td><td>Pointer to type erased ROS message taken and loaned by the middleware. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taken</td><td>Boolean flag indicating if a ROS message was taken or not. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message_info</td><td>Taken ROS message metadata. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Pre-allocated memory to use. May be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation fails, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>subscription</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>loaned_message</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>*loaned_message</code> is not NULL to prevent leaks, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>taken</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>message_info</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>subscription</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if the implementation does not support loaned ROS messages, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="ae1c931744261eaa9d362e145193cf7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c931744261eaa9d362e145193cf7d8">&#9670;&nbsp;</a></span>rmw_return_loaned_message_from_subscription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_return_loaned_message_from_subscription </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>loaned_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a loaned ROS message previously taken from a subscription. </p>
<p>Tells the middleware that previously loaned ROS message is no longer needed by the caller. If this function fails early due to a logical error, such as an invalid argument, the loaned ROS message will be left unchanged. Otherwise, ownership of the ROS message will be given back to the middleware. It is up to the middleware what will be made of the returned ROS message. It is undefined behavior to use a loaned ROS message after returning it.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check implementation documentation.</em></p>
<dl class="section user"><dt>Runtime behavior</dt><dd>To return a loaned ROS message is a synchronous operation. It is also non-blocking, but it is not guaranteed to be lock-free. Generally speaking, implementations may synchronize access to internal resources using locks but are not allowed to wait for events with no guaranteed time bound (barring the effects of starvation due to OS scheduling).</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Subscriptions are thread-safe objects, and so are all operations on them except for finalization. Therefore, it is safe to return loaned ROS messages to the same subscription concurrently. However, since ownership of the loaned ROS message is given back to middleware and this transfer is not synchronized, it is not safe to return the same loaned ROS message concurrently.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>subscription</code> must be a valid subscription, as returned by <a class="el" href="rmw_8h.html#a3a864d424c6aa5fc57b1ca3dbe19a697" title="Create a subscription and return a handle to that subscription.">rmw_create_subscription()</a>. </dd>
<dd>
Given <code>loaned_message</code> must be a loaned ROS message, previously taken from <code>subscription</code> using <a class="el" href="rmw_8h.html#a95da7643ef0f44a457361151bf6cbc3c" title="Take an incoming ROS message, loaned by the middleware.">rmw_take_loaned_message()</a> or <a class="el" href="rmw_8h.html#a163d11727369827302b7f021cea837d4" title="Take a loaned message and with its additional message information.">rmw_take_loaned_message_with_info()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>Subscription the ROS message was taken and loaned from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">loaned_message</td><td>Loaned type erased ROS message to be returned to the middleware. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>subscription</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>loaned_message</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>subscription</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if the implementation does not support loaned ROS messages, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a208bb1dd4d3c77cceee53ceba7abb8ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208bb1dd4d3c77cceee53ceba7abb8ac">&#9670;&nbsp;</a></span>rmw_create_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#afc04b99b504df3d1dfc167c4a46214a2">rmw_client_t</a>* rmw_create_client </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_service_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>service_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a6f1f6c7a61a3d276ea2758ce2d5ac9c5">rmw_qos_profile_t</a> *&#160;</td>
          <td class="paramname"><em>qos_policies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a service client that can send requests to and receive replies from a service server. </p>
<p>This function can fail, and therefore return <code>NULL</code>, if:</p><ul>
<li><code>node</code> is <code>NULL</code>, or</li>
<li><code>node</code> does not belong to this implementation i.e. it does not have a matching implementation identifier, or</li>
<li><code>type_support</code> is <code>NULL</code>, or</li>
<li><code>service_name</code> is <code>NULL</code>, or</li>
<li><code>service_name</code> is an empty string, or</li>
<li>(if ROS namespace conventions apply) <code>service_name</code> is invalid by <a class="el" href="validate__full__topic__name_8h.html#a5bf7cd29da7f1c6c28bff9e24fa8328d" title="Determine if a given fully qualified topic name is valid.">rmw_validate_full_topic_name()</a> definition, or</li>
<li><code>qos_profile</code> is <code>NULL</code>, or</li>
<li><code>qos_profile</code> has invalid or unknown policies, or</li>
<li>memory allocation fails during service client creation, or</li>
<li>an unspecified error occurs.</li>
</ul>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>node</code> must be a valid node, as returned by <a class="el" href="rmw_8h.html#aeb06f551db3cbcd6298ed8f20e3ed8d2" title="Create a node and return a handle to that node.">rmw_create_node()</a>. </dd>
<dd>
Given <code>type_support</code> must be a valid <code>rosidl</code> service type support, as returned by ROSIDL_GET_SRV_TYPE_SUPPORT().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Node with which to register this service client. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_support</td><td>Type support of the service to be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">service_name</td><td>Name of the service to be used, often a fully qualified service name unless <code>qos_profile</code> is configured to avoid ROS namespace conventions i.e. to create a native service client. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qos_policies</td><td>QoS policies for this service client's connections. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rmw service client handle, or <code>NULL</code> if there was an error. </dd></dl>

</div>
</div>
<a id="a3da675215fe98e4bcb8cf202c3503c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3da675215fe98e4bcb8cf202c3503c5e">&#9670;&nbsp;</a></span>rmw_destroy_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_destroy_client </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#afc04b99b504df3d1dfc167c4a46214a2">rmw_client_t</a> *&#160;</td>
          <td class="paramname"><em>client</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy and unregister a service client from its node. </p>
<p>This function will reclaim all associated resources, including the service client itself. Use of a destroyed service client is undefined behavior. This function will return early if a logical error, such as <code>RMW_RET_INVALID_ARGUMENT</code> or <code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code>, ensues, leaving the given service client unchanged. Otherwise, it will proceed despite errors.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>node</code> must be the one the service client was registered with. </dd>
<dd>
Given <code>client</code> must be a valid service client, as returned by <a class="el" href="rmw_8h.html#a5ea67119f9c74f8804e80c887488bd1e" title="Create a service server that can receive requests from and send replies to a service client.">rmw_create_service()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Node with which the given service client is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">client</td><td>Service client to be destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>node</code> is <code>NULL</code>, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>client</code> is <code>NULL</code>, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>node</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>client</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a9abc3e631cd2529f168d04be97f1db29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abc3e631cd2529f168d04be97f1db29">&#9670;&nbsp;</a></span>rmw_send_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_send_request </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#afc04b99b504df3d1dfc167c4a46214a2">rmw_client_t</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ros_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>sequence_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a ROS service request. </p>
<p>Send a ROS service request to one or more service servers, with matching QoS policies, using the given client.</p>
<dl class="section note"><dt>Note</dt><dd>It is implementation defined how many service servers may get, and potentially react to, the same request, considering there may be more than one server for the same service in the ROS graph.</dd></dl>
<p>On success, this function will return a sequence number. It is up to callers to save the returned sequence number to pair the ROS service request just sent with future ROS service responses (taken using <a class="el" href="rmw_8h.html#a31be4bb944b42b553a700a762d789dee" title="Take an incoming ROS service response.">rmw_take_response()</a>).</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check implementation documentation.</em></p>
<dl class="section user"><dt>Runtime behavior</dt><dd>It is implementation defined whether sending a ROS service request is a synchronous or asynchronous, and blocking or non-blocking, operation. However, asynchronous implementations are not allowed to access the given ROS service request after this function returns. Check the implementation documentation to learn about request behavior.</dd></dl>
<dl class="section user"><dt>Memory allocation</dt><dd>It is implementation defined whether memory will be allocated on send or not. For instance, implementations that serialize ROS service requests may need to perform additional memory allocations when dealing with unbounded (dynamically-sized) fields.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Service clients are thread-safe objects, and so are all operations on them except for finalization. Therefore, it is safe to send requests using the same service client concurrently. However:<ul>
<li>Access to the given ROS service request is read-only but it is not synchronized. Concurrent <code>ros_request</code> reads are safe, but concurrent reads and writes are not.</li>
<li>Access to given primitive data-type arguments is not synchronized. It is not safe to read or write <code>sequence_id</code> while <a class="el" href="rmw_8h.html#a9abc3e631cd2529f168d04be97f1db29" title="Send a ROS service request.">rmw_send_request()</a> uses it.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>client</code> must be a valid client, as returned by <a class="el" href="rmw_8h.html#a208bb1dd4d3c77cceee53ceba7abb8ac" title="Create a service client that can send requests to and receive replies from a service server.">rmw_create_client()</a>. </dd>
<dd>
Given <code>ros_request</code> must be a valid service request, whose type matches the service type support registered with the <code>client</code> on creation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">client</td><td>Service client to send a request with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ros_request</td><td>ROS service request to be sent. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sequence_id</td><td>Sequence number for the <code>ros_request</code> just sent i.e. a unique identification number for it, populated on success. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation fails, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>client</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>ros_request</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>sequence_id</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>client</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a31be4bb944b42b553a700a762d789dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31be4bb944b42b553a700a762d789dee">&#9670;&nbsp;</a></span>rmw_take_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_take_response </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#afc04b99b504df3d1dfc167c4a46214a2">rmw_client_t</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a8ba466b6297af05b5e02bb764e59d81a">rmw_service_info_t</a> *&#160;</td>
          <td class="paramname"><em>request_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ros_response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>taken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take an incoming ROS service response. </p>
<p>Take a ROS service response already received by the given service server, removing it from internal queues. The response header (i.e. its metadata), containing at least the writer guid and sequence number, is also retrieved. Both writer guid and sequence number allow callers to pair, potentially for each remote service server, a ROS service response with its corresponding ROS service request, previously sent using <a class="el" href="rmw_8h.html#a9abc3e631cd2529f168d04be97f1db29" title="Send a ROS service request.">rmw_send_request()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>It is implementation defined how many responses a given request may get, considering there may be more than one server for the same service in the ROS graph.</dd></dl>
<p>This function will succeed even if no ROS service request was received, but <code>taken</code> will be false.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The same ROS service response cannot be taken twice. Callers do not have to deal with duplicates.</dd></dl>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check implementation documentation.</em></p>
<dl class="section user"><dt>Runtime behavior</dt><dd>Taking a ROS service response is a synchronous operation. It is also non-blocking, to the extent it will not wait for new ROS service responses to arrive, but it is not guaranteed to be lock-free. Generally speaking, implementations may synchronize access to internal resources using locks but are not allowed to wait for events with no guaranteed time bound (barring the effects of starvation due to OS scheduling).</dd></dl>
<dl class="section user"><dt>Memory allocation</dt><dd>It is implementation defined whether memory will be allocated on take or not. For instance, implementations that deserialize ROS service responses received over the wire may need to perform additional memory allocations when dealing with unbounded (dynamically-sized) fields.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Service clients are thread-safe objects, and so are all operations on them except for finalization. Therefore, it is safe to take responses from the same service client concurrently. However:<ul>
<li>Access to the given ROS service response is not synchronized. It is not safe to read or write <code>ros_response</code> while <a class="el" href="rmw_8h.html#af5fdf79993ad434417b5edabe2023813" title="Take an incoming ROS service request.">rmw_take_request()</a> uses it.</li>
<li>Access to the given ROS service response header is not synchronized. It is not safe to read or write <code>response_header</code> while <a class="el" href="rmw_8h.html#a31be4bb944b42b553a700a762d789dee" title="Take an incoming ROS service response.">rmw_take_response()</a> uses it.</li>
<li>Access to given primitive data-type arguments is not synchronized. It is not safe to read or write <code>taken</code> while <a class="el" href="rmw_8h.html#a31be4bb944b42b553a700a762d789dee" title="Take an incoming ROS service response.">rmw_take_response()</a> uses it.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>client</code> must be a valid client, as returned by <a class="el" href="rmw_8h.html#a208bb1dd4d3c77cceee53ceba7abb8ac" title="Create a service client that can send requests to and receive replies from a service server.">rmw_create_client()</a>. </dd>
<dd>
Given <code>ros_response</code> must be a valid service response, whose type matches the service type support registered with the <code>client</code> on creation. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Given <code>ros_response</code> will remain a valid service response. It will be left unchanged if this function fails early due to a logical error, such as an invalid argument, or in an unknown yet valid state if it fails due to a runtime error. It will also be left unchanged if this function succeeds but <code>taken</code> is false.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">client</td><td>Service client to take response from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">request_header</td><td>Service response header to write to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ros_response</td><td>Type erased ROS service response to write to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taken</td><td>Boolean flag indicating if a ROS service response was taken or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation fails, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>client</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>response_header</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>ros_response</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>taken</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>client</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a6177c1ef618162fc58c453b5486e882c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6177c1ef618162fc58c453b5486e882c">&#9670;&nbsp;</a></span>rmw_client_request_publisher_get_actual_qos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_client_request_publisher_get_actual_qos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#afc04b99b504df3d1dfc167c4a46214a2">rmw_client_t</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a6f1f6c7a61a3d276ea2758ce2d5ac9c5">rmw_qos_profile_t</a> *&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the actual qos settings of the client's request publisher. </p>
<p>Query the underlying middleware to determine the qos settings of the client's request publisher. The actual configuration applied when using RMW_*_SYSTEM_DEFAULT can only be resolved after the creation of the client, and it depends on the underlying rmw implementation. If the underlying setting in use can't be represented in ROS terms, it will be set to RMW_*_UNKNOWN.</p>
<dl class="section note"><dt>Note</dt><dd>The value of avoid_ros_namespace_conventions field is not resolved with this function. The rcl function <code>rcl_client_request_publisher_get_actual_qos()</code> resolves it.</dd></dl>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">client</td><td>the client object to inspect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qos</td><td>the actual qos settings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if either argument is null, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if client implementation identifier does not match, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="ad7edd7850ffb8ea6247f680664cfda84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7edd7850ffb8ea6247f680664cfda84">&#9670;&nbsp;</a></span>rmw_client_response_subscription_get_actual_qos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_client_response_subscription_get_actual_qos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#afc04b99b504df3d1dfc167c4a46214a2">rmw_client_t</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a6f1f6c7a61a3d276ea2758ce2d5ac9c5">rmw_qos_profile_t</a> *&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the actual qos settings of the client's response subscription. </p>
<p>Query the underlying middleware to determine the qos settings of the client's response subscription. The actual configuration applied when using RMW_*_SYSTEM_DEFAULT can only be resolved after the creation of the client, and it depends on the underlying rmw implementation. If the underlying setting in use can't be represented in ROS terms, it will be set to RMW_*_UNKNOWN.</p>
<dl class="section note"><dt>Note</dt><dd>The value of avoid_ros_namespace_conventions field is not resolved with this function. The rcl function <code>rcl_client_request_publisher_get_actual_qos()</code> resolves it.</dd></dl>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">client</td><td>the client object to inspect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qos</td><td>the actual qos settings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if either argument is null, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if client implementation identifier does not match, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a5ea67119f9c74f8804e80c887488bd1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea67119f9c74f8804e80c887488bd1e">&#9670;&nbsp;</a></span>rmw_create_service()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a562ff74fd2c35c006bac0f8a98dabd7e">rmw_service_t</a>* rmw_create_service </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_service_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>service_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a6f1f6c7a61a3d276ea2758ce2d5ac9c5">rmw_qos_profile_t</a> *&#160;</td>
          <td class="paramname"><em>qos_profile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a service server that can receive requests from and send replies to a service client. </p>
<p>This function can fail, and therefore return <code>NULL</code>, if:</p><ul>
<li><code>node</code> is <code>NULL</code>, or</li>
<li><code>node</code> does not belong to this implementation i.e. it does not have a matching implementation identifier, or</li>
<li><code>type_support</code> is <code>NULL</code>, or</li>
<li><code>service_name</code> is <code>NULL</code>, or</li>
<li><code>service_name</code> is an empty string, or</li>
<li>(if ROS namespace conventions apply) <code>service_name</code> is invalid by <a class="el" href="validate__full__topic__name_8h.html#a5bf7cd29da7f1c6c28bff9e24fa8328d" title="Determine if a given fully qualified topic name is valid.">rmw_validate_full_topic_name()</a> definition, or</li>
<li><code>qos_profile</code> is <code>NULL</code>, or</li>
<li><code>qos_profile</code> has invalid or unknown policies, or</li>
<li>memory allocation fails during service server creation, or</li>
<li>an unspecified error occurs</li>
</ul>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>node</code> must be a valid node, as returned by <a class="el" href="rmw_8h.html#aeb06f551db3cbcd6298ed8f20e3ed8d2" title="Create a node and return a handle to that node.">rmw_create_node()</a>. </dd>
<dd>
Given <code>type_support</code> must be a valid <code>rosidl</code> service type support, as returned by ROSIDL_GET_SRV_TYPE_SUPPORT().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Node with which to register this service server. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_support</td><td>Type support of the service to be served. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">service_name</td><td>Name of the service to be served, often a fully qualified service name unless <code>qos_profile</code> is configured to avoid ROS namespace conventions i.e. to create a native service server. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qos_profile</td><td>QoS policies for this service server's connections. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rmw service handle, or <code>NULL</code> if there was an error. </dd></dl>

</div>
</div>
<a id="a39dc6f857dfa69a69bb198dc7fa96fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39dc6f857dfa69a69bb198dc7fa96fed">&#9670;&nbsp;</a></span>rmw_destroy_service()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_destroy_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a562ff74fd2c35c006bac0f8a98dabd7e">rmw_service_t</a> *&#160;</td>
          <td class="paramname"><em>service</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy and unregister a service server from its node. </p>
<p>This function will reclaim all associated resources, including the service server itself. Use of a destroyed service server is undefined behavior. This function will return early if a logical error, such as <code>RMW_RET_INVALID_ARGUMENT</code> or <code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code>, ensues, leaving the given service server unchanged. Otherwise, it will proceed despite errors.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>node</code> must be the one the service server was registered with. </dd>
<dd>
Given <code>service</code> must be a valid service server, as returned by <a class="el" href="rmw_8h.html#a5ea67119f9c74f8804e80c887488bd1e" title="Create a service server that can receive requests from and send replies to a service client.">rmw_create_service()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Node with which the given service server is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">service</td><td>Service server to be destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>node</code> is <code>NULL</code>, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>service</code> is <code>NULL</code>, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>node</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>service</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="af5fdf79993ad434417b5edabe2023813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5fdf79993ad434417b5edabe2023813">&#9670;&nbsp;</a></span>rmw_take_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_take_request </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a562ff74fd2c35c006bac0f8a98dabd7e">rmw_service_t</a> *&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a8ba466b6297af05b5e02bb764e59d81a">rmw_service_info_t</a> *&#160;</td>
          <td class="paramname"><em>request_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ros_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>taken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take an incoming ROS service request. </p>
<p>Take a ROS service request already received by the given service server, removing it from internal queues. The request header (i.e. its metadata), containing at least the writer guid and sequence number, is also retrieved. Both writer guid and sequence number allow callers to pair, for each remote service client, a ROS service request with its corresponding ROS service response, to be later sent using <a class="el" href="rmw_8h.html#abb55ba2b2a957cefb0a77b77ddc5afda" title="Send a ROS service response.">rmw_send_response()</a>.</p>
<p>This function will succeed even if no ROS service request was received, but <code>taken</code> will be false.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The same ROS service request cannot be taken twice. Callers do not have to deal with duplicates.</dd></dl>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check implementation documentation.</em></p>
<dl class="section user"><dt>Runtime behavior</dt><dd>Taking a ROS service request is a synchronous operation. It is also non-blocking, to the extent it will not wait for new ROS service requests to arrive, but it is not guaranteed to be lock-free. Generally speaking, implementations may synchronize access to internal resources using locks but are not allowed to wait for events with no guaranteed time bound (barring the effects of starvation due to OS scheduling).</dd></dl>
<dl class="section user"><dt>Memory allocation</dt><dd>It is implementation defined whether memory will be allocated on take or not. For instance, implementations that deserialize ROS service requests received over the wire may need to perform additional memory allocations when dealing with unbounded (dynamically-sized) fields.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Service servers are thread-safe objects, and so are all operations on them except for finalization. Therefore, it is safe to take requests from the same service server concurrently. However:<ul>
<li>Access to the given ROS service request is not synchronized. It is not safe to read or write <code>ros_request</code> while <a class="el" href="rmw_8h.html#af5fdf79993ad434417b5edabe2023813" title="Take an incoming ROS service request.">rmw_take_request()</a> uses it.</li>
<li>Access to the given ROS service request header is not synchronized. It is not safe to read or write <code>request_header</code> while <a class="el" href="rmw_8h.html#af5fdf79993ad434417b5edabe2023813" title="Take an incoming ROS service request.">rmw_take_request()</a> uses it.</li>
<li>Access to given primitive data-type arguments is not synchronized. It is not safe to read or write <code>taken</code> while <a class="el" href="rmw_8h.html#af5fdf79993ad434417b5edabe2023813" title="Take an incoming ROS service request.">rmw_take_request()</a> uses it.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>service</code> must be a valid service, as returned by <a class="el" href="rmw_8h.html#a5ea67119f9c74f8804e80c887488bd1e" title="Create a service server that can receive requests from and send replies to a service client.">rmw_create_service()</a>. </dd>
<dd>
Given <code>ros_request</code> must be a valid service request, whose type matches the service type support registered with the <code>service</code> on creation. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Given <code>ros_request</code> will remain a valid service request. It will be left unchanged if this function fails early due to a logical error, such as an invalid argument, or in an unknown yet valid state if it fails due to a runtime error. It will also be left unchanged if this function succeeds but <code>taken</code> is false.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">service</td><td>Service server to take request from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">request_header</td><td>Service request header to write to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ros_request</td><td>Type erased ROS service request to write to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taken</td><td>Boolean flag indicating if a ROS service request was taken or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation fails, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>service</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>request_header</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>ros_request</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>taken</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>service</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="abb55ba2b2a957cefb0a77b77ddc5afda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb55ba2b2a957cefb0a77b77ddc5afda">&#9670;&nbsp;</a></span>rmw_send_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_send_response </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a562ff74fd2c35c006bac0f8a98dabd7e">rmw_service_t</a> *&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a06165095338e08315047c7fde7537f03">rmw_request_id_t</a> *&#160;</td>
          <td class="paramname"><em>request_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ros_response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a ROS service response. </p>
<p>Send a ROS service response to the service client, with matching QoS policies, from which the previously taken ROS service request was originally sent.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check implementation documentation.</em></p>
<dl class="section user"><dt>Runtime behavior</dt><dd>It is implementation defined whether sending a ROS service response is a synchronous or asynchronous, and blocking or non-blocking, operation. However, asynchronous implementations are not allowed to access the given ROS service request after this function returns. Check the implementation documentation to learn about request behavior.</dd></dl>
<dl class="section user"><dt>Memory allocation</dt><dd>It is implementation defined whether memory will be allocated on send or not. For instance, implementations that serialize ROS service responses may need to perform additional memory allocations when dealing with unbounded (dynamically-sized) fields.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Service servers are thread-safe objects, and so are all operations on them except for finalization. Therefore, it is safe to send responses using the same service server concurrently. However:<ul>
<li>Access to the given ROS service request header is read-only but it is not synchronized. Concurrent <code>request_header</code> reads are safe, but concurrent reads and writes are not.</li>
<li>Access to the given ROS service response is read-only but it is not synchronized. Concurrent <code>ros_request</code> reads are safe, but concurrent reads and writes are not.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>service</code> must be a valid service server, as returned by <a class="el" href="rmw_8h.html#a5ea67119f9c74f8804e80c887488bd1e" title="Create a service server that can receive requests from and send replies to a service client.">rmw_create_service()</a>. </dd>
<dd>
Given <code>request_header</code> must be the one previously taken along with the ROS service request to which we reply. </dd>
<dd>
Given <code>ros_response</code> must be a valid service response, whose type matches the service type support registered with the <code>service</code> on creation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">service</td><td>Service server to send a response with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request_header</td><td>Service response header, same as the one taken with the corresponding ROS service request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ros_response</td><td>ROS service response to be sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation fails, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>service</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>request_header</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>ros_response</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>service</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="aa3d49673ef022bafb982bcd2ee17c4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d49673ef022bafb982bcd2ee17c4bb">&#9670;&nbsp;</a></span>rmw_service_request_subscription_get_actual_qos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_service_request_subscription_get_actual_qos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a562ff74fd2c35c006bac0f8a98dabd7e">rmw_service_t</a> *&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a6f1f6c7a61a3d276ea2758ce2d5ac9c5">rmw_qos_profile_t</a> *&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the actual qos settings of the service's request subscription. </p>
<p>Query the underlying middleware to determine the qos settings of the service's request subscription. The actual configuration applied when using RMW_*_SYSTEM_DEFAULT can only be resolved after the creation of the service, and it depends on the underlying rmw implementation. If the underlying setting in use can't be represented in ROS terms, it will be set to RMW_*_UNKNOWN.</p>
<dl class="section note"><dt>Note</dt><dd>The value of avoid_ros_namespace_conventions field is not resolved with this function. The rcl function <code>rcl_service_request_subscription_get_actual_qos()</code> resolves it.</dd></dl>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">service</td><td>the service object to inspect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qos</td><td>the actual qos settings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if either argument is null, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if service implementation identifier does not match, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a923323faee41f087cd9f3ecc6ec135e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923323faee41f087cd9f3ecc6ec135e9">&#9670;&nbsp;</a></span>rmw_service_response_publisher_get_actual_qos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_service_response_publisher_get_actual_qos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a562ff74fd2c35c006bac0f8a98dabd7e">rmw_service_t</a> *&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a6f1f6c7a61a3d276ea2758ce2d5ac9c5">rmw_qos_profile_t</a> *&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the actual qos settings of the service's response publisher. </p>
<p>Query the underlying middleware to determine the qos settings of the service's response publisher. The actual configuration applied when using RMW_*_SYSTEM_DEFAULT can only be resolved after the creation of the service, and it depends on the underlying rmw implementation. If the underlying setting in use can't be represented in ROS terms, it will be set to RMW_*_UNKNOWN.</p>
<dl class="section note"><dt>Note</dt><dd>The value of avoid_ros_namespace_conventions field is not resolved with this function. The rcl function <code>rcl_service_request_subscription_get_actual_qos()</code> resolves it.</dd></dl>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">service</td><td>the service object to inspect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qos</td><td>the actual qos settings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if either argument is null, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if service implementation identifier does not match, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a6994bb0042f3a057aa2657149b9f79b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6994bb0042f3a057aa2657149b9f79b4">&#9670;&nbsp;</a></span>rmw_create_guard_condition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a81b00c2cb16d5a51f37315c9f708b491">rmw_guard_condition_t</a>* rmw_create_guard_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="init_8h.html#a60d257a0cc981fb8961bcb0d613f3f2a">rmw_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a guard condition and return a handle to that guard condition. </p>
<p>This function can fail, and therefore return <code>NULL</code>, if:</p><ul>
<li>context is <code>NULL</code></li>
<li>context is invalid</li>
<li>memory allocation fails during guard condition creation</li>
<li>an unspecified error occurs</li>
</ul>
<p>The context must be non-null and valid, i.e. it has been initialized by <code><a class="el" href="init_8h.html#af74e9a1b897e41dc8f4c94a74bb9b1a5" title="Initialize the middleware with the given options, and yielding an context.">rmw_init()</a></code> and has not been finalized by <code><a class="el" href="init_8h.html#a36ece6fcb6294f21a0b69cb091e3ee5a" title="Shutdown the middleware for a given context.">rmw_shutdown()</a></code>.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">No [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">No [1]   </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<p>This should be defined by the rmw implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>init context that this node should be associated with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rmw guard condition handle or <code>NULL</code> if there was an error </dd></dl>

</div>
</div>
<a id="acdbd5e36cc0c98e9ab4b018d3a13dfe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbd5e36cc0c98e9ab4b018d3a13dfe2">&#9670;&nbsp;</a></span>rmw_destroy_guard_condition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_destroy_guard_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a81b00c2cb16d5a51f37315c9f708b491">rmw_guard_condition_t</a> *&#160;</td>
          <td class="paramname"><em>guard_condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a given guard condition handle, reclaim the resources, and deallocate the handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">guard_condition</td><td>the guard condition handle to be destroyed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if guard_condition is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a2c06507746a703e9a053c87c4a711fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c06507746a703e9a053c87c4a711fdc">&#9670;&nbsp;</a></span>rmw_trigger_guard_condition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_trigger_guard_condition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a81b00c2cb16d5a51f37315c9f708b491">rmw_guard_condition_t</a> *&#160;</td>
          <td class="paramname"><em>guard_condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac29d471adffff01c7738ec165f571aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29d471adffff01c7738ec165f571aca">&#9670;&nbsp;</a></span>rmw_create_wait_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa2c45fd1040f6af3af5a9fbd241a5665">rmw_wait_set_t</a>* rmw_create_wait_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="init_8h.html#a60d257a0cc981fb8961bcb0d613f3f2a">rmw_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_conditions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a wait set to store conditions that the middleware can wait on. </p>
<p>This function can fail, and therefore return <code>NULL</code>, if:</p><ul>
<li>context is <code>NULL</code></li>
<li>context is zero initialized, as provided by <a class="el" href="init_8h.html#a4491dce1b786c5049bd2142fddf8a769" title="Return a zero initialized context structure.">rmw_get_zero_initialized_context()</a></li>
<li>context does not belong to this implementation i.e. does not have a matching implementation identifier</li>
<li>memory allocation fails during wait set creation</li>
<li>an unspecified error occurs</li>
</ul>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<dl class="section user"><dt>Thread-safety</dt><dd>Contexts are thread-safe objects, and so are all operations on them except for finalization. Therefore, it is safe to create multiple wait sets in the same context concurrently.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>context</code> must be a valid context, initialized by <a class="el" href="init_8h.html#af74e9a1b897e41dc8f4c94a74bb9b1a5" title="Initialize the middleware with the given options, and yielding an context.">rmw_init()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Context to associate the wait set with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_conditions</td><td>The maximum number of conditions that can be attached to, and stored by, the wait set. Can be set to zero (0) for the wait set to support an unbounded number of conditions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An rmw wait set, or <code>NULL</code> if an error occurred. </dd></dl>

</div>
</div>
<a id="a42465b1d9fddb3556a1a9f5d44d60b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42465b1d9fddb3556a1a9f5d44d60b6c">&#9670;&nbsp;</a></span>rmw_destroy_wait_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_destroy_wait_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#aa2c45fd1040f6af3af5a9fbd241a5665">rmw_wait_set_t</a> *&#160;</td>
          <td class="paramname"><em>wait_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a wait set. </p>
<p>This function will reclaim all associated resources, including the wait set. Use of a wait set after destruction is undefined behavior. This function will return early if a logical error, such as <code>RMW_RET_INVALID_ARGUMENT</code> or <code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code>, ensues, leaving the given wait set unchanged. Otherwise, it will proceed despite errors.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>wait_set</code> must be a valid wait set, as returned by <a class="el" href="rmw_8h.html#ac29d471adffff01c7738ec165f571aca" title="Create a wait set to store conditions that the middleware can wait on.">rmw_create_wait_set()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_set</td><td>Wait set to be finalized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>wait_set</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>wait_set</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a5f480dd59075e80288fb596b2951be2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f480dd59075e80288fb596b2951be2b">&#9670;&nbsp;</a></span>rmw_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a1e3560769fa878a826745ee204f75965">rmw_subscriptions_t</a> *&#160;</td>
          <td class="paramname"><em>subscriptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a6489030799d6e0b70a6ffe602dbd318b">rmw_guard_conditions_t</a> *&#160;</td>
          <td class="paramname"><em>guard_conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aacbcb015e95c5b007475b6fc2bb00445">rmw_services_t</a> *&#160;</td>
          <td class="paramname"><em>services</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a53491c1cb3622c7e6ca4a553e2c2d222">rmw_clients_t</a> *&#160;</td>
          <td class="paramname"><em>clients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a44a5648706e809f9641af439d2a0a4a6">rmw_events_t</a> *&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aa2c45fd1040f6af3af5a9fbd241a5665">rmw_wait_set_t</a> *&#160;</td>
          <td class="paramname"><em>wait_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="time_8h.html#ad4459bc766d7eeca0c324c4650128686">rmw_time_t</a> *&#160;</td>
          <td class="paramname"><em>wait_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits on sets of different entities and returns when one is ready. </p>
<p>This function adds middleware-specific conditions to the wait set and waits until one or more become ready, or until the timeout is reached.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Elapsed time should be measured using a monotonic clock, though rmw implementations could use a different one. Timeout granularity is thus bound to that of the clock used by the underlying implementation, and to the platform-specific APIs used to sleep and/or wait.</dd>
<dd>
The amount of time this function actually waits may be either above or below the specified timeout.</dd></dl>
<p>Arrays contain type-erased, middleware-specific conditions associated with waitable entities, which this function casts and adds to the wait set. <code>NULL</code> entries in arrays prior to wait are considered invalid. When the wait is over, entries in each array that correspond to conditions that were <b>not</b> triggered are set to <code>NULL</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Arrays' memory management is external to this function.</dd></dl>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<dl class="section user"><dt>Thread-safety</dt><dd>To wait is a reentrant procedure, but:<ul>
<li>It is not safe to use the same wait set to wait in two or more threads concurrently.</li>
<li>It is not safe to wait for the same entity using different wait sets in two or more threads concurrently.</li>
<li>Access to the given timeout is read-only but it is not synchronized. Concurrent <code>wait_timeout</code> reads are safe, but concurrent reads and writes are not.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>wait_set</code> must be a valid wait set, as returned by <a class="el" href="rmw_8h.html#ac29d471adffff01c7738ec165f571aca" title="Create a wait set to store conditions that the middleware can wait on.">rmw_create_wait_set()</a>. </dd>
<dd>
All given entities must be associated with nodes that, in turn, were registered with the same context the given <code>wait_set</code> was registered with on creation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">subscriptions</td><td>Array of subscriptions to wait on. Can be <code>NULL</code> if there are no subscriptions to wait on. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">guard_conditions</td><td>Array of guard conditions to wait on Can be <code>NULL</code> if there are no guard conditions to wait on. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">services</td><td>Array of services to wait on. Can be <code>NULL</code> if there are no services to wait on. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">clients</td><td>Array of clients to wait on. Can be <code>NULL</code> if there are no clients to wait on. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">events</td><td>Array of events to wait on. Can be <code>NULL</code> if there are no events to wait on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_set</td><td>Wait set to use for waiting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_timeout</td><td>If <code>NULL</code>, block indefinitely until an entity becomes ready. If zero, do not block &ndash; check only for immediately available entities. Else, this represents the maximum amount of time to wait for an entity to become ready. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_TIMEOUT</code> if wait timed out, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>wait_set</code> is <code>NULL</code>, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if an array entry is <code>NULL</code>, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>wait_set</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a64a897976680c178e0be5ef4d4a17f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a897976680c178e0be5ef4d4a17f9f">&#9670;&nbsp;</a></span>rmw_get_node_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_get_node_names </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/string__array_8h.html#a3673fe65386e017b265debee5fab5cda">rcutils_string_array_t</a> *&#160;</td>
          <td class="paramname"><em>node_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/string__array_8h.html#a3673fe65386e017b265debee5fab5cda">rcutils_string_array_t</a> *&#160;</td>
          <td class="paramname"><em>node_namespaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name and namespace of all nodes in the ROS graph. </p>
<p>This function will return an array of node names and an array of node namespaces, as discovered so far by the given node. The two arrays represent name and namespace pairs for each discovered node. Both arrays will be the same length and the same index will refer to the same node.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check the implementation documentation</em></p>
<dl class="section user"><dt>Runtime behavior</dt><dd>To query the ROS graph is a synchronous operation. It is also non-blocking, but it is not guaranteed to be lock-free. Generally speaking, implementations may synchronize access to internal resources using locks but are not allowed to wait for events with no guaranteed time bound (barring the effects of starvation due to OS scheduling).</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Nodes are thread-safe objects, and so are all operations on them except for finalization. Therefore, it is safe to query the ROS graph using the same node concurrently. However, access to string arrays is not synchronized. It is not safe to read or write <code>node_names</code> nor <code>node_namespaces</code> while <a class="el" href="rmw_8h.html#a64a897976680c178e0be5ef4d4a17f9f" title="Return the name and namespace of all nodes in the ROS graph.">rmw_get_node_names()</a> uses them.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>node</code> must be a valid node handle, as returned by <a class="el" href="rmw_8h.html#aeb06f551db3cbcd6298ed8f20e3ed8d2" title="Create a node and return a handle to that node.">rmw_create_node()</a>. </dd>
<dd>
Given <code>node_names</code> must be a valid string array, zero-initialized as returned by <a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/string__array_8h.html#af1df636b307dce593cc0103f739d138c">rcutils_get_zero_initialized_string_array()</a>. </dd>
<dd>
Given <code>node_namespaces</code> must be a valid string array, zero-initialized as returned by <a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/string__array_8h.html#af1df636b307dce593cc0103f739d138c">rcutils_get_zero_initialized_string_array()</a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Given <code>node_names</code> and <code>node_namespaces</code> will remain valid arrays. These will be left unchanged if this function fails early due to a logical error, such as an invalid argument, or in an unknown yet valid state if it fails due to a runtime error.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Node to query the ROS graph. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node_names</td><td>Array of discovered node names, populated on success. It is up to the caller to finalize this array later on, using <a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/string__array_8h.html#a14634c20c63ae8dd8ef072ce9147a91d">rcutils_string_array_fini()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node_namespaces</td><td>Array of discovered node namespaces, populated on success. It is up to the caller to finalize this array later on, using <a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/string__array_8h.html#a14634c20c63ae8dd8ef072ce9147a91d">rcutils_string_array_fini()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if the query was successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>node</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>node_names</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>node_names</code> is not a zero-initialized array, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>node_namespaces</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>node_namespaces</code> is not a zero-initialized array, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>node</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation fails, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="aa9388d5cc9d2cb460e48f4212735c935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9388d5cc9d2cb460e48f4212735c935">&#9670;&nbsp;</a></span>rmw_get_node_names_with_enclaves()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_get_node_names_with_enclaves </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/string__array_8h.html#a3673fe65386e017b265debee5fab5cda">rcutils_string_array_t</a> *&#160;</td>
          <td class="paramname"><em>node_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/string__array_8h.html#a3673fe65386e017b265debee5fab5cda">rcutils_string_array_t</a> *&#160;</td>
          <td class="paramname"><em>node_namespaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/string__array_8h.html#a3673fe65386e017b265debee5fab5cda">rcutils_string_array_t</a> *&#160;</td>
          <td class="paramname"><em>enclaves</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name, namespae, and enclave name of all nodes in the ROS graph. </p>
<p>This is similar to <a class="el" href="rmw_8h.html#a64a897976680c178e0be5ef4d4a17f9f" title="Return the name and namespace of all nodes in the ROS graph.">rmw_get_node_names()</a>, but it also provides enclave names.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check the implementation documentation</em></p>
<dl class="section user"><dt>Runtime behavior</dt><dd>To query the ROS graph is a synchronous operation. It is also non-blocking, but it is not guaranteed to be lock-free. Generally speaking, implementations may synchronize access to internal resources using locks but are not allowed to wait for events with no guaranteed time bound (barring the effects of starvation due to OS scheduling).</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Nodes are thread-safe objects, and so are all operations on them except for finalization. Therefore, it is safe to query the ROS graph using the same node concurrently. However, access to string arrays is not synchronized. It is not safe to read or write <code>node_names</code>, <code>node_namespaces</code>, nor <code>enclaves</code> while <a class="el" href="rmw_8h.html#aa9388d5cc9d2cb460e48f4212735c935" title="Return the name, namespae, and enclave name of all nodes in the ROS graph.">rmw_get_node_names_with_enclaves()</a> uses them.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>node</code> must be a valid node handle, as returned by <a class="el" href="rmw_8h.html#aeb06f551db3cbcd6298ed8f20e3ed8d2" title="Create a node and return a handle to that node.">rmw_create_node()</a>. </dd>
<dd>
Given <code>node_names</code> must be a valid string array, zero-initialized as returned by <a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/string__array_8h.html#af1df636b307dce593cc0103f739d138c">rcutils_get_zero_initialized_string_array()</a>. </dd>
<dd>
Given <code>node_namespaces</code> must be a valid string array, zero-initialized as returned by <a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/string__array_8h.html#af1df636b307dce593cc0103f739d138c">rcutils_get_zero_initialized_string_array()</a>. </dd>
<dd>
Given <code>enclaves</code> must be a zero-initialized string array, as returned by <a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/string__array_8h.html#af1df636b307dce593cc0103f739d138c">rcutils_get_zero_initialized_string_array()</a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Given <code>node_names</code>, <code>node_namespaces</code>, and <code>enclaves</code> will remain valid arrays. These will be left unchanged if this function fails early due to a logical error, such as an invalid argument, or in an unknown yet valid state if it fails due to a runtime error.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Node to query the ROS graph. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node_names</td><td>Array of discovered node names, populated on success. It is up to the caller to finalize this array later on, using <a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/string__array_8h.html#a14634c20c63ae8dd8ef072ce9147a91d">rcutils_string_array_fini()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node_namespaces</td><td>Array of discovered node namespaces, populated on success. It is up to the caller to finalize this array later on, using <a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/string__array_8h.html#a14634c20c63ae8dd8ef072ce9147a91d">rcutils_string_array_fini()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">enclaves</td><td>Array of discovered node enclave names, populated on success. It is up to the caller to finalize this array later on, using <a class="elRef" href="http://docs.ros2.org/humble/api/rcutils/string__array_8h.html#a14634c20c63ae8dd8ef072ce9147a91d">rcutils_string_array_fini()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if the query was successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>node</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>node_names</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>node_names</code> is not a zero-initialized array, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>node_namespaces</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>node_namespaces</code> is not a zero-initialized array, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>enclaves</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>enclaves</code> is not a zero-initialized array, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>node</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation fails, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a83c761fb53a29f44b41fc299ffbb9cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c761fb53a29f44b41fc299ffbb9cb4">&#9670;&nbsp;</a></span>rmw_count_publishers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_count_publishers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of known publishers matching a topic name. </p>
<p>This function returns the numbers of publishers of a given topic in the ROS graph, as discovered so far by the given node.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check the implementation documentation</em></p>
<dl class="section user"><dt>Runtime behavior</dt><dd>To query the ROS graph is a synchronous operation. It is also non-blocking, but it is not guaranteed to be lock-free. Generally speaking, implementations may synchronize access to internal resources using locks but are not allowed to wait for events with no guaranteed time bound (barring the effects of starvation due to OS scheduling).</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Nodes are thread-safe objects, and so are all operations on them except for finalization. Therefore, it is safe to query the ROS graph using the same node concurrently. However, access to primitive data-type arguments is not synchronized. It is not safe to read or write <code>topic_name</code> or <code>count</code> while <a class="el" href="rmw_8h.html#a83c761fb53a29f44b41fc299ffbb9cb4" title="Count the number of known publishers matching a topic name.">rmw_count_publishers()</a> uses them.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>node</code> must be a valid node handle, as returned by <a class="el" href="rmw_8h.html#aeb06f551db3cbcd6298ed8f20e3ed8d2" title="Create a node and return a handle to that node.">rmw_create_node()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Handle to node to use to query the ROS graph. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topic_name</td><td>Fully qualified ROS topic name. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">count</td><td>Number of publishers matching the given topic name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if the query was successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>node</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>topic_name</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>topic_name</code> is not a fully qualified topic name, by <a class="el" href="validate__full__topic__name_8h.html#a5bf7cd29da7f1c6c28bff9e24fa8328d" title="Determine if a given fully qualified topic name is valid.">rmw_validate_full_topic_name()</a> definition, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>count</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>node</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a3d48df829636837092ef47f91514675e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d48df829636837092ef47f91514675e">&#9670;&nbsp;</a></span>rmw_count_subscribers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_count_subscribers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of known subscribers matching a topic name. </p>
<p>This function returns the numbers of subscribers of a given topic in the ROS graph, as discovered so far by the given node.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check the implementation documentation</em></p>
<dl class="section user"><dt>Runtime behavior</dt><dd>To query the ROS graph is a synchronous operation. It is also non-blocking, but it is not guaranteed to be lock-free. Generally speaking, implementations may synchronize access to internal resources using locks but are not allowed to wait for events with no guaranteed time bound (barring the effects of starvation due to OS scheduling).</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Nodes are thread-safe objects, and so are all operations on them except for finalization. Therefore, it is to query the ROS graph using the same node concurrently. However, access to primitive data-type arguments is not synchronized. It is not safe to read or write <code>topic_name</code> or <code>count</code> while <a class="el" href="rmw_8h.html#a3d48df829636837092ef47f91514675e" title="Count the number of known subscribers matching a topic name.">rmw_count_subscribers()</a> uses them.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>node</code> must be a valid node handle, as returned by <a class="el" href="rmw_8h.html#aeb06f551db3cbcd6298ed8f20e3ed8d2" title="Create a node and return a handle to that node.">rmw_create_node()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Handle to node to use to query the ROS graph. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topic_name</td><td>Fully qualified ROS topic name. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">count</td><td>Number of subscribers matching the given topic name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if the query was successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>node</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>topic_name</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>topic_name</code> is not a fully qualified topic name, by <a class="el" href="validate__full__topic__name_8h.html#a5bf7cd29da7f1c6c28bff9e24fa8328d" title="Determine if a given fully qualified topic name is valid.">rmw_validate_full_topic_name()</a> definition, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>count</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>node</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a846898b23af992f7f3eaa17eaf741e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a846898b23af992f7f3eaa17eaf741e9f">&#9670;&nbsp;</a></span>rmw_get_gid_for_publisher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_get_gid_for_publisher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#acb16586307694dcc71965aacaba5ae98">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a5be70c7256d63d47870e13224ee1dc57">rmw_gid_t</a> *&#160;</td>
          <td class="paramname"><em>gid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the unique identifier (gid) of a publisher. </p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check implementation documentation.</em></p>
<dl class="section user"><dt>Thread-safety</dt><dd>Publishers are thread-safe objects, and so are all operations on them except for finalization. Therefore, it is safe to get the unique identifier from the same publisher concurrently. However, access to the gid is not synchronized. It is not safe to read or write <code>gid</code> while <a class="el" href="rmw_8h.html#a846898b23af992f7f3eaa17eaf741e9f" title="Get the unique identifier (gid) of a publisher.">rmw_get_gid_for_publisher()</a> uses it.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>publisher</code> must be a valid publisher, as returned by <a class="el" href="rmw_8h.html#ac74022d90eb22d95b082d4808670f8a9" title="Create a publisher and return a handle to that publisher.">rmw_create_publisher()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>Publisher to get a gid from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gid</td><td>Publisher's unique identifier, populated on success but left unchanged on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>publisher</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>gid</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the <code>publisher</code> implementation identifier does not match this implementation, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a280fd9c0cf4fc49fbe6786b64b835194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280fd9c0cf4fc49fbe6786b64b835194">&#9670;&nbsp;</a></span>rmw_compare_gids_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_compare_gids_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a5be70c7256d63d47870e13224ee1dc57">rmw_gid_t</a> *&#160;</td>
          <td class="paramname"><em>gid1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a5be70c7256d63d47870e13224ee1dc57">rmw_gid_t</a> *&#160;</td>
          <td class="paramname"><em>gid2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two unique identifiers (gids) are equal. </p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check implementation documentation.</em></p>
<dl class="section user"><dt>Thread-safety</dt><dd>Unique identifier comparison is a reentrant function, but:<ul>
<li>Access to both gids is read-only but it is not synchronized. Concurrent <code>gid1</code> and <code>gid2</code> reads are safe, but concurrent reads and writes are not.</li>
<li>Access to primitive data-type arguments is not synchronized. It is not safe to read or write <code>result</code> while <a class="el" href="rmw_8h.html#a280fd9c0cf4fc49fbe6786b64b835194" title="Check if two unique identifiers (gids) are equal.">rmw_compare_gids_equal()</a> uses it.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gid1</td><td>First unique identifier to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gid2</td><td>Second unique identifier to compare. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>true if both gids are equal, false otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>gid1</code> or <code>gid2</code> is NULL, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the implementation identifier of <code>gid1</code> or <code>gid2</code> does not match this implementation, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="af0cec9687e5e4738aba7e061014eb3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0cec9687e5e4738aba7e061014eb3d5">&#9670;&nbsp;</a></span>rmw_service_server_is_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_service_server_is_available </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#aa4107492f674f1a634a2ad5b4075ce44">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#afc04b99b504df3d1dfc167c4a46214a2">rmw_client_t</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_available</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a service server is available for the given service client. </p>
<p>This function checks whether one or more service services matching the given service client exist in the ROS graph, as discovered so far by the given local node.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute   </th><th class="markdownTableHeadNone">Adherence    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics   </td><td class="markdownTableBodyNone">Maybe [1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free   </td><td class="markdownTableBodyNone">Maybe [1]   </td></tr>
</table>
<p><em>[1] implementation defined, check implementation documentation.</em></p>
<dl class="section user"><dt>Runtime behavior</dt><dd>To query the ROS graph is a synchronous operation. It is also non-blocking, but it is not guaranteed to be lock-free. Generally speaking, implementations may synchronize access to internal resources using locks but are not allowed to wait for events with no guaranteed time bound (barring the effects of starvation due to OS scheduling).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>node</code> must be a valid node, as returned by <a class="el" href="rmw_8h.html#aeb06f551db3cbcd6298ed8f20e3ed8d2" title="Create a node and return a handle to that node.">rmw_create_node()</a>. </dd>
<dd>
Given <code>client</code> must be a valid client, as returned by <a class="el" href="rmw_8h.html#a208bb1dd4d3c77cceee53ceba7abb8ac" title="Create a service client that can send requests to and receive replies from a service server.">rmw_create_client()</a>. </dd>
<dd>
Given <code>node</code> must be the one the <code>client</code> was registered with.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Node to query the ROS graph. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">client</td><td>Service client to look for matching service servers. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_available</td><td>True if there is a service server available, else false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>node</code> is <code>NULL</code>, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>client</code> is <code>NULL</code>, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>is_available</code> is <code>NULL</code>, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the implementation identifier of <code>node</code> or <code>client</code> does not match this implementation, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a95cc3dd8de47abb8a105d0b8a30419c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95cc3dd8de47abb8a105d0b8a30419c9">&#9670;&nbsp;</a></span>rmw_set_log_severity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_set_log_severity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a607a331d0f863b03e03c892ab45a03a0">rmw_log_severity_t</a>&#160;</td>
          <td class="paramname"><em>severity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current log severity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">severity</td><td>The log severity to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RMW_RET_OK if successful, otherwise an appropriate error code </dd></dl>

</div>
</div>
<a id="aea20ab8bae7e3085de0cbe06564b4e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea20ab8bae7e3085de0cbe06564b4e93">&#9670;&nbsp;</a></span>rmw_subscription_set_on_new_message_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_subscription_set_on_new_message_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a52d694cded1baf92185c3942b0a1db3a">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="event__callback__type_8h.html#a1333e7f82698dd85b57c1852c2f090c0">rmw_event_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the on new message callback function for the subscription. </p>
<p>This API sets the callback function to be called whenever the subscription is notified about a new message.</p>
<p>This callback is called for each new message received by the subscription. If messages arrive before the callback is registered, the number_of_events argument given to the callback may be &gt; 1.</p>
<p>The callback may be called from a thread that the rmw implementation created, rather than a thread owned by the user, i.e. some thread other than user owned threads calling rmw functions such as <a class="el" href="rmw_8h.html#a5f480dd59075e80288fb596b2951be2b" title="Waits on sets of different entities and returns when one is ready.">rmw_wait()</a> or <a class="el" href="rmw_8h.html#ab625a62ba2f32e3d3a7c7ca1f6e0dbd6" title="Publish a ROS message.">rmw_publish()</a>.</p>
<p>This function is thread-safe. This is required of the rmw implementation because the callback may be called from any middleware thread, and this function could be called by the user at any time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>The subscription on which to set the callback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to be called when new messages arrive, can be NULL to clear the registered callback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>Given to the callback when called later, may be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>subscription</code> is NULL, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if the API is not implemented in the dds implementation </dd></dl>

</div>
</div>
<a id="a16d8166fcd185bb40fa4b316f422e896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d8166fcd185bb40fa4b316f422e896">&#9670;&nbsp;</a></span>rmw_service_set_on_new_request_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_service_set_on_new_request_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a562ff74fd2c35c006bac0f8a98dabd7e">rmw_service_t</a> *&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="event__callback__type_8h.html#a1333e7f82698dd85b57c1852c2f090c0">rmw_event_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the on new request callback function for the service. </p>
<p>This API sets the callback function to be called whenever the service is notified about a new request.</p>
<p>This callback is called for each new request received by the service. If requests arrive before the callback is registered, the number_of_events argument given to the callback may be &gt; 1.</p>
<p>The callback may be called from a thread that the rmw implementation created, rather than a thread owned by the user, i.e. some thread other than user owned threads calling rmw functions such as <a class="el" href="rmw_8h.html#a5f480dd59075e80288fb596b2951be2b" title="Waits on sets of different entities and returns when one is ready.">rmw_wait()</a> or <a class="el" href="rmw_8h.html#a9abc3e631cd2529f168d04be97f1db29" title="Send a ROS service request.">rmw_send_request()</a>.</p>
<p>This function is thread-safe. This is required of the rmw implementation because the callback may be called from any middleware thread, and this function could be called by the user at any time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">service</td><td>The service on which to set the callback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to be called when new requests arrive, can be NULL to clear the registered callback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>Given to the callback when called later, may be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if callback was set to the listener, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>service</code> is NULL, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if the API is not implemented in the dds implementation </dd></dl>

</div>
</div>
<a id="a2195fea162b6f4b30f2d7bdd00a56401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2195fea162b6f4b30f2d7bdd00a56401">&#9670;&nbsp;</a></span>rmw_client_set_on_new_response_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_client_set_on_new_response_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#afc04b99b504df3d1dfc167c4a46214a2">rmw_client_t</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="event__callback__type_8h.html#a1333e7f82698dd85b57c1852c2f090c0">rmw_event_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the on new response callback function for the client. </p>
<p>This API sets the callback function to be called whenever the client is notified about a new response.</p>
<p>This callback is called for each new response received by the client. If responses arrive before the callback is registered, the number_of_events argument given to the callback may be &gt; 1.</p>
<p>The callback may be called from a thread that the rmw implementation created, rather than a thread owned by the user, i.e. some thread other than user owned threads calling rmw functions such as <a class="el" href="rmw_8h.html#a5f480dd59075e80288fb596b2951be2b" title="Waits on sets of different entities and returns when one is ready.">rmw_wait()</a> or <a class="el" href="rmw_8h.html#a31be4bb944b42b553a700a762d789dee" title="Take an incoming ROS service response.">rmw_take_response()</a>.</p>
<p>This function is thread-safe. This is required of the rmw implementation because the callback may be called from any middleware thread, and this function could be called by the user at any time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">client</td><td>The client on which to set the callback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to be called when new responses arrive, can be NULL to clear the registered callback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>Given to the callback when called later, may be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if callback was set to the listener, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>client</code> is NULL, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if the API is not implemented in the dds implementation </dd></dl>

</div>
</div>
<a id="af94efb0cd4a8f8b4568eeec1a2e51161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94efb0cd4a8f8b4568eeec1a2e51161">&#9670;&nbsp;</a></span>rmw_event_set_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_event_set_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="event_8h.html#a43057ed2076d1cf5a7fa7dda1fd84f47">rmw_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="event__callback__type_8h.html#a1333e7f82698dd85b57c1852c2f090c0">rmw_event_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the callback function for the event. </p>
<p>This API sets the callback function to be called whenever the event is notified about a new instance of the event.</p>
<p>For example, this could be called when incompatible QoS is detected, or a deadline is missed, or any other QoS event.</p>
<p>This callback is called for each new event that occurs for this rmw_event_t instance. If events occur before the callback is registered, the number_of_events argument given to the callback may be &gt; 1.</p>
<p>The callback may be called from a thread that the rmw implementation created, rather than a thread owned by the user, i.e. some thread other than user owned threads calling rmw functions such as <a class="el" href="rmw_8h.html#a5f480dd59075e80288fb596b2951be2b" title="Waits on sets of different entities and returns when one is ready.">rmw_wait()</a> or <a class="el" href="rmw_8h.html#ab625a62ba2f32e3d3a7c7ca1f6e0dbd6" title="Publish a ROS message.">rmw_publish()</a>.</p>
<p>This function is thread-safe. This is required of the rmw implementation because the callback may be called from any middleware thread, and this function could be called by the user at any time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>The event on which to set the callback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to be called when new events occur, can be NULL to clear the registered callback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>Given to the callback when called later, may be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if callback was set to the listener, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if <code>event</code> is NULL, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if the API is not implemented in the dds implementation </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
