<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rclcpp: rclcpp::wait_set_policies::detail::WritePreferringReadWriteLock Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rclcpp
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C++ ROS Client Library API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerclcpp.html">rclcpp</a></li><li class="navelem"><a class="el" href="namespacerclcpp_1_1wait__set__policies.html">wait_set_policies</a></li><li class="navelem"><a class="el" href="namespacerclcpp_1_1wait__set__policies_1_1detail.html">detail</a></li><li class="navelem"><a class="el" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock.html">WritePreferringReadWriteLock</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rclcpp::wait_set_policies::detail::WritePreferringReadWriteLock Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Writer-perferring read-write lock.  
 <a href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="write__preferring__read__write__lock_8hpp_source.html">write_preferring_read_write_lock.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for rclcpp::wait_set_policies::detail::WritePreferringReadWriteLock:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock__coll__graph.png" border="0" usemap="#arclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock_coll__map" alt="Collaboration graph"/></div>
<map name="arclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock_coll__map" id="arclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock_coll__map">
<area shape="rect" title="Writer&#45;perferring read&#45;write lock." alt="" coords="5,55,277,97"/>
<area shape="rect" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock_1_1WriteMutex.html" title="Write mutex for the WritePreferringReadWriteLock." alt="" coords="419,5,661,61"/>
<area shape="rect" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock_1_1ReadMutex.html" title="Read mutex for the WritePreferringReadWriteLock." alt="" coords="419,91,661,147"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock_1_1ReadMutex.html">ReadMutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read mutex for the <a class="el" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock.html" title="Writer-perferring read-write lock.">WritePreferringReadWriteLock</a>.  <a href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock_1_1ReadMutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock_1_1WriteMutex.html">WriteMutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write mutex for the <a class="el" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock.html" title="Writer-perferring read-write lock.">WritePreferringReadWriteLock</a>.  <a href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock_1_1WriteMutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abc763676b1ef57111ab7ba02dff17952"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock.html#abc763676b1ef57111ab7ba02dff17952">WritePreferringReadWriteLock</a> (std::function&lt; void()&gt; enter_waiting_function=nullptr)</td></tr>
<tr class="separator:abc763676b1ef57111ab7ba02dff17952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663bb0664988b9c6754b1327078f6704"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock_1_1ReadMutex.html">ReadMutex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock.html#a663bb0664988b9c6754b1327078f6704">get_read_mutex</a> ()</td></tr>
<tr class="memdesc:a663bb0664988b9c6754b1327078f6704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return read mutex which can be used with standard constructs like std::lock_guard.  <a href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock.html#a663bb0664988b9c6754b1327078f6704">More...</a><br /></td></tr>
<tr class="separator:a663bb0664988b9c6754b1327078f6704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72f99da9fe1ce7ccaae58b737e653be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock_1_1WriteMutex.html">WriteMutex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock.html#ad72f99da9fe1ce7ccaae58b737e653be">get_write_mutex</a> ()</td></tr>
<tr class="memdesc:ad72f99da9fe1ce7ccaae58b737e653be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return write mutex which can be used with standard constructs like std::lock_guard.  <a href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock.html#ad72f99da9fe1ce7ccaae58b737e653be">More...</a><br /></td></tr>
<tr class="separator:ad72f99da9fe1ce7ccaae58b737e653be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a94054abda39ee4cf1dad5e682f7324ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock.html#a94054abda39ee4cf1dad5e682f7324ad">reader_active_</a> = false</td></tr>
<tr class="separator:a94054abda39ee4cf1dad5e682f7324ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40eb9d8e2b4dc67598494357268e9186"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock.html#a40eb9d8e2b4dc67598494357268e9186">number_of_writers_waiting_</a> = 0</td></tr>
<tr class="separator:a40eb9d8e2b4dc67598494357268e9186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e320bd65cbe5ebe9b504449b22e499"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock.html#a78e320bd65cbe5ebe9b504449b22e499">writer_active_</a> = false</td></tr>
<tr class="separator:a78e320bd65cbe5ebe9b504449b22e499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7e2dc6110d908f602c44f999f14302"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock.html#a4b7e2dc6110d908f602c44f999f14302">mutex_</a></td></tr>
<tr class="separator:a4b7e2dc6110d908f602c44f999f14302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58524cbeaa93356b594b45f0062c8363"><td class="memItemLeft" align="right" valign="top">std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock.html#a58524cbeaa93356b594b45f0062c8363">condition_variable_</a></td></tr>
<tr class="separator:a58524cbeaa93356b594b45f0062c8363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac790a9680f11d081af241a4336faea79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock_1_1ReadMutex.html">ReadMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock.html#ac790a9680f11d081af241a4336faea79">read_mutex_</a></td></tr>
<tr class="separator:ac790a9680f11d081af241a4336faea79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb73ca818495131f81564de9c5a3667"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock_1_1WriteMutex.html">WriteMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock.html#a7bb73ca818495131f81564de9c5a3667">write_mutex_</a></td></tr>
<tr class="separator:a7bb73ca818495131f81564de9c5a3667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8396cf4e28ac6131d9cc2c31392a5bbc"><td class="memItemLeft" align="right" valign="top">std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock.html#a8396cf4e28ac6131d9cc2c31392a5bbc">enter_waiting_function_</a></td></tr>
<tr class="separator:a8396cf4e28ac6131d9cc2c31392a5bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Writer-perferring read-write lock. </p>
<p>This class is based on an implementation of a "write-preferring RW lock" as described in this wikipedia page:</p>
<p><a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock#Using_a_condition_variable_and_a_mutex">https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock#Using_a_condition_variable_and_a_mutex</a></p>
<p>Copying here for posterity:</p>
<pre class="fragment">*   For a write-preferring RW lock one can use two integer counters and one boolean flag:
*
*       num_readers_active: the number of readers that have acquired the lock (integer)
*       num_writers_waiting: the number of writers waiting for access (integer)
*       writer_active: whether a writer has acquired the lock (boolean).
*
*   Initially num_readers_active and num_writers_waiting are zero and writer_active is false.
*
*   The lock and release operations can be implemented as
*
*   Begin Read
*
*       Lock g
*       While num_writers_waiting &gt; 0 or writer_active:
*           wait cond, g[a]
*       Increment num_readers_active
*       Unlock g.
*
*   End Read
*
*       Lock g
*       Decrement num_readers_active
*       If num_readers_active = 0:
*           Notify cond (broadcast)
*       Unlock g.
*
*   Begin Write
*
*       Lock g
*       Increment num_writers_waiting
*       While num_readers_active &gt; 0 or writer_active is true:
*           wait cond, g
*       Decrement num_writers_waiting
*       Set writer_active to true
*       Unlock g.
*
*   End Write
*
*       Lock g
*       Set writer_active to false
*       Notify cond (broadcast)
*       Unlock g.
* </pre><p>It will prefer any waiting write calls to any waiting read calls, meaning that excessive write calls can starve read calls.</p>
<p>This class diverges from that design in two important ways. First, it is a single reader, single writer version. Second, it allows for user defined code to be run after a writer enters the waiting state, and the purpose of this feature is to allow the user to interrupt any potentially long blocking read activities.</p>
<p>Together these two features allow new waiting writers to not only ensure they get the lock before any queued readers, but also that it can safely interrupt read activities if needed, without allowing new read activities to start before it gains the lock.</p>
<p>The first difference prevents the case that a multiple read activities occur at the same time but the writer can only reliably interrupt one of them. By preventing multiple read activities concurrently, this case is avoided. The second difference allows the user to define how to interrupt read activity that could be blocking the write activities that need to happen as soon as possible.</p>
<p>To implement the differences, this class replaces the "num_readers_active" counter with a "reader_active" boolean. It also changes the "Begin Read" section from above, like this:</p>
<pre class="fragment">*   Begin Read
*
*       Lock g
*       While num_writers_waiting &gt; 0 or writer_active or reader_active:  // changed
*           wait cond, g[a]
*       Set reader_active to true  // changed
*       Unlock g.
* </pre><p>And changes the "End Read" section from above, like this:</p>
<pre class="fragment">*   End Read
*
*       Lock g
*       Set reader_active to false  // changed
*       Notify cond (broadcast)  // changed, now unconditional
*       Unlock g.
* </pre><p>The "Begin Write" section is also updated as follows:</p>
<pre class="fragment">*   Begin Write
*
*       Lock g
*       Increment num_writers_waiting
*       Call user defined enter_waiting function  // new
*       While reader_active is true or writer_active is true:  // changed
*           wait cond, g
*       Decrement num_writers_waiting
*       Set writer_active to true
*       Unlock g.
* </pre><p>The implementation uses a single condition variable, single lock, and several state variables.</p>
<p>The typical use of this class is as follows: </p><pre class="fragment">class MyClass
{
  WritePreferringReadWriteLock wprw_lock_;
public:
  MyClass() {}
  void do_some_reading()
  {
    using rclcpp::wait_set_policies::detail::WritePreferringReadWriteLock;
    std::lock_guard&lt;WritePreferringReadWriteLock::ReadMutex&gt; lock(wprw_lock_.get_read_mutex());
    // Do reading...
  }
  void do_some_writing()
  {
    using rclcpp::wait_set_policies::detail::WritePreferringReadWriteLock;
    std::lock_guard&lt;WritePreferringReadWriteLock::WriteMutex&gt; lock(wprw_lock_.get_write_mutex());
    // Do writing...
  }
};
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abc763676b1ef57111ab7ba02dff17952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc763676b1ef57111ab7ba02dff17952">&#9670;&nbsp;</a></span>WritePreferringReadWriteLock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::wait_set_policies::detail::WritePreferringReadWriteLock::WritePreferringReadWriteLock </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>enter_waiting_function</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a663bb0664988b9c6754b1327078f6704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663bb0664988b9c6754b1327078f6704">&#9670;&nbsp;</a></span>get_read_mutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock_1_1ReadMutex.html">ReadMutex</a>&amp; rclcpp::wait_set_policies::detail::WritePreferringReadWriteLock::get_read_mutex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return read mutex which can be used with standard constructs like std::lock_guard. </p>

</div>
</div>
<a id="ad72f99da9fe1ce7ccaae58b737e653be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad72f99da9fe1ce7ccaae58b737e653be">&#9670;&nbsp;</a></span>get_write_mutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock_1_1WriteMutex.html">WriteMutex</a>&amp; rclcpp::wait_set_policies::detail::WritePreferringReadWriteLock::get_write_mutex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return write mutex which can be used with standard constructs like std::lock_guard. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a94054abda39ee4cf1dad5e682f7324ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94054abda39ee4cf1dad5e682f7324ad">&#9670;&nbsp;</a></span>reader_active_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::wait_set_policies::detail::WritePreferringReadWriteLock::reader_active_ = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a40eb9d8e2b4dc67598494357268e9186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40eb9d8e2b4dc67598494357268e9186">&#9670;&nbsp;</a></span>number_of_writers_waiting_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t rclcpp::wait_set_policies::detail::WritePreferringReadWriteLock::number_of_writers_waiting_ = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a78e320bd65cbe5ebe9b504449b22e499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e320bd65cbe5ebe9b504449b22e499">&#9670;&nbsp;</a></span>writer_active_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::wait_set_policies::detail::WritePreferringReadWriteLock::writer_active_ = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b7e2dc6110d908f602c44f999f14302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7e2dc6110d908f602c44f999f14302">&#9670;&nbsp;</a></span>mutex_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex rclcpp::wait_set_policies::detail::WritePreferringReadWriteLock::mutex_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a58524cbeaa93356b594b45f0062c8363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58524cbeaa93356b594b45f0062c8363">&#9670;&nbsp;</a></span>condition_variable_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::condition_variable rclcpp::wait_set_policies::detail::WritePreferringReadWriteLock::condition_variable_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac790a9680f11d081af241a4336faea79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac790a9680f11d081af241a4336faea79">&#9670;&nbsp;</a></span>read_mutex_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock_1_1ReadMutex.html">ReadMutex</a> rclcpp::wait_set_policies::detail::WritePreferringReadWriteLock::read_mutex_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7bb73ca818495131f81564de9c5a3667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb73ca818495131f81564de9c5a3667">&#9670;&nbsp;</a></span>write_mutex_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1wait__set__policies_1_1detail_1_1WritePreferringReadWriteLock_1_1WriteMutex.html">WriteMutex</a> rclcpp::wait_set_policies::detail::WritePreferringReadWriteLock::write_mutex_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8396cf4e28ac6131d9cc2c31392a5bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8396cf4e28ac6131d9cc2c31392a5bbc">&#9670;&nbsp;</a></span>enter_waiting_function_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void()&gt; rclcpp::wait_set_policies::detail::WritePreferringReadWriteLock::enter_waiting_function_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/rclcpp/wait_set_policies/detail/<a class="el" href="write__preferring__read__write__lock_8hpp_source.html">write_preferring_read_write_lock.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
