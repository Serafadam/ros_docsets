<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rclcpp: rclcpp::experimental::SubscriptionIntraProcessBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rclcpp
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C++ ROS Client Library API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerclcpp.html">rclcpp</a></li><li class="navelem"><a class="el" href="namespacerclcpp_1_1experimental.html">experimental</a></li><li class="navelem"><a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html">SubscriptionIntraProcessBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rclcpp::experimental::SubscriptionIntraProcessBase Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="subscription__intra__process__base_8hpp_source.html">subscription_intra_process_base.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rclcpp::experimental::SubscriptionIntraProcessBase:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase__inherit__graph.png" border="0" usemap="#arclcpp_1_1experimental_1_1SubscriptionIntraProcessBase_inherit__map" alt="Inheritance graph"/></div>
<map name="arclcpp_1_1experimental_1_1SubscriptionIntraProcessBase_inherit__map" id="arclcpp_1_1experimental_1_1SubscriptionIntraProcessBase_inherit__map">
<area shape="rect" title=" " alt="" coords="180,146,403,187"/>
<area shape="rect" href="classrclcpp_1_1experimental_1_1SubscriptionROSMsgIntraProcessBuffer.html" title=" " alt="" coords="451,28,797,172"/>
<area shape="rect" href="classrclcpp_1_1experimental_1_1SubscriptionROSMsgIntraProcessBuffer.html" title=" " alt="" coords="502,197,746,267"/>
<area shape="rect" href="classrclcpp_1_1Waitable.html" title=" " alt="" coords="5,153,132,180"/>
<area shape="rect" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBuffer.html" title=" " alt="" coords="845,5,1171,91"/>
<area shape="rect" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBuffer.html" title=" " alt="" coords="889,115,1127,186"/>
<area shape="rect" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcess.html" title=" " alt="" coords="1219,5,1487,91"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for rclcpp::experimental::SubscriptionIntraProcessBase:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase__coll__graph.png" border="0" usemap="#arclcpp_1_1experimental_1_1SubscriptionIntraProcessBase_coll__map" alt="Collaboration graph"/></div>
<map name="arclcpp_1_1experimental_1_1SubscriptionIntraProcessBase_coll__map" id="arclcpp_1_1experimental_1_1SubscriptionIntraProcessBase_coll__map">
<area shape="rect" title=" " alt="" coords="44,95,267,136"/>
<area shape="rect" href="classrclcpp_1_1Waitable.html" title=" " alt="" coords="5,5,132,32"/>
<area shape="rect" href="classrclcpp_1_1GuardCondition.html" title="A condition that can be waited on in a single wait set and asynchronously triggered." alt="" coords="157,5,327,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:adbc9d561fecd9ed3139ce852b19f732c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#adbc9d561fecd9ed3139ce852b19f732c">EntityType</a> : std::size_t { <a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#adbc9d561fecd9ed3139ce852b19f732ca787ad0b7a17de4ad6b1711bbf8d79fcb">Subscription</a>
 }</td></tr>
<tr class="separator:adbc9d561fecd9ed3139ce852b19f732c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac84d4c3c4b8f7e057a00fa68114a3b51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#ac84d4c3c4b8f7e057a00fa68114a3b51">SubscriptionIntraProcessBase</a> (rclcpp::Context::SharedPtr context, const std::string &amp;topic_name, const <a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> &amp;qos_profile)</td></tr>
<tr class="separator:ac84d4c3c4b8f7e057a00fa68114a3b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2008107d587e561dca3b4028d748e9"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#a7c2008107d587e561dca3b4028d748e9">~SubscriptionIntraProcessBase</a> ()</td></tr>
<tr class="separator:a7c2008107d587e561dca3b4028d748e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d59d6d0ae85ffdfc56c05f0f23d5729"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#a9d59d6d0ae85ffdfc56c05f0f23d5729">get_number_of_ready_guard_conditions</a> () override</td></tr>
<tr class="memdesc:a9d59d6d0ae85ffdfc56c05f0f23d5729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of ready guard_conditions.  <a href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#a9d59d6d0ae85ffdfc56c05f0f23d5729">More...</a><br /></td></tr>
<tr class="separator:a9d59d6d0ae85ffdfc56c05f0f23d5729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0b3a9736b6f6079041f4875495757b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#a4f0b3a9736b6f6079041f4875495757b">add_to_wait_set</a> (rcl_wait_set_t *wait_set) override</td></tr>
<tr class="memdesc:a4f0b3a9736b6f6079041f4875495757b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> to a wait set.  <a href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#a4f0b3a9736b6f6079041f4875495757b">More...</a><br /></td></tr>
<tr class="separator:a4f0b3a9736b6f6079041f4875495757b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9168f87ed731367f4d698835c6b5c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#aee9168f87ed731367f4d698835c6b5c0">is_ready</a> (rcl_wait_set_t *wait_set) override=0</td></tr>
<tr class="memdesc:aee9168f87ed731367f4d698835c6b5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> is ready.  <a href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#aee9168f87ed731367f4d698835c6b5c0">More...</a><br /></td></tr>
<tr class="separator:aee9168f87ed731367f4d698835c6b5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa71f4648efd0f70e937e60a94a31d9"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#aefa71f4648efd0f70e937e60a94a31d9">take_data</a> () override=0</td></tr>
<tr class="memdesc:aefa71f4648efd0f70e937e60a94a31d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the data so that it can be consumed with <code>execute</code>.  <a href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#aefa71f4648efd0f70e937e60a94a31d9">More...</a><br /></td></tr>
<tr class="separator:aefa71f4648efd0f70e937e60a94a31d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f39a3d4af6aa06a4bae0367941c7ba3"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#a2f39a3d4af6aa06a4bae0367941c7ba3">take_data_by_entity_id</a> (size_t id) override</td></tr>
<tr class="memdesc:a2f39a3d4af6aa06a4bae0367941c7ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the data so that it can be consumed with <code>execute</code>.  <a href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#a2f39a3d4af6aa06a4bae0367941c7ba3">More...</a><br /></td></tr>
<tr class="separator:a2f39a3d4af6aa06a4bae0367941c7ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca4cd6e8f8fb1c5daee302661ac7c56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#a7ca4cd6e8f8fb1c5daee302661ac7c56">execute</a> (std::shared_ptr&lt; void &gt; &amp;data) override=0</td></tr>
<tr class="memdesc:a7ca4cd6e8f8fb1c5daee302661ac7c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute data that is passed in.  <a href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#a7ca4cd6e8f8fb1c5daee302661ac7c56">More...</a><br /></td></tr>
<tr class="separator:a7ca4cd6e8f8fb1c5daee302661ac7c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69ddb435daba3fe30797ce971766524"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#ab69ddb435daba3fe30797ce971766524">use_take_shared_method</a> () const =0</td></tr>
<tr class="separator:ab69ddb435daba3fe30797ce971766524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4834d68b40a4d5700b5b8a4f1a5222c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#ae4834d68b40a4d5700b5b8a4f1a5222c">get_topic_name</a> () const</td></tr>
<tr class="separator:ae4834d68b40a4d5700b5b8a4f1a5222c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2fe3f581738cd0d8fe68e5ff43b8d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1QoS.html">QoS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#abc2fe3f581738cd0d8fe68e5ff43b8d8">get_actual_qos</a> () const</td></tr>
<tr class="separator:abc2fe3f581738cd0d8fe68e5ff43b8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab823457f413f244c6fe7492b12c7265b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#ab823457f413f244c6fe7492b12c7265b">set_on_ready_callback</a> (std::function&lt; void(size_t, int)&gt; callback) override</td></tr>
<tr class="memdesc:ab823457f413f244c6fe7492b12c7265b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a callback to be called when each new message arrives.  <a href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#ab823457f413f244c6fe7492b12c7265b">More...</a><br /></td></tr>
<tr class="separator:ab823457f413f244c6fe7492b12c7265b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c542a3e38db47bb6ed5c368ebd4d876"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#a1c542a3e38db47bb6ed5c368ebd4d876">clear_on_ready_callback</a> () override</td></tr>
<tr class="memdesc:a1c542a3e38db47bb6ed5c368ebd4d876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unset the callback registered for new messages, if any.  <a href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#a1c542a3e38db47bb6ed5c368ebd4d876">More...</a><br /></td></tr>
<tr class="separator:a1c542a3e38db47bb6ed5c368ebd4d876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classrclcpp_1_1Waitable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrclcpp_1_1Waitable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classrclcpp_1_1Waitable.html">rclcpp::Waitable</a></td></tr>
<tr class="memitem:a775475ffdec36b88279a0d671739cce2 inherit pub_methods_classrclcpp_1_1Waitable"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Waitable.html#a775475ffdec36b88279a0d671739cce2">~Waitable</a> ()=default</td></tr>
<tr class="separator:a775475ffdec36b88279a0d671739cce2 inherit pub_methods_classrclcpp_1_1Waitable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f428f90de03558d8e5090b45fa96ac8 inherit pub_methods_classrclcpp_1_1Waitable"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Waitable.html#a4f428f90de03558d8e5090b45fa96ac8">get_number_of_ready_subscriptions</a> ()</td></tr>
<tr class="memdesc:a4f428f90de03558d8e5090b45fa96ac8 inherit pub_methods_classrclcpp_1_1Waitable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of ready subscriptions.  <a href="classrclcpp_1_1Waitable.html#a4f428f90de03558d8e5090b45fa96ac8">More...</a><br /></td></tr>
<tr class="separator:a4f428f90de03558d8e5090b45fa96ac8 inherit pub_methods_classrclcpp_1_1Waitable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46ecd60ac2ddee1a76f280a05155334 inherit pub_methods_classrclcpp_1_1Waitable"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Waitable.html#af46ecd60ac2ddee1a76f280a05155334">get_number_of_ready_timers</a> ()</td></tr>
<tr class="memdesc:af46ecd60ac2ddee1a76f280a05155334 inherit pub_methods_classrclcpp_1_1Waitable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of ready timers.  <a href="classrclcpp_1_1Waitable.html#af46ecd60ac2ddee1a76f280a05155334">More...</a><br /></td></tr>
<tr class="separator:af46ecd60ac2ddee1a76f280a05155334 inherit pub_methods_classrclcpp_1_1Waitable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7d6a8213736f5a60d9c8f9290866a9 inherit pub_methods_classrclcpp_1_1Waitable"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Waitable.html#aeb7d6a8213736f5a60d9c8f9290866a9">get_number_of_ready_clients</a> ()</td></tr>
<tr class="memdesc:aeb7d6a8213736f5a60d9c8f9290866a9 inherit pub_methods_classrclcpp_1_1Waitable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of ready clients.  <a href="classrclcpp_1_1Waitable.html#aeb7d6a8213736f5a60d9c8f9290866a9">More...</a><br /></td></tr>
<tr class="separator:aeb7d6a8213736f5a60d9c8f9290866a9 inherit pub_methods_classrclcpp_1_1Waitable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441c473cb21623371b8ae0bc4d4ff7ce inherit pub_methods_classrclcpp_1_1Waitable"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Waitable.html#a441c473cb21623371b8ae0bc4d4ff7ce">get_number_of_ready_events</a> ()</td></tr>
<tr class="memdesc:a441c473cb21623371b8ae0bc4d4ff7ce inherit pub_methods_classrclcpp_1_1Waitable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of ready events.  <a href="classrclcpp_1_1Waitable.html#a441c473cb21623371b8ae0bc4d4ff7ce">More...</a><br /></td></tr>
<tr class="separator:a441c473cb21623371b8ae0bc4d4ff7ce inherit pub_methods_classrclcpp_1_1Waitable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49309417506cfee91923ce88ce95b63f inherit pub_methods_classrclcpp_1_1Waitable"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Waitable.html#a49309417506cfee91923ce88ce95b63f">get_number_of_ready_services</a> ()</td></tr>
<tr class="memdesc:a49309417506cfee91923ce88ce95b63f inherit pub_methods_classrclcpp_1_1Waitable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of ready services.  <a href="classrclcpp_1_1Waitable.html#a49309417506cfee91923ce88ce95b63f">More...</a><br /></td></tr>
<tr class="separator:a49309417506cfee91923ce88ce95b63f inherit pub_methods_classrclcpp_1_1Waitable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73eeb074bfbbd858d5c559d6b185ff8 inherit pub_methods_classrclcpp_1_1Waitable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Waitable.html#aa73eeb074bfbbd858d5c559d6b185ff8">exchange_in_use_by_wait_set_state</a> (bool in_use_state)</td></tr>
<tr class="memdesc:aa73eeb074bfbbd858d5c559d6b185ff8 inherit pub_methods_classrclcpp_1_1Waitable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange the "in use by wait set" state for this timer.  <a href="classrclcpp_1_1Waitable.html#aa73eeb074bfbbd858d5c559d6b185ff8">More...</a><br /></td></tr>
<tr class="separator:aa73eeb074bfbbd858d5c559d6b185ff8 inherit pub_methods_classrclcpp_1_1Waitable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af207140da2074cf7c89dcbf6649f53d5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#af207140da2074cf7c89dcbf6649f53d5">trigger_guard_condition</a> ()=0</td></tr>
<tr class="separator:af207140da2074cf7c89dcbf6649f53d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c287358d0f5e337d86d3ab69fda253"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#a15c287358d0f5e337d86d3ab69fda253">invoke_on_new_message</a> ()</td></tr>
<tr class="separator:a15c287358d0f5e337d86d3ab69fda253"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a94981e43acf10be7681e9849372fa2f9"><td class="memItemLeft" align="right" valign="top">std::recursive_mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#a94981e43acf10be7681e9849372fa2f9">callback_mutex_</a></td></tr>
<tr class="separator:a94981e43acf10be7681e9849372fa2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4def0ee9dc41211c9f7e783435533df"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(size_t)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#af4def0ee9dc41211c9f7e783435533df">on_new_message_callback_</a> {nullptr}</td></tr>
<tr class="separator:af4def0ee9dc41211c9f7e783435533df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718e01845e522641d813d5f0faacb6f6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#a718e01845e522641d813d5f0faacb6f6">unread_count_</a> {0}</td></tr>
<tr class="separator:a718e01845e522641d813d5f0faacb6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2dd3ebe79fbaf6fb7d846f6b4f0247b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1GuardCondition.html">rclcpp::GuardCondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#ac2dd3ebe79fbaf6fb7d846f6b4f0247b">gc_</a></td></tr>
<tr class="separator:ac2dd3ebe79fbaf6fb7d846f6b4f0247b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="adbc9d561fecd9ed3139ce852b19f732c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc9d561fecd9ed3139ce852b19f732c">&#9670;&nbsp;</a></span>EntityType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#adbc9d561fecd9ed3139ce852b19f732c">rclcpp::experimental::SubscriptionIntraProcessBase::EntityType</a> : std::size_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adbc9d561fecd9ed3139ce852b19f732ca787ad0b7a17de4ad6b1711bbf8d79fcb"></a>Subscription&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac84d4c3c4b8f7e057a00fa68114a3b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84d4c3c4b8f7e057a00fa68114a3b51">&#9670;&nbsp;</a></span>SubscriptionIntraProcessBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::experimental::SubscriptionIntraProcessBase::SubscriptionIntraProcessBase </td>
          <td>(</td>
          <td class="paramtype">rclcpp::Context::SharedPtr&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> &amp;&#160;</td>
          <td class="paramname"><em>qos_profile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c2008107d587e561dca3b4028d748e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2008107d587e561dca3b4028d748e9">&#9670;&nbsp;</a></span>~SubscriptionIntraProcessBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual rclcpp::experimental::SubscriptionIntraProcessBase::~SubscriptionIntraProcessBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9d59d6d0ae85ffdfc56c05f0f23d5729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d59d6d0ae85ffdfc56c05f0f23d5729">&#9670;&nbsp;</a></span>get_number_of_ready_guard_conditions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t rclcpp::experimental::SubscriptionIntraProcessBase::get_number_of_ready_guard_conditions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of ready guard_conditions. </p>
<p>Returns a value of 0 by default. This should be overridden if the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> contains one or more guard_conditions. </p><dl class="section return"><dt>Returns</dt><dd>The number of guard_conditions associated with the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classrclcpp_1_1Waitable.html#a154b4cee45c24584485586cb4de10ee8">rclcpp::Waitable</a>.</p>

</div>
</div>
<a id="a4f0b3a9736b6f6079041f4875495757b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f0b3a9736b6f6079041f4875495757b">&#9670;&nbsp;</a></span>add_to_wait_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::experimental::SubscriptionIntraProcessBase::add_to_wait_set </td>
          <td>(</td>
          <td class="paramtype">rcl_wait_set_t *&#160;</td>
          <td class="paramname"><em>wait_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> to a wait set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_set</td><td>A handle to the wait set to add the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rclcpp::execptions::RCLError</td><td>from rcl_wait_set_add_*() </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classrclcpp_1_1Waitable.html#ae2cbdb05dd021b246413d0dd01072412">rclcpp::Waitable</a>.</p>

</div>
</div>
<a id="aee9168f87ed731367f4d698835c6b5c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9168f87ed731367f4d698835c6b5c0">&#9670;&nbsp;</a></span>is_ready()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::experimental::SubscriptionIntraProcessBase::is_ready </td>
          <td>(</td>
          <td class="paramtype">rcl_wait_set_t *&#160;</td>
          <td class="paramname"><em>wait_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> is ready. </p>
<p>The input wait set should be the same that was used in a previously call to <code><a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#a4f0b3a9736b6f6079041f4875495757b" title="Add the Waitable to a wait set.">add_to_wait_set()</a></code>. The wait set should also have been previously waited on with <code>rcl_wait()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_set</td><td>A handle to the wait set the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> was previously added to and that has been waited on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> is ready, <code>false</code> otherwise. </dd></dl>

<p>Implements <a class="el" href="classrclcpp_1_1Waitable.html#a7a71a73b57677c3097012a0bb23b83d4">rclcpp::Waitable</a>.</p>

<p>Implemented in <a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBuffer.html#a9e83f1869eba9804e8d53852fdda7c76">rclcpp::experimental::SubscriptionIntraProcessBuffer&lt; SubscribedType, Alloc, Deleter, ROSMessageType &gt;</a>, and <a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBuffer.html#a9e83f1869eba9804e8d53852fdda7c76">rclcpp::experimental::SubscriptionIntraProcessBuffer&lt; SubscribedType, std::allocator&lt; SubscribedType &gt;, std::default_delete&lt; SubscribedType &gt;, SubscribedType &gt;</a>.</p>

</div>
</div>
<a id="aefa71f4648efd0f70e937e60a94a31d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa71f4648efd0f70e937e60a94a31d9">&#9670;&nbsp;</a></span>take_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;void&gt; rclcpp::experimental::SubscriptionIntraProcessBase::take_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take the data so that it can be consumed with <code>execute</code>. </p>
<p>NOTE: take_data is a partial fix to a larger design issue with the multithreaded executor. This method is likely to be removed when a more permanent fix is implemented. A longterm fix is currently being discussed here: <a href="https://github.com/ros2/rclcpp/pull/1276">https://github.com/ros2/rclcpp/pull/1276</a></p>
<p>This method takes the data from the underlying data structure and writes it to the void shared pointer <code>data</code> that is passed into the method. The <code>data</code> can then be executed with the <code>execute</code> method.</p>
<p>Before calling this method, the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> should be added to a wait set, waited on, and then updated.</p>
<p>Example usage:</p>
<div class="fragment"><div class="line"><span class="comment">// ... create a wait set and a Waitable</span></div>
<div class="line"><span class="comment">// Add the Waitable to the wait set</span></div>
<div class="line">waitable.add_to_wait_set(wait_set);</div>
<div class="line"><span class="comment">// Wait</span></div>
<div class="line">rcl_ret_t wait_ret = rcl_wait(wait_set);</div>
<div class="line"><span class="comment">// ... error handling</span></div>
<div class="line"><span class="comment">// Update the Waitable</span></div>
<div class="line">waitable.update(wait_set);</div>
<div class="line"><span class="comment">// Execute any entities of the Waitable that may be ready</span></div>
<div class="line">std::shared_ptr&lt;void&gt; data = waitable.take_data();</div>
</div><!-- fragment --> 
<p>Implements <a class="el" href="classrclcpp_1_1Waitable.html#a69bc70332645461c9317bbb59468c94b">rclcpp::Waitable</a>.</p>

<p>Implemented in <a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcess.html#a4f2a998479d2b1f8ca001066953966eb">rclcpp::experimental::SubscriptionIntraProcess&lt; MessageT, SubscribedType, SubscribedTypeAlloc, SubscribedTypeDeleter, ROSMessageType, Alloc &gt;</a>.</p>

</div>
</div>
<a id="a2f39a3d4af6aa06a4bae0367941c7ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f39a3d4af6aa06a4bae0367941c7ba3">&#9670;&nbsp;</a></span>take_data_by_entity_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;void&gt; rclcpp::experimental::SubscriptionIntraProcessBase::take_data_by_entity_id </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take the data so that it can be consumed with <code>execute</code>. </p>
<p>This function allows to specify an entity ID to take the data from. Entity IDs are identifiers that can be defined by waitable-derived classes that are composed of several distinct entities. The main use-case is in conjunction with the listener APIs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>the id of the entity from which to take </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-erased data taken from entity specified</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Waitable.html#a69bc70332645461c9317bbb59468c94b" title="Take the data so that it can be consumed with execute.">rclcpp::Waitable::take_data</a> </dd>
<dd>
<a class="el" href="classrclcpp_1_1Waitable.html#a48eae7264bbc8598ec5ee16a5c2035a4" title="Set a callback to be called whenever the waitable becomes ready.">rclcpp::Waitable::set_on_ready_callback</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classrclcpp_1_1Waitable.html#a9c3b5a6501ecbd76090ce032ce5f000c">rclcpp::Waitable</a>.</p>

</div>
</div>
<a id="a7ca4cd6e8f8fb1c5daee302661ac7c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca4cd6e8f8fb1c5daee302661ac7c56">&#9670;&nbsp;</a></span>execute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::experimental::SubscriptionIntraProcessBase::execute </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute data that is passed in. </p>
<p>Before calling this method, the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> should be added to a wait set, waited on, and then updated - and the <code>take_data</code> method should be called.</p>
<p>Example usage:</p>
<div class="fragment"><div class="line"><span class="comment">// ... create a wait set and a Waitable</span></div>
<div class="line"><span class="comment">// Add the Waitable to the wait set</span></div>
<div class="line">waitable.add_to_wait_set(wait_set);</div>
<div class="line"><span class="comment">// Wait</span></div>
<div class="line">rcl_ret_t wait_ret = rcl_wait(wait_set);</div>
<div class="line"><span class="comment">// ... error handling</span></div>
<div class="line"><span class="comment">// Update the Waitable</span></div>
<div class="line">waitable.update(wait_set);</div>
<div class="line"><span class="comment">// Execute any entities of the Waitable that may be ready</span></div>
<div class="line">std::shared_ptr&lt;void&gt; data = waitable.take_data();</div>
<div class="line">waitable.execute(data);</div>
</div><!-- fragment --> 
<p>Implements <a class="el" href="classrclcpp_1_1Waitable.html#aa4aa39a931c99fb99c1ed1e9a50aaf97">rclcpp::Waitable</a>.</p>

<p>Implemented in <a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcess.html#a0c246e15b891b387c2dd7c98e705f650">rclcpp::experimental::SubscriptionIntraProcess&lt; MessageT, SubscribedType, SubscribedTypeAlloc, SubscribedTypeDeleter, ROSMessageType, Alloc &gt;</a>.</p>

</div>
</div>
<a id="ab69ddb435daba3fe30797ce971766524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69ddb435daba3fe30797ce971766524">&#9670;&nbsp;</a></span>use_take_shared_method()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool rclcpp::experimental::SubscriptionIntraProcessBase::use_take_shared_method </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBuffer.html#a46d04022881f2462324369cf753d4bed">rclcpp::experimental::SubscriptionIntraProcessBuffer&lt; SubscribedType, Alloc, Deleter, ROSMessageType &gt;</a>, and <a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBuffer.html#a46d04022881f2462324369cf753d4bed">rclcpp::experimental::SubscriptionIntraProcessBuffer&lt; SubscribedType, std::allocator&lt; SubscribedType &gt;, std::default_delete&lt; SubscribedType &gt;, SubscribedType &gt;</a>.</p>

</div>
</div>
<a id="ae4834d68b40a4d5700b5b8a4f1a5222c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4834d68b40a4d5700b5b8a4f1a5222c">&#9670;&nbsp;</a></span>get_topic_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rclcpp::experimental::SubscriptionIntraProcessBase::get_topic_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc2fe3f581738cd0d8fe68e5ff43b8d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc2fe3f581738cd0d8fe68e5ff43b8d8">&#9670;&nbsp;</a></span>get_actual_qos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1QoS.html">QoS</a> rclcpp::experimental::SubscriptionIntraProcessBase::get_actual_qos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab823457f413f244c6fe7492b12c7265b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab823457f413f244c6fe7492b12c7265b">&#9670;&nbsp;</a></span>set_on_ready_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::experimental::SubscriptionIntraProcessBase::set_on_ready_callback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(size_t, int)&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a callback to be called when each new message arrives. </p>
<p>The callback receives a size_t which is the number of messages received since the last time this callback was called. Normally this is 1, but can be &gt; 1 if messages were received before any callback was set.</p>
<p>The callback also receives an int identifier argument. This is needed because a <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> may be composed of several distinct entities, such as subscriptions, services, etc. The application should provide a generic callback function that will be then forwarded by the waitable to all of its entities. Before forwarding, a different value for the identifier argument will be bound to the function. This implies that the provided callback can use the identifier to behave differently depending on which entity triggered the waitable to become ready.</p>
<p>Calling it again will clear any previously set callback.</p>
<p>An exception will be thrown if the callback is not callable.</p>
<p>This function is thread-safe.</p>
<p>If you want more information available in the callback, like the subscription or other information, you may use a lambda with captures or std::bind.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>functor to be called when a new message is received. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classrclcpp_1_1Waitable.html#a48eae7264bbc8598ec5ee16a5c2035a4">rclcpp::Waitable</a>.</p>

</div>
</div>
<a id="a1c542a3e38db47bb6ed5c368ebd4d876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c542a3e38db47bb6ed5c368ebd4d876">&#9670;&nbsp;</a></span>clear_on_ready_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::experimental::SubscriptionIntraProcessBase::clear_on_ready_callback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unset the callback registered for new messages, if any. </p>

<p>Reimplemented from <a class="el" href="classrclcpp_1_1Waitable.html#ac81c97b4136b8aaf0a144b1981896eab">rclcpp::Waitable</a>.</p>

</div>
</div>
<a id="af207140da2074cf7c89dcbf6649f53d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af207140da2074cf7c89dcbf6649f53d5">&#9670;&nbsp;</a></span>trigger_guard_condition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::experimental::SubscriptionIntraProcessBase::trigger_guard_condition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBuffer.html#a18700ab938f8c1357bc39a3782797575">rclcpp::experimental::SubscriptionIntraProcessBuffer&lt; SubscribedType, Alloc, Deleter, ROSMessageType &gt;</a>, and <a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBuffer.html#a18700ab938f8c1357bc39a3782797575">rclcpp::experimental::SubscriptionIntraProcessBuffer&lt; SubscribedType, std::allocator&lt; SubscribedType &gt;, std::default_delete&lt; SubscribedType &gt;, SubscribedType &gt;</a>.</p>

</div>
</div>
<a id="a15c287358d0f5e337d86d3ab69fda253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c287358d0f5e337d86d3ab69fda253">&#9670;&nbsp;</a></span>invoke_on_new_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::experimental::SubscriptionIntraProcessBase::invoke_on_new_message </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a94981e43acf10be7681e9849372fa2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94981e43acf10be7681e9849372fa2f9">&#9670;&nbsp;</a></span>callback_mutex_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::recursive_mutex rclcpp::experimental::SubscriptionIntraProcessBase::callback_mutex_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af4def0ee9dc41211c9f7e783435533df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4def0ee9dc41211c9f7e783435533df">&#9670;&nbsp;</a></span>on_new_message_callback_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(size_t)&gt; rclcpp::experimental::SubscriptionIntraProcessBase::on_new_message_callback_ {nullptr}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a718e01845e522641d813d5f0faacb6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718e01845e522641d813d5f0faacb6f6">&#9670;&nbsp;</a></span>unread_count_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t rclcpp::experimental::SubscriptionIntraProcessBase::unread_count_ {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2dd3ebe79fbaf6fb7d846f6b4f0247b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2dd3ebe79fbaf6fb7d846f6b4f0247b">&#9670;&nbsp;</a></span>gc_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1GuardCondition.html">rclcpp::GuardCondition</a> rclcpp::experimental::SubscriptionIntraProcessBase::gc_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/rclcpp/experimental/<a class="el" href="subscription__intra__process__base_8hpp_source.html">subscription_intra_process_base.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
