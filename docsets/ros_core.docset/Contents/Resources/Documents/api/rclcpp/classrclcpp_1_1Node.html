<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rclcpp: rclcpp::Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rclcpp
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C++ ROS Client Library API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerclcpp.html">rclcpp</a></li><li class="navelem"><a class="el" href="classrclcpp_1_1Node.html">Node</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classrclcpp_1_1Node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rclcpp::Node Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> is the single point of entry for creating publishers and subscribers.  
 <a href="classrclcpp_1_1Node.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="node_8hpp_source.html">node.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rclcpp::Node:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1Node__inherit__graph.png" border="0" usemap="#arclcpp_1_1Node_inherit__map" alt="Inheritance graph"/></div>
<map name="arclcpp_1_1Node_inherit__map" id="arclcpp_1_1Node_inherit__map">
<area shape="rect" title="Node is the single point of entry for creating publishers and subscribers." alt="" coords="31,95,134,121"/>
<area shape="rect" title=" " alt="" coords="5,5,160,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for rclcpp::Node:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1Node__coll__graph.png" border="0" usemap="#arclcpp_1_1Node_coll__map" alt="Collaboration graph"/></div>
<map name="arclcpp_1_1Node_coll__map" id="arclcpp_1_1Node_coll__map">
<area shape="rect" title="Node is the single point of entry for creating publishers and subscribers." alt="" coords="31,95,134,121"/>
<area shape="rect" title=" " alt="" coords="5,5,160,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aac7e1fe50bc2683380cd9a635ac51edb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#aac7e1fe50bc2683380cd9a635ac51edb">OnSetParametersCallbackHandle</a> = <a class="el" href="structrclcpp_1_1node__interfaces_1_1OnSetParametersCallbackHandle.html">rclcpp::node_interfaces::OnSetParametersCallbackHandle</a></td></tr>
<tr class="separator:aac7e1fe50bc2683380cd9a635ac51edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab403fecdb5ec2eb9f88e3eb7ae6f6d0c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#ab403fecdb5ec2eb9f88e3eb7ae6f6d0c">OnParametersSetCallbackType</a> = <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeParametersInterface.html#a7143766bc4249673edb6244820fc5a94">rclcpp::node_interfaces::NodeParametersInterface::OnParametersSetCallbackType</a></td></tr>
<tr class="separator:ab403fecdb5ec2eb9f88e3eb7ae6f6d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abaa409bd2dc2cc2437fd9e47378cc5af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#abaa409bd2dc2cc2437fd9e47378cc5af">Node</a> (const std::string &amp;node_name, const <a class="el" href="classrclcpp_1_1NodeOptions.html">NodeOptions</a> &amp;options=<a class="el" href="classrclcpp_1_1NodeOptions.html">NodeOptions</a>())</td></tr>
<tr class="memdesc:abaa409bd2dc2cc2437fd9e47378cc5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new node with the specified name.  <a href="classrclcpp_1_1Node.html#abaa409bd2dc2cc2437fd9e47378cc5af">More...</a><br /></td></tr>
<tr class="separator:abaa409bd2dc2cc2437fd9e47378cc5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f5f45604217b3dc583dac7ab3b66a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a83f5f45604217b3dc583dac7ab3b66a8">Node</a> (const std::string &amp;node_name, const std::string &amp;namespace_, const <a class="el" href="classrclcpp_1_1NodeOptions.html">NodeOptions</a> &amp;options=<a class="el" href="classrclcpp_1_1NodeOptions.html">NodeOptions</a>())</td></tr>
<tr class="memdesc:a83f5f45604217b3dc583dac7ab3b66a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new node with the specified name.  <a href="classrclcpp_1_1Node.html#a83f5f45604217b3dc583dac7ab3b66a8">More...</a><br /></td></tr>
<tr class="separator:a83f5f45604217b3dc583dac7ab3b66a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63584993927b11869d15a34af7e64937"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a63584993927b11869d15a34af7e64937">~Node</a> ()</td></tr>
<tr class="separator:a63584993927b11869d15a34af7e64937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e162104495b21f50c1e9aa11460fb93"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a1e162104495b21f50c1e9aa11460fb93">get_name</a> () const</td></tr>
<tr class="memdesc:a1e162104495b21f50c1e9aa11460fb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the node.  <a href="classrclcpp_1_1Node.html#a1e162104495b21f50c1e9aa11460fb93">More...</a><br /></td></tr>
<tr class="separator:a1e162104495b21f50c1e9aa11460fb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be04e55e2934e05df992b188d9dce6d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a7be04e55e2934e05df992b188d9dce6d">get_namespace</a> () const</td></tr>
<tr class="memdesc:a7be04e55e2934e05df992b188d9dce6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the namespace of the node.  <a href="classrclcpp_1_1Node.html#a7be04e55e2934e05df992b188d9dce6d">More...</a><br /></td></tr>
<tr class="separator:a7be04e55e2934e05df992b188d9dce6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f81aa79665cd9d16a591bddf762747"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a57f81aa79665cd9d16a591bddf762747">get_fully_qualified_name</a> () const</td></tr>
<tr class="memdesc:a57f81aa79665cd9d16a591bddf762747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the fully-qualified name of the node.  <a href="classrclcpp_1_1Node.html#a57f81aa79665cd9d16a591bddf762747">More...</a><br /></td></tr>
<tr class="separator:a57f81aa79665cd9d16a591bddf762747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884ebededa2125cb8316998852ca3fc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1Logger.html">rclcpp::Logger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a884ebededa2125cb8316998852ca3fc5">get_logger</a> () const</td></tr>
<tr class="memdesc:a884ebededa2125cb8316998852ca3fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the logger of the node.  <a href="classrclcpp_1_1Node.html#a884ebededa2125cb8316998852ca3fc5">More...</a><br /></td></tr>
<tr class="separator:a884ebededa2125cb8316998852ca3fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1836b0fb28e1adc4b4e844f862552639"><td class="memItemLeft" align="right" valign="top">rclcpp::CallbackGroup::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a1836b0fb28e1adc4b4e844f862552639">create_callback_group</a> (<a class="el" href="namespacerclcpp.html#a0027d5804ef28f0b6fea8eea4195c44a">rclcpp::CallbackGroupType</a> group_type, bool automatically_add_to_executor_with_node=true)</td></tr>
<tr class="memdesc:a1836b0fb28e1adc4b4e844f862552639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a callback group.  <a href="classrclcpp_1_1Node.html#a1836b0fb28e1adc4b4e844f862552639">More...</a><br /></td></tr>
<tr class="separator:a1836b0fb28e1adc4b4e844f862552639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f396915654cc774ba0d76202db989d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#ac3f396915654cc774ba0d76202db989d">for_each_callback_group</a> (const <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeBaseInterface.html#a0999fa38e0674245d3b41b742655e811">node_interfaces::NodeBaseInterface::CallbackGroupFunction</a> &amp;func)</td></tr>
<tr class="memdesc:ac3f396915654cc774ba0d76202db989d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over the callback groups in the node, calling the given function on each valid one.  <a href="classrclcpp_1_1Node.html#ac3f396915654cc774ba0d76202db989d">More...</a><br /></td></tr>
<tr class="separator:ac3f396915654cc774ba0d76202db989d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1dfc9d04d67ab93353e04a7df72bc9a"><td class="memTemplParams" colspan="2">template&lt;typename MessageT , typename AllocatorT  = std::allocator&lt;void&gt;, typename PublisherT  = rclcpp::Publisher&lt;MessageT, AllocatorT&gt;&gt; </td></tr>
<tr class="memitem:ad1dfc9d04d67ab93353e04a7df72bc9a"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; PublisherT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#ad1dfc9d04d67ab93353e04a7df72bc9a">create_publisher</a> (const std::string &amp;topic_name, const <a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> &amp;qos, const <a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">PublisherOptionsWithAllocator</a>&lt; AllocatorT &gt; &amp;options=<a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">PublisherOptionsWithAllocator</a>&lt; AllocatorT &gt;())</td></tr>
<tr class="memdesc:ad1dfc9d04d67ab93353e04a7df72bc9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a <a class="el" href="classrclcpp_1_1Publisher.html" title="A publisher publishes messages of any type to a topic.">Publisher</a>.  <a href="classrclcpp_1_1Node.html#ad1dfc9d04d67ab93353e04a7df72bc9a">More...</a><br /></td></tr>
<tr class="separator:ad1dfc9d04d67ab93353e04a7df72bc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6f1370b4f676c843272d4b6b41b46d"><td class="memTemplParams" colspan="2">template&lt;typename MessageT , typename CallbackT , typename AllocatorT  = std::allocator&lt;void&gt;, typename SubscriptionT  = rclcpp::Subscription&lt;MessageT, AllocatorT&gt;, typename MessageMemoryStrategyT  = typename SubscriptionT::MessageMemoryStrategyType&gt; </td></tr>
<tr class="memitem:acb6f1370b4f676c843272d4b6b41b46d"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; SubscriptionT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#acb6f1370b4f676c843272d4b6b41b46d">create_subscription</a> (const std::string &amp;topic_name, const <a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> &amp;qos, CallbackT &amp;&amp;callback, const <a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">SubscriptionOptionsWithAllocator</a>&lt; AllocatorT &gt; &amp;options=<a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">SubscriptionOptionsWithAllocator</a>&lt; AllocatorT &gt;(), typename MessageMemoryStrategyT::SharedPtr msg_mem_strat=(MessageMemoryStrategyT::create_default()))</td></tr>
<tr class="memdesc:acb6f1370b4f676c843272d4b6b41b46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a <a class="el" href="classrclcpp_1_1Subscription.html" title="Subscription implementation, templated on the type of message this subscription receives.">Subscription</a>.  <a href="classrclcpp_1_1Node.html#acb6f1370b4f676c843272d4b6b41b46d">More...</a><br /></td></tr>
<tr class="separator:acb6f1370b4f676c843272d4b6b41b46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27d1f6d1c5ff633b1b42ab6f77479c5"><td class="memTemplParams" colspan="2">template&lt;typename DurationRepT  = int64_t, typename DurationT  = std::milli, typename CallbackT &gt; </td></tr>
<tr class="memitem:ad27d1f6d1c5ff633b1b42ab6f77479c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1WallTimer.html">rclcpp::WallTimer</a>&lt; CallbackT &gt;::SharedPtr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#ad27d1f6d1c5ff633b1b42ab6f77479c5">create_wall_timer</a> (std::chrono::duration&lt; DurationRepT, DurationT &gt; period, CallbackT callback, rclcpp::CallbackGroup::SharedPtr group=nullptr)</td></tr>
<tr class="memdesc:ad27d1f6d1c5ff633b1b42ab6f77479c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a timer.  <a href="classrclcpp_1_1Node.html#ad27d1f6d1c5ff633b1b42ab6f77479c5">More...</a><br /></td></tr>
<tr class="separator:ad27d1f6d1c5ff633b1b42ab6f77479c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed42f345ae1de3a1979d5a8076127199"><td class="memTemplParams" colspan="2">template&lt;typename ServiceT &gt; </td></tr>
<tr class="memitem:aed42f345ae1de3a1979d5a8076127199"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1Client.html">rclcpp::Client</a>&lt; ServiceT &gt;::SharedPtr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#aed42f345ae1de3a1979d5a8076127199">create_client</a> (const std::string &amp;service_name, const rmw_qos_profile_t &amp;qos_profile=rmw_qos_profile_services_default, rclcpp::CallbackGroup::SharedPtr group=nullptr)</td></tr>
<tr class="memdesc:aed42f345ae1de3a1979d5a8076127199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a <a class="el" href="classrclcpp_1_1Client.html">Client</a>.  <a href="classrclcpp_1_1Node.html#aed42f345ae1de3a1979d5a8076127199">More...</a><br /></td></tr>
<tr class="separator:aed42f345ae1de3a1979d5a8076127199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d1f389ba5e4a57559203d5d9e77ec9"><td class="memTemplParams" colspan="2">template&lt;typename ServiceT , typename CallbackT &gt; </td></tr>
<tr class="memitem:a20d1f389ba5e4a57559203d5d9e77ec9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1Service.html">rclcpp::Service</a>&lt; ServiceT &gt;::SharedPtr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a20d1f389ba5e4a57559203d5d9e77ec9">create_service</a> (const std::string &amp;service_name, CallbackT &amp;&amp;callback, const rmw_qos_profile_t &amp;qos_profile=rmw_qos_profile_services_default, rclcpp::CallbackGroup::SharedPtr group=nullptr)</td></tr>
<tr class="memdesc:a20d1f389ba5e4a57559203d5d9e77ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a <a class="el" href="classrclcpp_1_1Service.html">Service</a>.  <a href="classrclcpp_1_1Node.html#a20d1f389ba5e4a57559203d5d9e77ec9">More...</a><br /></td></tr>
<tr class="separator:a20d1f389ba5e4a57559203d5d9e77ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73e99cfe2655b1bdb1d6d34cc9775aa"><td class="memTemplParams" colspan="2">template&lt;typename AllocatorT  = std::allocator&lt;void&gt;&gt; </td></tr>
<tr class="memitem:af73e99cfe2655b1bdb1d6d34cc9775aa"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1GenericPublisher.html">rclcpp::GenericPublisher</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#af73e99cfe2655b1bdb1d6d34cc9775aa">create_generic_publisher</a> (const std::string &amp;topic_name, const std::string &amp;topic_type, const <a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> &amp;qos, const <a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">rclcpp::PublisherOptionsWithAllocator</a>&lt; AllocatorT &gt; &amp;options=(<a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">rclcpp::PublisherOptionsWithAllocator</a>&lt; AllocatorT &gt;()))</td></tr>
<tr class="memdesc:af73e99cfe2655b1bdb1d6d34cc9775aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a <a class="el" href="classrclcpp_1_1GenericPublisher.html" title="Publisher for serialized messages whose type is not known at compile time.">GenericPublisher</a>.  <a href="classrclcpp_1_1Node.html#af73e99cfe2655b1bdb1d6d34cc9775aa">More...</a><br /></td></tr>
<tr class="separator:af73e99cfe2655b1bdb1d6d34cc9775aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fce75ef652d8c5db159204afa5dd08"><td class="memTemplParams" colspan="2">template&lt;typename AllocatorT  = std::allocator&lt;void&gt;&gt; </td></tr>
<tr class="memitem:a54fce75ef652d8c5db159204afa5dd08"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1GenericSubscription.html">rclcpp::GenericSubscription</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a54fce75ef652d8c5db159204afa5dd08">create_generic_subscription</a> (const std::string &amp;topic_name, const std::string &amp;topic_type, const <a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> &amp;qos, std::function&lt; void(std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1SerializedMessage.html">rclcpp::SerializedMessage</a> &gt;)&gt; callback, const <a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">rclcpp::SubscriptionOptionsWithAllocator</a>&lt; AllocatorT &gt; &amp;options=(<a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">rclcpp::SubscriptionOptionsWithAllocator</a>&lt; AllocatorT &gt;()))</td></tr>
<tr class="memdesc:a54fce75ef652d8c5db159204afa5dd08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a <a class="el" href="classrclcpp_1_1GenericSubscription.html" title="Subscription for serialized messages whose type is not known at compile time.">GenericSubscription</a>.  <a href="classrclcpp_1_1Node.html#a54fce75ef652d8c5db159204afa5dd08">More...</a><br /></td></tr>
<tr class="separator:a54fce75ef652d8c5db159204afa5dd08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2297309b4c1a2e583801fa8a6ef955"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classrclcpp_1_1ParameterValue.html">rclcpp::ParameterValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a2f2297309b4c1a2e583801fa8a6ef955">declare_parameter</a> (const std::string &amp;name, const <a class="el" href="classrclcpp_1_1ParameterValue.html">rclcpp::ParameterValue</a> &amp;default_value, const rcl_interfaces::msg::ParameterDescriptor &amp;parameter_descriptor=rcl_interfaces::msg::ParameterDescriptor(), bool ignore_override=false)</td></tr>
<tr class="memdesc:a2f2297309b4c1a2e583801fa8a6ef955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare and initialize a parameter, return the effective value.  <a href="classrclcpp_1_1Node.html#a2f2297309b4c1a2e583801fa8a6ef955">More...</a><br /></td></tr>
<tr class="separator:a2f2297309b4c1a2e583801fa8a6ef955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333cba98bb365cfa98614b993f522d38"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classrclcpp_1_1ParameterValue.html">rclcpp::ParameterValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a333cba98bb365cfa98614b993f522d38">declare_parameter</a> (const std::string &amp;name, <a class="el" href="namespacerclcpp.html#a1b307a4b7368b68f325812cd2aeb8784">rclcpp::ParameterType</a> type, const rcl_interfaces::msg::ParameterDescriptor &amp;parameter_descriptor=rcl_interfaces::msg::ParameterDescriptor{}, bool ignore_override=false)</td></tr>
<tr class="memdesc:a333cba98bb365cfa98614b993f522d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare and initialize a parameter, return the effective value.  <a href="classrclcpp_1_1Node.html#a333cba98bb365cfa98614b993f522d38">More...</a><br /></td></tr>
<tr class="separator:a333cba98bb365cfa98614b993f522d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1ca8c48e28bd1f3e5fda2ab3116efd"><td class="memTemplParams" colspan="2">template&lt;typename ParameterT &gt; </td></tr>
<tr class="memitem:a5b1ca8c48e28bd1f3e5fda2ab3116efd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a5b1ca8c48e28bd1f3e5fda2ab3116efd">declare_parameter</a> (const std::string &amp;name, const ParameterT &amp;default_value, const rcl_interfaces::msg::ParameterDescriptor &amp;parameter_descriptor=rcl_interfaces::msg::ParameterDescriptor(), bool ignore_override=false)</td></tr>
<tr class="memdesc:a5b1ca8c48e28bd1f3e5fda2ab3116efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare and initialize a parameter with a type.  <a href="classrclcpp_1_1Node.html#a5b1ca8c48e28bd1f3e5fda2ab3116efd">More...</a><br /></td></tr>
<tr class="separator:a5b1ca8c48e28bd1f3e5fda2ab3116efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12051ad340f2212370a0829e55674ad"><td class="memTemplParams" colspan="2">template&lt;typename ParameterT &gt; </td></tr>
<tr class="memitem:ac12051ad340f2212370a0829e55674ad"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#ac12051ad340f2212370a0829e55674ad">declare_parameter</a> (const std::string &amp;name, const rcl_interfaces::msg::ParameterDescriptor &amp;parameter_descriptor=rcl_interfaces::msg::ParameterDescriptor(), bool ignore_override=false)</td></tr>
<tr class="memdesc:ac12051ad340f2212370a0829e55674ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare and initialize a parameter with a type.  <a href="classrclcpp_1_1Node.html#ac12051ad340f2212370a0829e55674ad">More...</a><br /></td></tr>
<tr class="separator:ac12051ad340f2212370a0829e55674ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebda51ed6fa4ce8f2cddc9f77e9674e"><td class="memTemplParams" colspan="2">template&lt;typename ParameterT &gt; </td></tr>
<tr class="memitem:a5ebda51ed6fa4ce8f2cddc9f77e9674e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; ParameterT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a5ebda51ed6fa4ce8f2cddc9f77e9674e">declare_parameters</a> (const std::string &amp;namespace_, const std::map&lt; std::string, ParameterT &gt; &amp;parameters, bool ignore_overrides=false)</td></tr>
<tr class="memdesc:a5ebda51ed6fa4ce8f2cddc9f77e9674e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare and initialize several parameters with the same namespace and type.  <a href="classrclcpp_1_1Node.html#a5ebda51ed6fa4ce8f2cddc9f77e9674e">More...</a><br /></td></tr>
<tr class="separator:a5ebda51ed6fa4ce8f2cddc9f77e9674e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3300ad15cdf9e22ee7bfc844b9a30c"><td class="memTemplParams" colspan="2">template&lt;typename ParameterT &gt; </td></tr>
<tr class="memitem:a9b3300ad15cdf9e22ee7bfc844b9a30c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; ParameterT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a9b3300ad15cdf9e22ee7bfc844b9a30c">declare_parameters</a> (const std::string &amp;namespace_, const std::map&lt; std::string, std::pair&lt; ParameterT, rcl_interfaces::msg::ParameterDescriptor &gt; &gt; &amp;parameters, bool ignore_overrides=false)</td></tr>
<tr class="memdesc:a9b3300ad15cdf9e22ee7bfc844b9a30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare and initialize several parameters with the same namespace and type.  <a href="classrclcpp_1_1Node.html#a9b3300ad15cdf9e22ee7bfc844b9a30c">More...</a><br /></td></tr>
<tr class="separator:a9b3300ad15cdf9e22ee7bfc844b9a30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c525bd10070bd025bd570e98afd0d7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a2c525bd10070bd025bd570e98afd0d7d">undeclare_parameter</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a2c525bd10070bd025bd570e98afd0d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undeclare a previously declared parameter.  <a href="classrclcpp_1_1Node.html#a2c525bd10070bd025bd570e98afd0d7d">More...</a><br /></td></tr>
<tr class="separator:a2c525bd10070bd025bd570e98afd0d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb818bb5c848c5a980ddbe745517b7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#aabb818bb5c848c5a980ddbe745517b7c">has_parameter</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:aabb818bb5c848c5a980ddbe745517b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if a given parameter is declared.  <a href="classrclcpp_1_1Node.html#aabb818bb5c848c5a980ddbe745517b7c">More...</a><br /></td></tr>
<tr class="separator:aabb818bb5c848c5a980ddbe745517b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c753036cd5cbdf0168ca3b39a193223"><td class="memItemLeft" align="right" valign="top">rcl_interfaces::msg::SetParametersResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a8c753036cd5cbdf0168ca3b39a193223">set_parameter</a> (const <a class="el" href="classrclcpp_1_1Parameter.html">rclcpp::Parameter</a> &amp;parameter)</td></tr>
<tr class="memdesc:a8c753036cd5cbdf0168ca3b39a193223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a single parameter.  <a href="classrclcpp_1_1Node.html#a8c753036cd5cbdf0168ca3b39a193223">More...</a><br /></td></tr>
<tr class="separator:a8c753036cd5cbdf0168ca3b39a193223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8af4dc449c7130ccc396814b86c14d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; rcl_interfaces::msg::SetParametersResult &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a7d8af4dc449c7130ccc396814b86c14d">set_parameters</a> (const std::vector&lt; <a class="el" href="classrclcpp_1_1Parameter.html">rclcpp::Parameter</a> &gt; &amp;parameters)</td></tr>
<tr class="memdesc:a7d8af4dc449c7130ccc396814b86c14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set one or more parameters, one at a time.  <a href="classrclcpp_1_1Node.html#a7d8af4dc449c7130ccc396814b86c14d">More...</a><br /></td></tr>
<tr class="separator:a7d8af4dc449c7130ccc396814b86c14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6d4b50c0fab975859590c82931e9ae"><td class="memItemLeft" align="right" valign="top">rcl_interfaces::msg::SetParametersResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a0a6d4b50c0fab975859590c82931e9ae">set_parameters_atomically</a> (const std::vector&lt; <a class="el" href="classrclcpp_1_1Parameter.html">rclcpp::Parameter</a> &gt; &amp;parameters)</td></tr>
<tr class="memdesc:a0a6d4b50c0fab975859590c82931e9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set one or more parameters, all at once.  <a href="classrclcpp_1_1Node.html#a0a6d4b50c0fab975859590c82931e9ae">More...</a><br /></td></tr>
<tr class="separator:a0a6d4b50c0fab975859590c82931e9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf1077fba623d72fe1b49805f6c0a5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1Parameter.html">rclcpp::Parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a0bf1077fba623d72fe1b49805f6c0a5a">get_parameter</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a0bf1077fba623d72fe1b49805f6c0a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the parameter by the given name.  <a href="classrclcpp_1_1Node.html#a0bf1077fba623d72fe1b49805f6c0a5a">More...</a><br /></td></tr>
<tr class="separator:a0bf1077fba623d72fe1b49805f6c0a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe80d17fb6789dec1ecf74c4d135aad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a1fe80d17fb6789dec1ecf74c4d135aad">get_parameter</a> (const std::string &amp;name, <a class="el" href="classrclcpp_1_1Parameter.html">rclcpp::Parameter</a> &amp;parameter) const</td></tr>
<tr class="memdesc:a1fe80d17fb6789dec1ecf74c4d135aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a parameter by the given name, and return true if it was set.  <a href="classrclcpp_1_1Node.html#a1fe80d17fb6789dec1ecf74c4d135aad">More...</a><br /></td></tr>
<tr class="separator:a1fe80d17fb6789dec1ecf74c4d135aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3158e5520c58531ae4d85a2e98cdf210"><td class="memTemplParams" colspan="2">template&lt;typename ParameterT &gt; </td></tr>
<tr class="memitem:a3158e5520c58531ae4d85a2e98cdf210"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a3158e5520c58531ae4d85a2e98cdf210">get_parameter</a> (const std::string &amp;name, ParameterT &amp;parameter) const</td></tr>
<tr class="memdesc:a3158e5520c58531ae4d85a2e98cdf210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a parameter by the given name, and return true if it was set.  <a href="classrclcpp_1_1Node.html#a3158e5520c58531ae4d85a2e98cdf210">More...</a><br /></td></tr>
<tr class="separator:a3158e5520c58531ae4d85a2e98cdf210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bba086f9d74de0f1f10ffb8deb4c11a"><td class="memTemplParams" colspan="2">template&lt;typename ParameterT &gt; </td></tr>
<tr class="memitem:a4bba086f9d74de0f1f10ffb8deb4c11a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a4bba086f9d74de0f1f10ffb8deb4c11a">get_parameter_or</a> (const std::string &amp;name, ParameterT &amp;parameter, const ParameterT &amp;alternative_value) const</td></tr>
<tr class="memdesc:a4bba086f9d74de0f1f10ffb8deb4c11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parameter value, or the "alternative_value" if not set, and assign it to "parameter".  <a href="classrclcpp_1_1Node.html#a4bba086f9d74de0f1f10ffb8deb4c11a">More...</a><br /></td></tr>
<tr class="separator:a4bba086f9d74de0f1f10ffb8deb4c11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c042e282c9a3e169f53f27542962b9"><td class="memTemplParams" colspan="2">template&lt;typename ParameterT &gt; </td></tr>
<tr class="memitem:a13c042e282c9a3e169f53f27542962b9"><td class="memTemplItemLeft" align="right" valign="top">ParameterT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a13c042e282c9a3e169f53f27542962b9">get_parameter_or</a> (const std::string &amp;name, const ParameterT &amp;alternative_value) const</td></tr>
<tr class="memdesc:a13c042e282c9a3e169f53f27542962b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the parameter value, or the "alternative_value" if not set.  <a href="classrclcpp_1_1Node.html#a13c042e282c9a3e169f53f27542962b9">More...</a><br /></td></tr>
<tr class="separator:a13c042e282c9a3e169f53f27542962b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25890d01a2cd47ce99af887f556c529b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classrclcpp_1_1Parameter.html">rclcpp::Parameter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a25890d01a2cd47ce99af887f556c529b">get_parameters</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:a25890d01a2cd47ce99af887f556c529b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the parameters by the given parameter names.  <a href="classrclcpp_1_1Node.html#a25890d01a2cd47ce99af887f556c529b">More...</a><br /></td></tr>
<tr class="separator:a25890d01a2cd47ce99af887f556c529b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ab12777100f65bd09163814dbbf486"><td class="memTemplParams" colspan="2">template&lt;typename ParameterT &gt; </td></tr>
<tr class="memitem:ae5ab12777100f65bd09163814dbbf486"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#ae5ab12777100f65bd09163814dbbf486">get_parameters</a> (const std::string &amp;prefix, std::map&lt; std::string, ParameterT &gt; &amp;values) const</td></tr>
<tr class="memdesc:ae5ab12777100f65bd09163814dbbf486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parameter values for all parameters that have a given prefix.  <a href="classrclcpp_1_1Node.html#ae5ab12777100f65bd09163814dbbf486">More...</a><br /></td></tr>
<tr class="separator:ae5ab12777100f65bd09163814dbbf486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39de814a51b5792e86cd9b315e631fe0"><td class="memItemLeft" align="right" valign="top">rcl_interfaces::msg::ParameterDescriptor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a39de814a51b5792e86cd9b315e631fe0">describe_parameter</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a39de814a51b5792e86cd9b315e631fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the parameter descriptor for the given parameter name.  <a href="classrclcpp_1_1Node.html#a39de814a51b5792e86cd9b315e631fe0">More...</a><br /></td></tr>
<tr class="separator:a39de814a51b5792e86cd9b315e631fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfb47c0983e14482c39159b274f6308"><td class="memItemLeft" align="right" valign="top">std::vector&lt; rcl_interfaces::msg::ParameterDescriptor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#adbfb47c0983e14482c39159b274f6308">describe_parameters</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:adbfb47c0983e14482c39159b274f6308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of parameter descriptors, one for each of the given names.  <a href="classrclcpp_1_1Node.html#adbfb47c0983e14482c39159b274f6308">More...</a><br /></td></tr>
<tr class="separator:adbfb47c0983e14482c39159b274f6308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9855812e7873bd35b28afa420d4242b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#af9855812e7873bd35b28afa420d4242b">get_parameter_types</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:af9855812e7873bd35b28afa420d4242b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of parameter types, one for each of the given names.  <a href="classrclcpp_1_1Node.html#af9855812e7873bd35b28afa420d4242b">More...</a><br /></td></tr>
<tr class="separator:af9855812e7873bd35b28afa420d4242b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37aa95886a706c174db77c2b160f6d7d"><td class="memItemLeft" align="right" valign="top">rcl_interfaces::msg::ListParametersResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a37aa95886a706c174db77c2b160f6d7d">list_parameters</a> (const std::vector&lt; std::string &gt; &amp;prefixes, uint64_t depth) const</td></tr>
<tr class="memdesc:a37aa95886a706c174db77c2b160f6d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of parameters with any of the given prefixes, up to the given depth.  <a href="classrclcpp_1_1Node.html#a37aa95886a706c174db77c2b160f6d7d">More...</a><br /></td></tr>
<tr class="separator:a37aa95886a706c174db77c2b160f6d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3ad2ca5c56eb54af0227f04e943679"><td class="memItemLeft" align="right" valign="top">OnSetParametersCallbackHandle::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a0c3ad2ca5c56eb54af0227f04e943679">add_on_set_parameters_callback</a> (<a class="el" href="classrclcpp_1_1Node.html#ab403fecdb5ec2eb9f88e3eb7ae6f6d0c">OnParametersSetCallbackType</a> callback)</td></tr>
<tr class="memdesc:a0c3ad2ca5c56eb54af0227f04e943679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a callback for when parameters are being set.  <a href="classrclcpp_1_1Node.html#a0c3ad2ca5c56eb54af0227f04e943679">More...</a><br /></td></tr>
<tr class="separator:a0c3ad2ca5c56eb54af0227f04e943679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d4f7fa0ef760941b6a78f42cccb7e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a15d4f7fa0ef760941b6a78f42cccb7e0">remove_on_set_parameters_callback</a> (const <a class="el" href="classrclcpp_1_1Node.html#aac7e1fe50bc2683380cd9a635ac51edb">OnSetParametersCallbackHandle</a> *const handler)</td></tr>
<tr class="memdesc:a15d4f7fa0ef760941b6a78f42cccb7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a callback registered with <code>add_on_set_parameters_callback</code>.  <a href="classrclcpp_1_1Node.html#a15d4f7fa0ef760941b6a78f42cccb7e0">More...</a><br /></td></tr>
<tr class="separator:a15d4f7fa0ef760941b6a78f42cccb7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4302d8e28f17078cbc3b6db93c97ba"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a9e4302d8e28f17078cbc3b6db93c97ba">get_node_names</a> () const</td></tr>
<tr class="memdesc:a9e4302d8e28f17078cbc3b6db93c97ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the fully-qualified names of all available nodes.  <a href="classrclcpp_1_1Node.html#a9e4302d8e28f17078cbc3b6db93c97ba">More...</a><br /></td></tr>
<tr class="separator:a9e4302d8e28f17078cbc3b6db93c97ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64ee81d61071100f222b819eab3e311"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#ab64ee81d61071100f222b819eab3e311">get_topic_names_and_types</a> () const</td></tr>
<tr class="memdesc:ab64ee81d61071100f222b819eab3e311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a map of existing topic names to list of topic types.  <a href="classrclcpp_1_1Node.html#ab64ee81d61071100f222b819eab3e311">More...</a><br /></td></tr>
<tr class="separator:ab64ee81d61071100f222b819eab3e311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d400bbd606a936a556b747f519eab38"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a0d400bbd606a936a556b747f519eab38">get_service_names_and_types</a> () const</td></tr>
<tr class="memdesc:a0d400bbd606a936a556b747f519eab38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a map of existing service names to list of service types.  <a href="classrclcpp_1_1Node.html#a0d400bbd606a936a556b747f519eab38">More...</a><br /></td></tr>
<tr class="separator:a0d400bbd606a936a556b747f519eab38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3df8a7d8b174f8049dfd2766f4b2eb9"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#aa3df8a7d8b174f8049dfd2766f4b2eb9">get_service_names_and_types_by_node</a> (const std::string &amp;node_name, const std::string &amp;namespace_) const</td></tr>
<tr class="memdesc:aa3df8a7d8b174f8049dfd2766f4b2eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a map of existing service names to list of service types for a specific node.  <a href="classrclcpp_1_1Node.html#aa3df8a7d8b174f8049dfd2766f4b2eb9">More...</a><br /></td></tr>
<tr class="separator:aa3df8a7d8b174f8049dfd2766f4b2eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8792429fa0ee5c5d7f9eca537cf4cff0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a8792429fa0ee5c5d7f9eca537cf4cff0">count_publishers</a> (const std::string &amp;topic_name) const</td></tr>
<tr class="memdesc:a8792429fa0ee5c5d7f9eca537cf4cff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of publishers created for a given topic.  <a href="classrclcpp_1_1Node.html#a8792429fa0ee5c5d7f9eca537cf4cff0">More...</a><br /></td></tr>
<tr class="separator:a8792429fa0ee5c5d7f9eca537cf4cff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa2ed22450d2f3300ea5b879acd73b8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a7aa2ed22450d2f3300ea5b879acd73b8">count_subscribers</a> (const std::string &amp;topic_name) const</td></tr>
<tr class="memdesc:a7aa2ed22450d2f3300ea5b879acd73b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of subscribers created for a given topic.  <a href="classrclcpp_1_1Node.html#a7aa2ed22450d2f3300ea5b879acd73b8">More...</a><br /></td></tr>
<tr class="separator:a7aa2ed22450d2f3300ea5b879acd73b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08220daf1d66596012e858d19efd1212"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classrclcpp_1_1TopicEndpointInfo.html">rclcpp::TopicEndpointInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a08220daf1d66596012e858d19efd1212">get_publishers_info_by_topic</a> (const std::string &amp;topic_name, bool no_mangle=false) const</td></tr>
<tr class="memdesc:a08220daf1d66596012e858d19efd1212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the topic endpoint information about publishers on a given topic.  <a href="classrclcpp_1_1Node.html#a08220daf1d66596012e858d19efd1212">More...</a><br /></td></tr>
<tr class="separator:a08220daf1d66596012e858d19efd1212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba993c401901433b3c8647ef716c7e4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classrclcpp_1_1TopicEndpointInfo.html">rclcpp::TopicEndpointInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#afba993c401901433b3c8647ef716c7e4">get_subscriptions_info_by_topic</a> (const std::string &amp;topic_name, bool no_mangle=false) const</td></tr>
<tr class="memdesc:afba993c401901433b3c8647ef716c7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the topic endpoint information about subscriptions on a given topic.  <a href="classrclcpp_1_1Node.html#afba993c401901433b3c8647ef716c7e4">More...</a><br /></td></tr>
<tr class="separator:afba993c401901433b3c8647ef716c7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5851844ecb1794503b8fc0f9f5c898"><td class="memItemLeft" align="right" valign="top">rclcpp::Event::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a9e5851844ecb1794503b8fc0f9f5c898">get_graph_event</a> ()</td></tr>
<tr class="memdesc:a9e5851844ecb1794503b8fc0f9f5c898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a graph event, which will be set anytime a graph change occurs.  <a href="classrclcpp_1_1Node.html#a9e5851844ecb1794503b8fc0f9f5c898">More...</a><br /></td></tr>
<tr class="separator:a9e5851844ecb1794503b8fc0f9f5c898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72e2c59951c08c515fd597bfc9e8cfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#ab72e2c59951c08c515fd597bfc9e8cfd">wait_for_graph_change</a> (rclcpp::Event::SharedPtr event, std::chrono::nanoseconds timeout)</td></tr>
<tr class="memdesc:ab72e2c59951c08c515fd597bfc9e8cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a graph event to occur by waiting on an <a class="el" href="classrclcpp_1_1Event.html">Event</a> to become set.  <a href="classrclcpp_1_1Node.html#ab72e2c59951c08c515fd597bfc9e8cfd">More...</a><br /></td></tr>
<tr class="separator:ab72e2c59951c08c515fd597bfc9e8cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0332887ae90caed727e5025cb62195"><td class="memItemLeft" align="right" valign="top">rclcpp::Clock::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#aec0332887ae90caed727e5025cb62195">get_clock</a> ()</td></tr>
<tr class="memdesc:aec0332887ae90caed727e5025cb62195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a clock as a non-const shared pointer which is managed by the node.  <a href="classrclcpp_1_1Node.html#aec0332887ae90caed727e5025cb62195">More...</a><br /></td></tr>
<tr class="separator:aec0332887ae90caed727e5025cb62195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c725f0bb2e36943ca5c0255ad0bc0cf"><td class="memItemLeft" align="right" valign="top">rclcpp::Clock::ConstSharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a2c725f0bb2e36943ca5c0255ad0bc0cf">get_clock</a> () const</td></tr>
<tr class="memdesc:a2c725f0bb2e36943ca5c0255ad0bc0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a clock as a const shared pointer which is managed by the node.  <a href="classrclcpp_1_1Node.html#a2c725f0bb2e36943ca5c0255ad0bc0cf">More...</a><br /></td></tr>
<tr class="separator:a2c725f0bb2e36943ca5c0255ad0bc0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db9cec1af19a994b3f1dad2059d2707"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1Time.html">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a1db9cec1af19a994b3f1dad2059d2707">now</a> () const</td></tr>
<tr class="memdesc:a1db9cec1af19a994b3f1dad2059d2707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current time from the time source specified by clock_type.  <a href="classrclcpp_1_1Node.html#a1db9cec1af19a994b3f1dad2059d2707">More...</a><br /></td></tr>
<tr class="separator:a1db9cec1af19a994b3f1dad2059d2707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e5b136ef0a29853e01d5cecb8e4690"><td class="memItemLeft" align="right" valign="top">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a37e5b136ef0a29853e01d5cecb8e4690">get_node_base_interface</a> ()</td></tr>
<tr class="memdesc:a37e5b136ef0a29853e01d5cecb8e4690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a>'s internal NodeBaseInterface implementation.  <a href="classrclcpp_1_1Node.html#a37e5b136ef0a29853e01d5cecb8e4690">More...</a><br /></td></tr>
<tr class="separator:a37e5b136ef0a29853e01d5cecb8e4690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5495b9faae261feed33d8d8828840709"><td class="memItemLeft" align="right" valign="top">rclcpp::node_interfaces::NodeClockInterface::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a5495b9faae261feed33d8d8828840709">get_node_clock_interface</a> ()</td></tr>
<tr class="memdesc:a5495b9faae261feed33d8d8828840709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a>'s internal NodeClockInterface implementation.  <a href="classrclcpp_1_1Node.html#a5495b9faae261feed33d8d8828840709">More...</a><br /></td></tr>
<tr class="separator:a5495b9faae261feed33d8d8828840709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2378e5b1486e58afdead52fa14928c2b"><td class="memItemLeft" align="right" valign="top">rclcpp::node_interfaces::NodeGraphInterface::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a2378e5b1486e58afdead52fa14928c2b">get_node_graph_interface</a> ()</td></tr>
<tr class="memdesc:a2378e5b1486e58afdead52fa14928c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a>'s internal NodeGraphInterface implementation.  <a href="classrclcpp_1_1Node.html#a2378e5b1486e58afdead52fa14928c2b">More...</a><br /></td></tr>
<tr class="separator:a2378e5b1486e58afdead52fa14928c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05394f5147dd263af2df15a99f5a4bb"><td class="memItemLeft" align="right" valign="top">rclcpp::node_interfaces::NodeLoggingInterface::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#af05394f5147dd263af2df15a99f5a4bb">get_node_logging_interface</a> ()</td></tr>
<tr class="memdesc:af05394f5147dd263af2df15a99f5a4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a>'s internal NodeLoggingInterface implementation.  <a href="classrclcpp_1_1Node.html#af05394f5147dd263af2df15a99f5a4bb">More...</a><br /></td></tr>
<tr class="separator:af05394f5147dd263af2df15a99f5a4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28869f473b562a08aa581fc7deae867"><td class="memItemLeft" align="right" valign="top">rclcpp::node_interfaces::NodeTimersInterface::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#aa28869f473b562a08aa581fc7deae867">get_node_timers_interface</a> ()</td></tr>
<tr class="memdesc:aa28869f473b562a08aa581fc7deae867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a>'s internal NodeTimersInterface implementation.  <a href="classrclcpp_1_1Node.html#aa28869f473b562a08aa581fc7deae867">More...</a><br /></td></tr>
<tr class="separator:aa28869f473b562a08aa581fc7deae867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae76be5bac60aea82486a9b4c6b2ff5"><td class="memItemLeft" align="right" valign="top">rclcpp::node_interfaces::NodeTopicsInterface::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a5ae76be5bac60aea82486a9b4c6b2ff5">get_node_topics_interface</a> ()</td></tr>
<tr class="memdesc:a5ae76be5bac60aea82486a9b4c6b2ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a>'s internal NodeTopicsInterface implementation.  <a href="classrclcpp_1_1Node.html#a5ae76be5bac60aea82486a9b4c6b2ff5">More...</a><br /></td></tr>
<tr class="separator:a5ae76be5bac60aea82486a9b4c6b2ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588cb7990fd658e58c532d65e4872df3"><td class="memItemLeft" align="right" valign="top">rclcpp::node_interfaces::NodeServicesInterface::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a588cb7990fd658e58c532d65e4872df3">get_node_services_interface</a> ()</td></tr>
<tr class="memdesc:a588cb7990fd658e58c532d65e4872df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a>'s internal NodeServicesInterface implementation.  <a href="classrclcpp_1_1Node.html#a588cb7990fd658e58c532d65e4872df3">More...</a><br /></td></tr>
<tr class="separator:a588cb7990fd658e58c532d65e4872df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6708bb439e1d3bb1ea44fbae50e460b2"><td class="memItemLeft" align="right" valign="top">rclcpp::node_interfaces::NodeWaitablesInterface::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a6708bb439e1d3bb1ea44fbae50e460b2">get_node_waitables_interface</a> ()</td></tr>
<tr class="memdesc:a6708bb439e1d3bb1ea44fbae50e460b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a>'s internal NodeWaitablesInterface implementation.  <a href="classrclcpp_1_1Node.html#a6708bb439e1d3bb1ea44fbae50e460b2">More...</a><br /></td></tr>
<tr class="separator:a6708bb439e1d3bb1ea44fbae50e460b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6272f2facdfb35f0ef9ce01ffedeec9"><td class="memItemLeft" align="right" valign="top">rclcpp::node_interfaces::NodeParametersInterface::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#ab6272f2facdfb35f0ef9ce01ffedeec9">get_node_parameters_interface</a> ()</td></tr>
<tr class="memdesc:ab6272f2facdfb35f0ef9ce01ffedeec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a>'s internal NodeParametersInterface implementation.  <a href="classrclcpp_1_1Node.html#ab6272f2facdfb35f0ef9ce01ffedeec9">More...</a><br /></td></tr>
<tr class="separator:ab6272f2facdfb35f0ef9ce01ffedeec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa70b6e8bd3ecc39c5928d822024db39"><td class="memItemLeft" align="right" valign="top">rclcpp::node_interfaces::NodeTimeSourceInterface::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#afa70b6e8bd3ecc39c5928d822024db39">get_node_time_source_interface</a> ()</td></tr>
<tr class="memdesc:afa70b6e8bd3ecc39c5928d822024db39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a>'s internal NodeTimeSourceInterface implementation.  <a href="classrclcpp_1_1Node.html#afa70b6e8bd3ecc39c5928d822024db39">More...</a><br /></td></tr>
<tr class="separator:afa70b6e8bd3ecc39c5928d822024db39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ac5055f3f7a3537642482bd505d4bd"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#aa9ac5055f3f7a3537642482bd505d4bd">get_sub_namespace</a> () const</td></tr>
<tr class="memdesc:aa9ac5055f3f7a3537642482bd505d4bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sub-namespace, if this is a sub-node, otherwise an empty string.  <a href="classrclcpp_1_1Node.html#aa9ac5055f3f7a3537642482bd505d4bd">More...</a><br /></td></tr>
<tr class="separator:aa9ac5055f3f7a3537642482bd505d4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4790bba38942b795d24b6ccb3e9c5a"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#afe4790bba38942b795d24b6ccb3e9c5a">get_effective_namespace</a> () const</td></tr>
<tr class="memdesc:afe4790bba38942b795d24b6ccb3e9c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the effective namespace that is used when creating entities.  <a href="classrclcpp_1_1Node.html#afe4790bba38942b795d24b6ccb3e9c5a">More...</a><br /></td></tr>
<tr class="separator:afe4790bba38942b795d24b6ccb3e9c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df8e4507d17a503630317432449d69d"><td class="memItemLeft" align="right" valign="top">rclcpp::Node::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a1df8e4507d17a503630317432449d69d">create_sub_node</a> (const std::string &amp;sub_namespace)</td></tr>
<tr class="memdesc:a1df8e4507d17a503630317432449d69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sub-node, which will extend the namespace of all entities created with it.  <a href="classrclcpp_1_1Node.html#a1df8e4507d17a503630317432449d69d">More...</a><br /></td></tr>
<tr class="separator:a1df8e4507d17a503630317432449d69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b6a37589d4371c9e0675acfc0f197a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classrclcpp_1_1NodeOptions.html">rclcpp::NodeOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a53b6a37589d4371c9e0675acfc0f197a">get_node_options</a> () const</td></tr>
<tr class="memdesc:a53b6a37589d4371c9e0675acfc0f197a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classrclcpp_1_1NodeOptions.html" title="Encapsulation of options for node initialization.">NodeOptions</a> used when creating this node.  <a href="classrclcpp_1_1Node.html#a53b6a37589d4371c9e0675acfc0f197a">More...</a><br /></td></tr>
<tr class="separator:a53b6a37589d4371c9e0675acfc0f197a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9aed5a03eb2420254745528a7d20443"><td class="memTemplParams" colspan="2">template&lt;typename ServiceT &gt; </td></tr>
<tr class="memitem:ac9aed5a03eb2420254745528a7d20443"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1Client.html">Client</a>&lt; ServiceT &gt;::SharedPtr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#ac9aed5a03eb2420254745528a7d20443">create_client</a> (const std::string &amp;service_name, const rmw_qos_profile_t &amp;qos_profile, rclcpp::CallbackGroup::SharedPtr group)</td></tr>
<tr class="separator:ac9aed5a03eb2420254745528a7d20443"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a52e594aa6a2790c0190739d862f68270"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html#a52e594aa6a2790c0190739d862f68270">Node</a> (const <a class="el" href="classrclcpp_1_1Node.html">Node</a> &amp;other, const std::string &amp;sub_namespace)</td></tr>
<tr class="memdesc:a52e594aa6a2790c0190739d862f68270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sub-node, which will extend the namespace of all entities created with it.  <a href="classrclcpp_1_1Node.html#a52e594aa6a2790c0190739d862f68270">More...</a><br /></td></tr>
<tr class="separator:a52e594aa6a2790c0190739d862f68270"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> is the single point of entry for creating publishers and subscribers. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aac7e1fe50bc2683380cd9a635ac51edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7e1fe50bc2683380cd9a635ac51edb">&#9670;&nbsp;</a></span>OnSetParametersCallbackHandle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrclcpp_1_1Node.html#aac7e1fe50bc2683380cd9a635ac51edb">rclcpp::Node::OnSetParametersCallbackHandle</a> =  <a class="el" href="structrclcpp_1_1node__interfaces_1_1OnSetParametersCallbackHandle.html">rclcpp::node_interfaces::OnSetParametersCallbackHandle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab403fecdb5ec2eb9f88e3eb7ae6f6d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab403fecdb5ec2eb9f88e3eb7ae6f6d0c">&#9670;&nbsp;</a></span>OnParametersSetCallbackType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrclcpp_1_1Node.html#ab403fecdb5ec2eb9f88e3eb7ae6f6d0c">rclcpp::Node::OnParametersSetCallbackType</a> =  <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeParametersInterface.html#a7143766bc4249673edb6244820fc5a94">rclcpp::node_interfaces::NodeParametersInterface::OnParametersSetCallbackType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abaa409bd2dc2cc2437fd9e47378cc5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa409bd2dc2cc2437fd9e47378cc5af">&#9670;&nbsp;</a></span>Node() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::Node::Node </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>node_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1NodeOptions.html">NodeOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="classrclcpp_1_1NodeOptions.html">NodeOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new node with the specified name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_name</td><td>Name of the node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Additional options to control creation of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidNamespaceError</td><td>if the namespace is invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83f5f45604217b3dc583dac7ab3b66a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f5f45604217b3dc583dac7ab3b66a8">&#9670;&nbsp;</a></span>Node() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::Node::Node </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>node_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>namespace_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1NodeOptions.html">NodeOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="classrclcpp_1_1NodeOptions.html">NodeOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new node with the specified name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_name</td><td>Name of the node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">namespace_</td><td>Namespace of the node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Additional options to control creation of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidNamespaceError</td><td>if the namespace is invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63584993927b11869d15a34af7e64937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63584993927b11869d15a34af7e64937">&#9670;&nbsp;</a></span>~Node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual rclcpp::Node::~Node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a52e594aa6a2790c0190739d862f68270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e594aa6a2790c0190739d862f68270">&#9670;&nbsp;</a></span>Node() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::Node::Node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sub_namespace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a sub-node, which will extend the namespace of all entities created with it. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Node.html#a1df8e4507d17a503630317432449d69d" title="Create a sub-node, which will extend the namespace of all entities created with it.">create_sub_node()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The node from which a new sub-node is created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sub_namespace</td><td>The sub-namespace of the sub-node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1e162104495b21f50c1e9aa11460fb93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e162104495b21f50c1e9aa11460fb93">&#9670;&nbsp;</a></span>get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rclcpp::Node::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the node. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of the node. </dd></dl>

</div>
</div>
<a id="a7be04e55e2934e05df992b188d9dce6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be04e55e2934e05df992b188d9dce6d">&#9670;&nbsp;</a></span>get_namespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rclcpp::Node::get_namespace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the namespace of the node. </p>
<p>This namespace is the "node's" namespace, and therefore is not affected by any sub-namespace's that may affect entities created with this instance. Use <a class="el" href="classrclcpp_1_1Node.html#afe4790bba38942b795d24b6ccb3e9c5a" title="Return the effective namespace that is used when creating entities.">get_effective_namespace()</a> to get the full namespace used by entities.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Node.html#aa9ac5055f3f7a3537642482bd505d4bd" title="Return the sub-namespace, if this is a sub-node, otherwise an empty string.">get_sub_namespace()</a> </dd>
<dd>
<a class="el" href="classrclcpp_1_1Node.html#afe4790bba38942b795d24b6ccb3e9c5a" title="Return the effective namespace that is used when creating entities.">get_effective_namespace()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The namespace of the node. </dd></dl>

</div>
</div>
<a id="a57f81aa79665cd9d16a591bddf762747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f81aa79665cd9d16a591bddf762747">&#9670;&nbsp;</a></span>get_fully_qualified_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rclcpp::Node::get_fully_qualified_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the fully-qualified name of the node. </p>
<p>The fully-qualified name includes the local namespace and name of the node. </p><dl class="section return"><dt>Returns</dt><dd>fully-qualified name of the node. </dd></dl>

</div>
</div>
<a id="a884ebededa2125cb8316998852ca3fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884ebededa2125cb8316998852ca3fc5">&#9670;&nbsp;</a></span>get_logger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1Logger.html">rclcpp::Logger</a> rclcpp::Node::get_logger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the logger of the node. </p>
<dl class="section return"><dt>Returns</dt><dd>The logger of the node. </dd></dl>

</div>
</div>
<a id="a1836b0fb28e1adc4b4e844f862552639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1836b0fb28e1adc4b4e844f862552639">&#9670;&nbsp;</a></span>create_callback_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::CallbackGroup::SharedPtr rclcpp::Node::create_callback_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerclcpp.html#a0027d5804ef28f0b6fea8eea4195c44a">rclcpp::CallbackGroupType</a>&#160;</td>
          <td class="paramname"><em>group_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>automatically_add_to_executor_with_node</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and return a callback group. </p>

</div>
</div>
<a id="ac3f396915654cc774ba0d76202db989d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f396915654cc774ba0d76202db989d">&#9670;&nbsp;</a></span>for_each_callback_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Node::for_each_callback_group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeBaseInterface.html#a0999fa38e0674245d3b41b742655e811">node_interfaces::NodeBaseInterface::CallbackGroupFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over the callback groups in the node, calling the given function on each valid one. </p>
<p>This method is called in a thread-safe way, and also makes sure to only call the given function on those items that are still valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The callback function to call on each valid callback group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1dfc9d04d67ab93353e04a7df72bc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1dfc9d04d67ab93353e04a7df72bc9a">&#9670;&nbsp;</a></span>create_publisher()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageT , typename AllocatorT , typename PublisherT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; PublisherT &gt; rclcpp::Node::create_publisher </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> &amp;&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">PublisherOptionsWithAllocator</a>&lt; AllocatorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">PublisherOptionsWithAllocator</a>&lt;AllocatorT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and return a <a class="el" href="classrclcpp_1_1Publisher.html" title="A publisher publishes messages of any type to a topic.">Publisher</a>. </p>
<p>The <a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">rclcpp::QoS</a> has several convenient constructors, including a conversion constructor for size_t, which mimics older API's that allows just a string and size_t to create a publisher.</p>
<p>For example, all of these cases will work:</p>
<div class="fragment"><div class="line">pub = node-&gt;create_publisher&lt;MsgT&gt;(<span class="stringliteral">&quot;chatter&quot;</span>, 10);  <span class="comment">// implicitly KeepLast</span></div>
<div class="line">pub = node-&gt;create_publisher&lt;MsgT&gt;(<span class="stringliteral">&quot;chatter&quot;</span>, QoS(10));  <span class="comment">// implicitly KeepLast</span></div>
<div class="line">pub = node-&gt;create_publisher&lt;MsgT&gt;(<span class="stringliteral">&quot;chatter&quot;</span>, QoS(<a class="code" href="namespacerclcpp.html#aa48cefe5c31e4efce7e715a23f02fc6aadc899de472766d7f25128b9ef50be307">KeepLast</a>(10)));</div>
<div class="line">pub = node-&gt;create_publisher&lt;MsgT&gt;(<span class="stringliteral">&quot;chatter&quot;</span>, QoS(<a class="code" href="namespacerclcpp.html#aa48cefe5c31e4efce7e715a23f02fc6aa98e4e92f8ed10755a2fde1531cf6593f">KeepAll</a>()));</div>
<div class="line">pub = node-&gt;create_publisher&lt;MsgT&gt;(<span class="stringliteral">&quot;chatter&quot;</span>, QoS(1).best_effort().durability_volatile());</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> custom_qos(<a class="code" href="namespacerclcpp.html#aa48cefe5c31e4efce7e715a23f02fc6aadc899de472766d7f25128b9ef50be307">KeepLast</a>(10), rmw_qos_profile_sensor_data);</div>
<div class="line">  pub = node-&gt;create_publisher&lt;MsgT&gt;(<span class="stringliteral">&quot;chatter&quot;</span>, custom_qos);</div>
<div class="line">}</div>
<div class="ttc" id="aclassrclcpp_1_1QoS_html"><div class="ttname"><a href="classrclcpp_1_1QoS.html">rclcpp::QoS</a></div><div class="ttdoc">Encapsulation of Quality of Service settings.</div><div class="ttdef"><b>Definition:</b> qos.hpp:111</div></div>
<div class="ttc" id="anamespacerclcpp_html_aa48cefe5c31e4efce7e715a23f02fc6aa98e4e92f8ed10755a2fde1531cf6593f"><div class="ttname"><a href="namespacerclcpp.html#aa48cefe5c31e4efce7e715a23f02fc6aa98e4e92f8ed10755a2fde1531cf6593f">rclcpp::HistoryPolicy::KeepAll</a></div><div class="ttdeci">@ KeepAll</div></div>
<div class="ttc" id="anamespacerclcpp_html_aa48cefe5c31e4efce7e715a23f02fc6aadc899de472766d7f25128b9ef50be307"><div class="ttname"><a href="namespacerclcpp.html#aa48cefe5c31e4efce7e715a23f02fc6aadc899de472766d7f25128b9ef50be307">rclcpp::HistoryPolicy::KeepLast</a></div><div class="ttdeci">@ KeepLast</div></div>
</div><!-- fragment --><p>The publisher options may optionally be passed as the third argument for any of the above cases.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topic_name</td><td>The topic for this publisher to publish on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qos</td><td>The Quality of <a class="el" href="classrclcpp_1_1Service.html">Service</a> settings for the publisher. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Additional options for the created <a class="el" href="classrclcpp_1_1Publisher.html" title="A publisher publishes messages of any type to a topic.">Publisher</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to the created publisher. </dd></dl>

</div>
</div>
<a id="acb6f1370b4f676c843272d4b6b41b46d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6f1370b4f676c843272d4b6b41b46d">&#9670;&nbsp;</a></span>create_subscription()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageT , typename CallbackT , typename AllocatorT , typename SubscriptionT , typename MessageMemoryStrategyT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; SubscriptionT &gt; rclcpp::Node::create_subscription </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> &amp;&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">SubscriptionOptionsWithAllocator</a>&lt; AllocatorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">SubscriptionOptionsWithAllocator</a>&lt;AllocatorT&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MessageMemoryStrategyT::SharedPtr&#160;</td>
          <td class="paramname"><em>msg_mem_strat</em> = <code>(&#160;&#160;&#160;&#160;&#160;&#160;MessageMemoryStrategyT::create_default()&#160;&#160;&#160;&#160;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and return a <a class="el" href="classrclcpp_1_1Subscription.html" title="Subscription implementation, templated on the type of message this subscription receives.">Subscription</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topic_name</td><td>The topic to subscribe on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qos</td><td><a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">QoS</a> profile for Subcription. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The user-defined callback function to receive a message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Additional options for the creation of the <a class="el" href="classrclcpp_1_1Subscription.html" title="Subscription implementation, templated on the type of message this subscription receives.">Subscription</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg_mem_strat</td><td>The message memory strategy to use for allocating messages. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to the created subscription. </dd></dl>

</div>
</div>
<a id="ad27d1f6d1c5ff633b1b42ab6f77479c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27d1f6d1c5ff633b1b42ab6f77479c5">&#9670;&nbsp;</a></span>create_wall_timer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DurationRepT , typename DurationT , typename CallbackT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1WallTimer.html">rclcpp::WallTimer</a>&lt; CallbackT &gt;::SharedPtr rclcpp::Node::create_wall_timer </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; DurationRepT, DurationT &gt;&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackT&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rclcpp::CallbackGroup::SharedPtr&#160;</td>
          <td class="paramname"><em>group</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td><a class="el" href="classrclcpp_1_1Time.html">Time</a> interval between triggers of the callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>User-defined callback function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Callback group to execute this timer's callback in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed42f345ae1de3a1979d5a8076127199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed42f345ae1de3a1979d5a8076127199">&#9670;&nbsp;</a></span>create_client() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ServiceT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1Client.html">rclcpp::Client</a>&lt;ServiceT&gt;::SharedPtr rclcpp::Node::create_client </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rmw_qos_profile_t &amp;&#160;</td>
          <td class="paramname"><em>qos_profile</em> = <code>rmw_qos_profile_services_default</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rclcpp::CallbackGroup::SharedPtr&#160;</td>
          <td class="paramname"><em>group</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and return a <a class="el" href="classrclcpp_1_1Client.html">Client</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">service_name</td><td>The topic to service on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qos_profile</td><td>rmw_qos_profile_t Quality of service profile for client. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Callback group to call the service. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to the created client. </dd></dl>

</div>
</div>
<a id="a20d1f389ba5e4a57559203d5d9e77ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d1f389ba5e4a57559203d5d9e77ec9">&#9670;&nbsp;</a></span>create_service()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ServiceT , typename CallbackT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1Service.html">rclcpp::Service</a>&lt; ServiceT &gt;::SharedPtr rclcpp::Node::create_service </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rmw_qos_profile_t &amp;&#160;</td>
          <td class="paramname"><em>qos_profile</em> = <code>rmw_qos_profile_services_default</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rclcpp::CallbackGroup::SharedPtr&#160;</td>
          <td class="paramname"><em>group</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and return a <a class="el" href="classrclcpp_1_1Service.html">Service</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">service_name</td><td>The topic to service on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>User-defined callback function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qos_profile</td><td>rmw_qos_profile_t Quality of service profile for client. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Callback group to call the service. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to the created service. </dd></dl>

</div>
</div>
<a id="af73e99cfe2655b1bdb1d6d34cc9775aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73e99cfe2655b1bdb1d6d34cc9775aa">&#9670;&nbsp;</a></span>create_generic_publisher()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1GenericPublisher.html">rclcpp::GenericPublisher</a> &gt; rclcpp::Node::create_generic_publisher </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> &amp;&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">rclcpp::PublisherOptionsWithAllocator</a>&lt; AllocatorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>(&#160;&#160;&#160;&#160;&#160;&#160;<a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">rclcpp::PublisherOptionsWithAllocator</a>&lt;AllocatorT&gt;()&#160;&#160;&#160;&#160;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and return a <a class="el" href="classrclcpp_1_1GenericPublisher.html" title="Publisher for serialized messages whose type is not known at compile time.">GenericPublisher</a>. </p>
<p>The returned pointer will never be empty, but this function can throw various exceptions, for instance when the message's package can not be found on the AMENT_PREFIX_PATH.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topic_name</td><td>Topic name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topic_type</td><td>Topic type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qos</td><td>QoS settings </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Publisher options. Not all publisher options are currently respected, the only relevant options for this publisher are <code>event_callbacks</code>, <code>use_default_callbacks</code>, and <code>callback_group</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to the created generic publisher. </dd></dl>

</div>
</div>
<a id="a54fce75ef652d8c5db159204afa5dd08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54fce75ef652d8c5db159204afa5dd08">&#9670;&nbsp;</a></span>create_generic_subscription()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1GenericSubscription.html">rclcpp::GenericSubscription</a> &gt; rclcpp::Node::create_generic_subscription </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> &amp;&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1SerializedMessage.html">rclcpp::SerializedMessage</a> &gt;)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">rclcpp::SubscriptionOptionsWithAllocator</a>&lt; AllocatorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>(&#160;&#160;&#160;&#160;&#160;&#160;<a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">rclcpp::SubscriptionOptionsWithAllocator</a>&lt;AllocatorT&gt;()&#160;&#160;&#160;&#160;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and return a <a class="el" href="classrclcpp_1_1GenericSubscription.html" title="Subscription for serialized messages whose type is not known at compile time.">GenericSubscription</a>. </p>
<p>The returned pointer will never be empty, but this function can throw various exceptions, for instance when the message's package can not be found on the AMENT_PREFIX_PATH.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topic_name</td><td>Topic name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topic_type</td><td>Topic type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qos</td><td>QoS settings </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Callback for new messages of serialized form </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Subscription options. Not all subscription options are currently respected, the only relevant options for this subscription are <code>event_callbacks</code>, <code>use_default_callbacks</code>, <code>ignore_local_publications</code>, and <code>callback_group</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to the created generic subscription. </dd></dl>

</div>
</div>
<a id="a2f2297309b4c1a2e583801fa8a6ef955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2297309b4c1a2e583801fa8a6ef955">&#9670;&nbsp;</a></span>declare_parameter() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classrclcpp_1_1ParameterValue.html">rclcpp::ParameterValue</a>&amp; rclcpp::Node::declare_parameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1ParameterValue.html">rclcpp::ParameterValue</a> &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rcl_interfaces::msg::ParameterDescriptor &amp;&#160;</td>
          <td class="paramname"><em>parameter_descriptor</em> = <code>rcl_interfaces::msg::ParameterDescriptor()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_override</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare and initialize a parameter, return the effective value. </p>
<p>This method is used to declare that a parameter exists on this node. If, at run-time, the user has provided an initial value then it will be set in this method, otherwise the given default_value will be set. In either case, the resulting value is returned, whether or not it is based on the default value or the user provided initial value.</p>
<p>If no parameter_descriptor is given, then the default values from the message definition will be used, e.g. read_only will be false.</p>
<p>The name and type in the given rcl_interfaces::msg::ParameterDescriptor are ignored, and should be specified using the name argument to this function and the default value's type instead.</p>
<p>If <code>ignore_override</code> is <code>true</code>, the parameter override will be ignored.</p>
<p>This method, if successful, will result in any callback registered with add_on_set_parameters_callback to be called. If that callback prevents the initial value for the parameter from being set then <a class="el" href="classrclcpp_1_1exceptions_1_1InvalidParameterValueException.html" title="Thrown if passed parameter value is invalid.">rclcpp::exceptions::InvalidParameterValueException</a> is thrown.</p>
<p>The returned reference will remain valid until the parameter is undeclared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_value</td><td>An initial value to be used if at run-time user did not override it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter_descriptor</td><td>An optional, custom description for the parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_override</td><td>When <code>true</code>, the parameter override is ignored. Default to <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the value of the parameter. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1exceptions_1_1ParameterAlreadyDeclaredException.html" title="Thrown if parameter is already declared.">rclcpp::exceptions::ParameterAlreadyDeclaredException</a></td><td>if parameter has already been declared. </td></tr>
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1exceptions_1_1InvalidParametersException.html" title="Thrown if passed parameters are inconsistent or invalid.">rclcpp::exceptions::InvalidParametersException</a></td><td>if a parameter name is invalid. </td></tr>
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1exceptions_1_1InvalidParameterValueException.html" title="Thrown if passed parameter value is invalid.">rclcpp::exceptions::InvalidParameterValueException</a></td><td>if initial value fails to be set. </td></tr>
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1exceptions_1_1InvalidParameterTypeException.html" title="Thrown if requested parameter type is invalid.">rclcpp::exceptions::InvalidParameterTypeException</a></td><td>if the type of the default value or override is wrong. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a333cba98bb365cfa98614b993f522d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333cba98bb365cfa98614b993f522d38">&#9670;&nbsp;</a></span>declare_parameter() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classrclcpp_1_1ParameterValue.html">rclcpp::ParameterValue</a>&amp; rclcpp::Node::declare_parameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerclcpp.html#a1b307a4b7368b68f325812cd2aeb8784">rclcpp::ParameterType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rcl_interfaces::msg::ParameterDescriptor &amp;&#160;</td>
          <td class="paramname"><em>parameter_descriptor</em> = <code>rcl_interfaces::msg::ParameterDescriptor{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_override</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare and initialize a parameter, return the effective value. </p>
<p>Same as the previous one, but a default value is not provided and the user must provide a parameter override of the correct type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Desired type of the parameter, which will enforced at runtime. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter_descriptor</td><td>An optional, custom description for the parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_override</td><td>When <code>true</code>, the parameter override is ignored. Default to <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the value of the parameter. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Same</td><td>as the previous overload taking a default value. </td></tr>
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1exceptions_1_1InvalidParameterTypeException.html" title="Thrown if requested parameter type is invalid.">rclcpp::exceptions::InvalidParameterTypeException</a></td><td>if an override is not provided or the provided override is of the wrong type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b1ca8c48e28bd1f3e5fda2ab3116efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1ca8c48e28bd1f3e5fda2ab3116efd">&#9670;&nbsp;</a></span>declare_parameter() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParameterT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rclcpp::Node::declare_parameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ParameterT &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rcl_interfaces::msg::ParameterDescriptor &amp;&#160;</td>
          <td class="paramname"><em>parameter_descriptor</em> = <code>rcl_interfaces::msg::ParameterDescriptor()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_override</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare and initialize a parameter with a type. </p>
<p>See the non-templated <a class="el" href="classrclcpp_1_1Node.html#a2f2297309b4c1a2e583801fa8a6ef955" title="Declare and initialize a parameter, return the effective value.">declare_parameter()</a> on this class for details.</p>
<p>If the type of the default value, and therefore also the type of return value, differs from the initial value provided in the node options, then a <a class="el" href="classrclcpp_1_1exceptions_1_1InvalidParameterTypeException.html" title="Thrown if requested parameter type is invalid.">rclcpp::exceptions::InvalidParameterTypeException</a> may be thrown. To avoid this, use the <a class="el" href="classrclcpp_1_1Node.html#a2f2297309b4c1a2e583801fa8a6ef955" title="Declare and initialize a parameter, return the effective value.">declare_parameter()</a> method which returns an <a class="el" href="classrclcpp_1_1ParameterValue.html" title="Store the type and value of a parameter.">rclcpp::ParameterValue</a> instead.</p>
<p>Note, this method cannot return a const reference, because extending the lifetime of a temporary only works recursively with member initializers, and cannot be extended to members of a class returned. The return value of this class is a copy of the member of a <a class="el" href="classrclcpp_1_1ParameterValue.html" title="Store the type and value of a parameter.">ParameterValue</a> which is returned by the other version of <a class="el" href="classrclcpp_1_1Node.html#a2f2297309b4c1a2e583801fa8a6ef955" title="Declare and initialize a parameter, return the effective value.">declare_parameter()</a>. See also:</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/lifetime">https://en.cppreference.com/w/cpp/language/lifetime</a></li>
<li><a href="https://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/">https://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/</a></li>
<li><a href="https://www.youtube.com/watch?v=uQyT-5iWUow">https://www.youtube.com/watch?v=uQyT-5iWUow</a> (cppnow 2018 presentation) </li>
</ul>

</div>
</div>
<a id="ac12051ad340f2212370a0829e55674ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac12051ad340f2212370a0829e55674ad">&#9670;&nbsp;</a></span>declare_parameter() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParameterT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rclcpp::Node::declare_parameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rcl_interfaces::msg::ParameterDescriptor &amp;&#160;</td>
          <td class="paramname"><em>parameter_descriptor</em> = <code>rcl_interfaces::msg::ParameterDescriptor()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_override</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare and initialize a parameter with a type. </p>
<p>See the non-templated <a class="el" href="classrclcpp_1_1Node.html#a2f2297309b4c1a2e583801fa8a6ef955" title="Declare and initialize a parameter, return the effective value.">declare_parameter()</a> on this class for details. </p>

</div>
</div>
<a id="a5ebda51ed6fa4ce8f2cddc9f77e9674e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ebda51ed6fa4ce8f2cddc9f77e9674e">&#9670;&nbsp;</a></span>declare_parameters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParameterT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; ParameterT &gt; rclcpp::Node::declare_parameters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>namespace_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, ParameterT &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_overrides</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare and initialize several parameters with the same namespace and type. </p>
<p>For each key in the map, a parameter with a name of "namespace.key" will be set to the value in the map. The resulting value for each declared parameter will be returned.</p>
<p>The name expansion is naive, so if you set the namespace to be "foo.", then the resulting parameter names will be like "foo..key". However, if the namespace is an empty string, then no leading '.' will be placed before each key, which would have been the case when naively expanding "namespace.key". This allows you to declare several parameters at once without a namespace.</p>
<p>The map contains default values for parameters. There is another overload which takes the std::pair with the default value and descriptor.</p>
<p>If <code>ignore_overrides</code> is <code>true</code>, all the overrides of the parameters declared by the function call will be ignored.</p>
<p>This method, if successful, will result in any callback registered with add_on_set_parameters_callback to be called, once for each parameter. If that callback prevents the initial value for any parameter from being set then <a class="el" href="classrclcpp_1_1exceptions_1_1InvalidParameterValueException.html" title="Thrown if passed parameter value is invalid.">rclcpp::exceptions::InvalidParameterValueException</a> is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">namespace_</td><td>The namespace in which to declare the parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parameters</td><td>The parameters to set in the given namespace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_overrides</td><td>When <code>true</code>, the parameters overrides are ignored. Default to <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1exceptions_1_1ParameterAlreadyDeclaredException.html" title="Thrown if parameter is already declared.">rclcpp::exceptions::ParameterAlreadyDeclaredException</a></td><td>if parameter has already been declared. </td></tr>
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1exceptions_1_1InvalidParametersException.html" title="Thrown if passed parameters are inconsistent or invalid.">rclcpp::exceptions::InvalidParametersException</a></td><td>if a parameter name is invalid. </td></tr>
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1exceptions_1_1InvalidParameterValueException.html" title="Thrown if passed parameter value is invalid.">rclcpp::exceptions::InvalidParameterValueException</a></td><td>if initial value fails to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b3300ad15cdf9e22ee7bfc844b9a30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3300ad15cdf9e22ee7bfc844b9a30c">&#9670;&nbsp;</a></span>declare_parameters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParameterT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; ParameterT &gt; rclcpp::Node::declare_parameters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>namespace_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::pair&lt; ParameterT, rcl_interfaces::msg::ParameterDescriptor &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_overrides</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare and initialize several parameters with the same namespace and type. </p>
<p>This version will take a map where the value is a pair, with the default parameter value as the first item and a parameter descriptor as the second.</p>
<p>See the simpler <a class="el" href="classrclcpp_1_1Node.html#a5ebda51ed6fa4ce8f2cddc9f77e9674e" title="Declare and initialize several parameters with the same namespace and type.">declare_parameters()</a> on this class for more details. </p>

</div>
</div>
<a id="a2c525bd10070bd025bd570e98afd0d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c525bd10070bd025bd570e98afd0d7d">&#9670;&nbsp;</a></span>undeclare_parameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Node::undeclare_parameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undeclare a previously declared parameter. </p>
<p>This method will not cause a callback registered with add_on_set_parameters_callback to be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the parameter to be undeclared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1exceptions_1_1ParameterNotDeclaredException.html" title="Thrown if parameter is not declared, e.g. either set or get was called without first declaring.">rclcpp::exceptions::ParameterNotDeclaredException</a></td><td>if the parameter has not been declared. </td></tr>
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1exceptions_1_1ParameterImmutableException.html" title="Thrown if parameter is immutable and therefore cannot be undeclared.">rclcpp::exceptions::ParameterImmutableException</a></td><td>if the parameter was create as read_only (immutable). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabb818bb5c848c5a980ddbe745517b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb818bb5c848c5a980ddbe745517b7c">&#9670;&nbsp;</a></span>has_parameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::Node::has_parameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if a given parameter is declared. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the parameter to check for being declared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the parameter name has been declared, otherwise false. </dd></dl>

</div>
</div>
<a id="a8c753036cd5cbdf0168ca3b39a193223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c753036cd5cbdf0168ca3b39a193223">&#9670;&nbsp;</a></span>set_parameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rcl_interfaces::msg::SetParametersResult rclcpp::Node::set_parameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1Parameter.html">rclcpp::Parameter</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a single parameter. </p>
<p>Set the given parameter and then return result of the set action.</p>
<p>If the parameter has not been declared this function may throw the <a class="el" href="classrclcpp_1_1exceptions_1_1ParameterNotDeclaredException.html" title="Thrown if parameter is not declared, e.g. either set or get was called without first declaring.">rclcpp::exceptions::ParameterNotDeclaredException</a> exception, but only if the node was not created with the <a class="el" href="classrclcpp_1_1NodeOptions.html#a5b9580203b3cb88c75b5b858e26b3b7d" title="Return the allow_undeclared_parameters flag.">rclcpp::NodeOptions::allow_undeclared_parameters</a> set to true. If undeclared parameters are allowed, then the parameter is implicitly declared with the default parameter meta data before being set. <a class="el" href="classrclcpp_1_1Parameter.html" title="Structure to store an arbitrary parameter with templated get/set methods.">Parameter</a> overrides are ignored by set_parameter.</p>
<p>This method will result in any callback registered with add_on_set_parameters_callback to be called. If the callback prevents the parameter from being set, then it will be reflected in the SetParametersResult that is returned, but no exception will be thrown.</p>
<p>If the value type of the parameter is <a class="el" href="namespacerclcpp.html#a1b307a4b7368b68f325812cd2aeb8784adefddb470d1054265245a0c5dbeccf4e">rclcpp::PARAMETER_NOT_SET</a>, and the existing parameter type is something else, then the parameter will be implicitly undeclared. This will result in a parameter event indicating that the parameter was deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>The parameter to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the set action. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1exceptions_1_1ParameterNotDeclaredException.html" title="Thrown if parameter is not declared, e.g. either set or get was called without first declaring.">rclcpp::exceptions::ParameterNotDeclaredException</a></td><td>if the parameter has not been declared and undeclared parameters are not allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d8af4dc449c7130ccc396814b86c14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8af4dc449c7130ccc396814b86c14d">&#9670;&nbsp;</a></span>set_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;rcl_interfaces::msg::SetParametersResult&gt; rclcpp::Node::set_parameters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classrclcpp_1_1Parameter.html">rclcpp::Parameter</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set one or more parameters, one at a time. </p>
<p>Set the given parameters, one at a time, and then return result of each set action.</p>
<p>Parameters are set in the order they are given within the input vector.</p>
<p>Like set_parameter, if any of the parameters to be set have not first been declared, and undeclared parameters are not allowed (the default), then this method will throw <a class="el" href="classrclcpp_1_1exceptions_1_1ParameterNotDeclaredException.html" title="Thrown if parameter is not declared, e.g. either set or get was called without first declaring.">rclcpp::exceptions::ParameterNotDeclaredException</a>.</p>
<p>If setting a parameter fails due to not being declared, then the parameters which have already been set will stay set, and no attempt will be made to set the parameters which come after.</p>
<p>If a parameter fails to be set due to any other reason, like being rejected by the user's callback (basically any reason other than not having been declared beforehand), then that is reflected in the corresponding SetParametersResult in the vector returned by this function.</p>
<p>This method will result in any callback registered with add_on_set_parameters_callback to be called, once for each parameter. If the callback prevents the parameter from being set, then, as mentioned before, it will be reflected in the corresponding SetParametersResult that is returned, but no exception will be thrown.</p>
<p>Like <a class="el" href="classrclcpp_1_1Node.html#a8c753036cd5cbdf0168ca3b39a193223" title="Set a single parameter.">set_parameter()</a> this method will implicitly undeclare parameters with the type <a class="el" href="namespacerclcpp.html#a1b307a4b7368b68f325812cd2aeb8784adefddb470d1054265245a0c5dbeccf4e">rclcpp::PARAMETER_NOT_SET</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameters</td><td>The vector of parameters to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The results for each set action as a vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1exceptions_1_1ParameterNotDeclaredException.html" title="Thrown if parameter is not declared, e.g. either set or get was called without first declaring.">rclcpp::exceptions::ParameterNotDeclaredException</a></td><td>if any parameter has not been declared and undeclared parameters are not allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a6d4b50c0fab975859590c82931e9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a6d4b50c0fab975859590c82931e9ae">&#9670;&nbsp;</a></span>set_parameters_atomically()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rcl_interfaces::msg::SetParametersResult rclcpp::Node::set_parameters_atomically </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classrclcpp_1_1Parameter.html">rclcpp::Parameter</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set one or more parameters, all at once. </p>
<p>Set the given parameters, all at one time, and then aggregate result.</p>
<p>Behaves like set_parameter, except that it sets multiple parameters, failing all if just one of the parameters are unsuccessfully set. Either all of the parameters are set or none of them are set.</p>
<p>Like set_parameter and set_parameters, this method may throw an <a class="el" href="classrclcpp_1_1exceptions_1_1ParameterNotDeclaredException.html" title="Thrown if parameter is not declared, e.g. either set or get was called without first declaring.">rclcpp::exceptions::ParameterNotDeclaredException</a> exception if any of the parameters to be set have not first been declared. If the exception is thrown then none of the parameters will have been set.</p>
<p>This method will result in any callback registered with add_on_set_parameters_callback to be called, just one time. If the callback prevents the parameters from being set, then it will be reflected in the SetParametersResult which is returned, but no exception will be thrown.</p>
<p>If you pass multiple <a class="el" href="classrclcpp_1_1Parameter.html" title="Structure to store an arbitrary parameter with templated get/set methods.">rclcpp::Parameter</a> instances with the same name, then only the last one in the vector (forward iteration) will be set.</p>
<p>Like <a class="el" href="classrclcpp_1_1Node.html#a8c753036cd5cbdf0168ca3b39a193223" title="Set a single parameter.">set_parameter()</a> this method will implicitly undeclare parameters with the type <a class="el" href="namespacerclcpp.html#a1b307a4b7368b68f325812cd2aeb8784adefddb470d1054265245a0c5dbeccf4e">rclcpp::PARAMETER_NOT_SET</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameters</td><td>The vector of parameters to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The aggregate result of setting all the parameters atomically. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1exceptions_1_1ParameterNotDeclaredException.html" title="Thrown if parameter is not declared, e.g. either set or get was called without first declaring.">rclcpp::exceptions::ParameterNotDeclaredException</a></td><td>if any parameter has not been declared and undeclared parameters are not allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bf1077fba623d72fe1b49805f6c0a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf1077fba623d72fe1b49805f6c0a5a">&#9670;&nbsp;</a></span>get_parameter() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1Parameter.html">rclcpp::Parameter</a> rclcpp::Node::get_parameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the parameter by the given name. </p>
<p>If the parameter has not been declared, then this method may throw the <a class="el" href="classrclcpp_1_1exceptions_1_1ParameterNotDeclaredException.html" title="Thrown if parameter is not declared, e.g. either set or get was called without first declaring.">rclcpp::exceptions::ParameterNotDeclaredException</a> exception.</p>
<p>If undeclared parameters are allowed, see the node option <a class="el" href="classrclcpp_1_1NodeOptions.html#a5b9580203b3cb88c75b5b858e26b3b7d" title="Return the allow_undeclared_parameters flag.">rclcpp::NodeOptions::allow_undeclared_parameters</a>, then this method will not throw an exception, and instead return a default initialized <a class="el" href="classrclcpp_1_1Parameter.html" title="Structure to store an arbitrary parameter with templated get/set methods.">rclcpp::Parameter</a>, which has a type of rclcpp::ParameterType::PARAMETER_NOT_SET.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the parameter to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested parameter inside of a rclcpp parameter object. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1exceptions_1_1ParameterNotDeclaredException.html" title="Thrown if parameter is not declared, e.g. either set or get was called without first declaring.">rclcpp::exceptions::ParameterNotDeclaredException</a></td><td>if the parameter has not been declared and undeclared parameters are not allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fe80d17fb6789dec1ecf74c4d135aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe80d17fb6789dec1ecf74c4d135aad">&#9670;&nbsp;</a></span>get_parameter() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::Node::get_parameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1Parameter.html">rclcpp::Parameter</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a parameter by the given name, and return true if it was set. </p>
<p>This method will never throw the <a class="el" href="classrclcpp_1_1exceptions_1_1ParameterNotDeclaredException.html" title="Thrown if parameter is not declared, e.g. either set or get was called without first declaring.">rclcpp::exceptions::ParameterNotDeclaredException</a> exception, but will instead return false if the parameter has not be previously declared.</p>
<p>If the parameter was not declared, then the output argument for this method which is called "parameter" will not be assigned a value. If the parameter was declared, and therefore has a value, then it is assigned into the "parameter" argument of this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the parameter to get. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">parameter</td><td>The output storage for the parameter being retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the parameter was previously declared, otherwise false. </dd></dl>

</div>
</div>
<a id="a3158e5520c58531ae4d85a2e98cdf210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3158e5520c58531ae4d85a2e98cdf210">&#9670;&nbsp;</a></span>get_parameter() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParameterT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::Node::get_parameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParameterT &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a parameter by the given name, and return true if it was set. </p>
<p>Identical to the non-templated version of this method, except that when assigning the output argument called "parameter", this method will attempt to coerce the parameter value into the type requested by the given template argument, which may fail and throw an exception.</p>
<p>If the parameter has not been declared, it will not attempt to coerce the value into the requested type, as it is known that the type is not set.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1ParameterTypeException.html" title="Indicate the parameter type does not match the expected type.">rclcpp::ParameterTypeException</a></td><td>if the requested type does not match the value of the parameter which is stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4bba086f9d74de0f1f10ffb8deb4c11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bba086f9d74de0f1f10ffb8deb4c11a">&#9670;&nbsp;</a></span>get_parameter_or() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParameterT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::Node::get_parameter_or </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParameterT &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ParameterT &amp;&#160;</td>
          <td class="paramname"><em>alternative_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the parameter value, or the "alternative_value" if not set, and assign it to "parameter". </p>
<p>If the parameter was not set, then the "parameter" argument is assigned the "alternative_value".</p>
<p>Like the version of <a class="el" href="classrclcpp_1_1Node.html#a0bf1077fba623d72fe1b49805f6c0a5a" title="Return the parameter by the given name.">get_parameter()</a> which returns a bool, this method will not throw the <a class="el" href="classrclcpp_1_1exceptions_1_1ParameterNotDeclaredException.html" title="Thrown if parameter is not declared, e.g. either set or get was called without first declaring.">rclcpp::exceptions::ParameterNotDeclaredException</a> exception.</p>
<p>In all cases, the parameter is never set or declared within the node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the parameter to get. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">parameter</td><td>The output where the value of the parameter should be assigned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alternative_value</td><td>Value to be stored in output if the parameter was not set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the parameter was set, false otherwise. </dd></dl>

</div>
</div>
<a id="a13c042e282c9a3e169f53f27542962b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c042e282c9a3e169f53f27542962b9">&#9670;&nbsp;</a></span>get_parameter_or() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParameterT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ParameterT rclcpp::Node::get_parameter_or </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ParameterT &amp;&#160;</td>
          <td class="paramname"><em>alternative_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the parameter value, or the "alternative_value" if not set. </p>
<p>If the parameter was not set, then the "alternative_value" argument is returned.</p>
<p>This method will not throw the <a class="el" href="classrclcpp_1_1exceptions_1_1ParameterNotDeclaredException.html" title="Thrown if parameter is not declared, e.g. either set or get was called without first declaring.">rclcpp::exceptions::ParameterNotDeclaredException</a> exception.</p>
<p>In all cases, the parameter is never set or declared within the node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the parameter to get. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alternative_value</td><td>Value to be stored in output if the parameter was not set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the parameter. </dd></dl>

</div>
</div>
<a id="a25890d01a2cd47ce99af887f556c529b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25890d01a2cd47ce99af887f556c529b">&#9670;&nbsp;</a></span>get_parameters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classrclcpp_1_1Parameter.html">rclcpp::Parameter</a>&gt; rclcpp::Node::get_parameters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the parameters by the given parameter names. </p>
<p>Like <a class="el" href="classrclcpp_1_1Node.html#a25890d01a2cd47ce99af887f556c529b" title="Return the parameters by the given parameter names.">get_parameters()</a>, this method may throw the <a class="el" href="classrclcpp_1_1exceptions_1_1ParameterNotDeclaredException.html" title="Thrown if parameter is not declared, e.g. either set or get was called without first declaring.">rclcpp::exceptions::ParameterNotDeclaredException</a> exception if the requested parameter has not been declared and undeclared parameters are not allowed.</p>
<p>Also like <a class="el" href="classrclcpp_1_1Node.html#a25890d01a2cd47ce99af887f556c529b" title="Return the parameters by the given parameter names.">get_parameters()</a>, if undeclared parameters are allowed and the parameter has not been declared, then the corresponding <a class="el" href="classrclcpp_1_1Parameter.html" title="Structure to store an arbitrary parameter with templated get/set methods.">rclcpp::Parameter</a> will be default initialized and therefore have the type rclcpp::ParameterType::PARAMETER_NOT_SET.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>The names of the parameters to be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parameters that were retrieved. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1exceptions_1_1ParameterNotDeclaredException.html" title="Thrown if parameter is not declared, e.g. either set or get was called without first declaring.">rclcpp::exceptions::ParameterNotDeclaredException</a></td><td>if any of the parameters have not been declared and undeclared parameters are not allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5ab12777100f65bd09163814dbbf486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ab12777100f65bd09163814dbbf486">&#9670;&nbsp;</a></span>get_parameters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParameterT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::Node::get_parameters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, ParameterT &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the parameter values for all parameters that have a given prefix. </p>
<p>The "prefix" argument is used to list the parameters which are prefixed with that prefix, see also <a class="el" href="classrclcpp_1_1Node.html#a37aa95886a706c174db77c2b160f6d7d" title="Return a list of parameters with any of the given prefixes, up to the given depth.">list_parameters()</a>.</p>
<p>The resulting list of parameter names are used to get the values of the parameters.</p>
<p>The names which are used as keys in the values map have the prefix removed. For example, if you use the prefix "foo" and the parameters "foo.ping" and "foo.pong" exist, then the returned map will have the keys "ping" and "pong".</p>
<p>An empty string for the prefix will match all parameters.</p>
<p>If no parameters with the prefix are found, then the output parameter "values" will be unchanged and false will be returned. Otherwise, the parameter names and values will be stored in the map and true will be returned to indicate "values" was mutated.</p>
<p>This method will never throw the <a class="el" href="classrclcpp_1_1exceptions_1_1ParameterNotDeclaredException.html" title="Thrown if parameter is not declared, e.g. either set or get was called without first declaring.">rclcpp::exceptions::ParameterNotDeclaredException</a> exception because the action of listing the parameters is done atomically with getting the values, and therefore they are only listed if already declared and cannot be undeclared before being retrieved.</p>
<p>Like the templated <a class="el" href="classrclcpp_1_1Node.html#a0bf1077fba623d72fe1b49805f6c0a5a" title="Return the parameter by the given name.">get_parameter()</a> variant, this method will attempt to coerce the parameter values into the type requested by the given template argument, which may fail and throw an exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>The prefix of the parameters to get. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>The map used to store the parameter names and values, respectively, with one entry per parameter matching prefix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if output "values" was changed, false otherwise. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1ParameterTypeException.html" title="Indicate the parameter type does not match the expected type.">rclcpp::ParameterTypeException</a></td><td>if the requested type does not match the value of the parameter which is stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39de814a51b5792e86cd9b315e631fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39de814a51b5792e86cd9b315e631fe0">&#9670;&nbsp;</a></span>describe_parameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rcl_interfaces::msg::ParameterDescriptor rclcpp::Node::describe_parameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the parameter descriptor for the given parameter name. </p>
<p>Like <a class="el" href="classrclcpp_1_1Node.html#a25890d01a2cd47ce99af887f556c529b" title="Return the parameters by the given parameter names.">get_parameters()</a>, this method may throw the <a class="el" href="classrclcpp_1_1exceptions_1_1ParameterNotDeclaredException.html" title="Thrown if parameter is not declared, e.g. either set or get was called without first declaring.">rclcpp::exceptions::ParameterNotDeclaredException</a> exception if the requested parameter has not been declared and undeclared parameters are not allowed.</p>
<p>If undeclared parameters are allowed, then a default initialized descriptor will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the parameter to describe. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The descriptor for the given parameter name. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1exceptions_1_1ParameterNotDeclaredException.html" title="Thrown if parameter is not declared, e.g. either set or get was called without first declaring.">rclcpp::exceptions::ParameterNotDeclaredException</a></td><td>if the parameter has not been declared and undeclared parameters are not allowed. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the number of described parameters is more than one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbfb47c0983e14482c39159b274f6308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbfb47c0983e14482c39159b274f6308">&#9670;&nbsp;</a></span>describe_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;rcl_interfaces::msg::ParameterDescriptor&gt; rclcpp::Node::describe_parameters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a vector of parameter descriptors, one for each of the given names. </p>
<p>Like <a class="el" href="classrclcpp_1_1Node.html#a25890d01a2cd47ce99af887f556c529b" title="Return the parameters by the given parameter names.">get_parameters()</a>, this method may throw the <a class="el" href="classrclcpp_1_1exceptions_1_1ParameterNotDeclaredException.html" title="Thrown if parameter is not declared, e.g. either set or get was called without first declaring.">rclcpp::exceptions::ParameterNotDeclaredException</a> exception if any of the requested parameters have not been declared and undeclared parameters are not allowed.</p>
<p>If undeclared parameters are allowed, then a default initialized descriptor will be returned for the undeclared parameter's descriptor.</p>
<p>If the names vector is empty, then an empty vector will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>The list of parameter names to describe. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of parameter descriptors, one for each parameter given. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1exceptions_1_1ParameterNotDeclaredException.html" title="Thrown if parameter is not declared, e.g. either set or get was called without first declaring.">rclcpp::exceptions::ParameterNotDeclaredException</a></td><td>if any of the parameters have not been declared and undeclared parameters are not allowed. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the number of described parameters is more than one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9855812e7873bd35b28afa420d4242b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9855812e7873bd35b28afa420d4242b">&#9670;&nbsp;</a></span>get_parameter_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;uint8_t&gt; rclcpp::Node::get_parameter_types </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a vector of parameter types, one for each of the given names. </p>
<p>Like <a class="el" href="classrclcpp_1_1Node.html#a25890d01a2cd47ce99af887f556c529b" title="Return the parameters by the given parameter names.">get_parameters()</a>, this method may throw the <a class="el" href="classrclcpp_1_1exceptions_1_1ParameterNotDeclaredException.html" title="Thrown if parameter is not declared, e.g. either set or get was called without first declaring.">rclcpp::exceptions::ParameterNotDeclaredException</a> exception if any of the requested parameters have not been declared and undeclared parameters are not allowed.</p>
<p>If undeclared parameters are allowed, then the default type rclcpp::ParameterType::PARAMETER_NOT_SET will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>The list of parameter names to get the types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of parameter types, one for each parameter given. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1exceptions_1_1ParameterNotDeclaredException.html" title="Thrown if parameter is not declared, e.g. either set or get was called without first declaring.">rclcpp::exceptions::ParameterNotDeclaredException</a></td><td>if any of the parameters have not been declared and undeclared parameters are not allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37aa95886a706c174db77c2b160f6d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37aa95886a706c174db77c2b160f6d7d">&#9670;&nbsp;</a></span>list_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rcl_interfaces::msg::ListParametersResult rclcpp::Node::list_parameters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of parameters with any of the given prefixes, up to the given depth. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>: properly document and test this method. </dd></dl>

</div>
</div>
<a id="a0c3ad2ca5c56eb54af0227f04e943679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c3ad2ca5c56eb54af0227f04e943679">&#9670;&nbsp;</a></span>add_on_set_parameters_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OnSetParametersCallbackHandle::SharedPtr rclcpp::Node::add_on_set_parameters_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1Node.html#ab403fecdb5ec2eb9f88e3eb7ae6f6d0c">OnParametersSetCallbackType</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a callback for when parameters are being set. </p>
<p>The callback signature is designed to allow handling of any of the above <code>set_parameter*</code> or <code>declare_parameter*</code> methods, and so it takes a const reference to a vector of parameters to be set, and returns an instance of rcl_interfaces::msg::SetParametersResult to indicate whether or not the parameter should be set or not, and if not why.</p>
<p>For an example callback:</p>
<div class="fragment"><div class="line">rcl_interfaces::msg::SetParametersResult</div>
<div class="line">my_callback(<span class="keyword">const</span> std::vector&lt;rclcpp::Parameter&gt; &amp; parameters)</div>
<div class="line">{</div>
<div class="line">  rcl_interfaces::msg::SetParametersResult result;</div>
<div class="line">  result.successful = <span class="keyword">true</span>;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; parameter : parameters) {</div>
<div class="line">    <span class="keywordflow">if</span> (!some_condition) {</div>
<div class="line">      result.successful = <span class="keyword">false</span>;</div>
<div class="line">      result.reason = <span class="stringliteral">&quot;the reason it could not be allowed&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p>You can see that the SetParametersResult is a boolean flag for success and an optional reason that can be used in error reporting when it fails.</p>
<p>This allows the node developer to control which parameters may be changed.</p>
<p>It is considered bad practice to reject changes for "unknown" parameters as this prevents other parts of the node (that may be aware of these parameters) from handling them.</p>
<p>Note that the callback is called when <a class="el" href="classrclcpp_1_1Node.html#a2f2297309b4c1a2e583801fa8a6ef955" title="Declare and initialize a parameter, return the effective value.">declare_parameter()</a> and its variants are called, and so you cannot assume the parameter has been set before this callback, so when checking a new value against the existing one, you must account for the case where the parameter is not yet set.</p>
<p>Some constraints like read_only are enforced before the callback is called.</p>
<p>The callback may introspect other already set parameters (by calling any of the {get,list,describe}_parameter() methods), but may <em>not</em> modify other parameters (by calling any of the {set,declare}_parameter() methods) or modify the registered callback itself (by calling the <a class="el" href="classrclcpp_1_1Node.html#a0c3ad2ca5c56eb54af0227f04e943679" title="Add a callback for when parameters are being set.">add_on_set_parameters_callback()</a> method). If a callback tries to do any of the latter things, <a class="el" href="classrclcpp_1_1exceptions_1_1ParameterModifiedInCallbackException.html" title="Thrown if parameter is modified while in a set callback.">rclcpp::exceptions::ParameterModifiedInCallbackException</a> will be thrown.</p>
<p>The callback functions must remain valid as long as the returned smart pointer is valid. The returned smart pointer can be promoted to a shared version.</p>
<p>Resetting or letting the smart pointer go out of scope unregisters the callback. <code>remove_on_set_parameters_callback</code> can also be used.</p>
<p>The registered callbacks are called when a parameter is set. When a callback returns a not successful result, the remaining callbacks aren't called. The order of the callback is the reverse from the registration order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback to register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer. The callback is valid as long as the smart pointer is alive. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if the allocation of the OnSetParametersCallbackHandle fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15d4f7fa0ef760941b6a78f42cccb7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d4f7fa0ef760941b6a78f42cccb7e0">&#9670;&nbsp;</a></span>remove_on_set_parameters_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Node::remove_on_set_parameters_callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1Node.html#aac7e1fe50bc2683380cd9a635ac51edb">OnSetParametersCallbackHandle</a> *const&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a callback registered with <code>add_on_set_parameters_callback</code>. </p>
<p>Delete a handler returned by <code>add_on_set_parameters_callback</code>.</p>
<p>e.g.:</p>
<p><code>remove_on_set_parameters_callback(scoped_callback.get())</code></p>
<p>As an alternative, the smart pointer can be reset:</p>
<p><code>scoped_callback.reset()</code></p>
<p>Supposing that <code>scoped_callback</code> was the only owner.</p>
<p>Calling <code>remove_on_set_parameters_callback</code> more than once with the same handler, or calling it after the shared pointer has been reset is an error. Resetting or letting the smart pointer go out of scope after calling <code>remove_on_set_parameters_callback</code> is not a problem.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The callback handler to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the handler was not created with <code>add_on_set_parameters_callback</code>, or if it has been removed before. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e4302d8e28f17078cbc3b6db93c97ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4302d8e28f17078cbc3b6db93c97ba">&#9670;&nbsp;</a></span>get_node_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; rclcpp::Node::get_node_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the fully-qualified names of all available nodes. </p>
<p>The fully-qualified name includes the local namespace and name of the node. </p><dl class="section return"><dt>Returns</dt><dd>A vector of fully-qualified names of nodes. </dd></dl>

</div>
</div>
<a id="ab64ee81d61071100f222b819eab3e311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64ee81d61071100f222b819eab3e311">&#9670;&nbsp;</a></span>get_topic_names_and_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::vector&lt;std::string&gt; &gt; rclcpp::Node::get_topic_names_and_types </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a map of existing topic names to list of topic types. </p>
<dl class="section return"><dt>Returns</dt><dd>a map of existing topic names to list of topic types. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>anything that rcl_error can throw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d400bbd606a936a556b747f519eab38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d400bbd606a936a556b747f519eab38">&#9670;&nbsp;</a></span>get_service_names_and_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::vector&lt;std::string&gt; &gt; rclcpp::Node::get_service_names_and_types </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a map of existing service names to list of service types. </p>
<dl class="section return"><dt>Returns</dt><dd>a map of existing service names to list of service types. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>anything that rcl_error can throw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3df8a7d8b174f8049dfd2766f4b2eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3df8a7d8b174f8049dfd2766f4b2eb9">&#9670;&nbsp;</a></span>get_service_names_and_types_by_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::vector&lt;std::string&gt; &gt; rclcpp::Node::get_service_names_and_types_by_node </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>node_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>namespace_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a map of existing service names to list of service types for a specific node. </p>
<p>This function only considers services - not clients. The returned names are the actual names used and do not have remap rules applied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_name</td><td>name of the node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">namespace_</td><td>namespace of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a map of existing service names to list of service types. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>anything that rcl_error can throw. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8792429fa0ee5c5d7f9eca537cf4cff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8792429fa0ee5c5d7f9eca537cf4cff0">&#9670;&nbsp;</a></span>count_publishers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t rclcpp::Node::count_publishers </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of publishers created for a given topic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topic_name</td><td>the actual topic name used; it will not be automatically remapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of publishers that have been created for the given topic. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if publishers could not be counted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7aa2ed22450d2f3300ea5b879acd73b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa2ed22450d2f3300ea5b879acd73b8">&#9670;&nbsp;</a></span>count_subscribers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t rclcpp::Node::count_subscribers </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of subscribers created for a given topic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topic_name</td><td>the actual topic name used; it will not be automatically remapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of subscribers that have been created for the given topic. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if subscribers could not be counted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08220daf1d66596012e858d19efd1212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08220daf1d66596012e858d19efd1212">&#9670;&nbsp;</a></span>get_publishers_info_by_topic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classrclcpp_1_1TopicEndpointInfo.html">rclcpp::TopicEndpointInfo</a>&gt; rclcpp::Node::get_publishers_info_by_topic </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_mangle</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the topic endpoint information about publishers on a given topic. </p>
<p>The returned parameter is a list of topic endpoint information, where each item will contain the node name, node namespace, topic type, endpoint type, topic endpoint's GID, and its <a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">QoS</a> profile.</p>
<p>When the <code>no_mangle</code> parameter is <code>true</code>, the provided <code>topic_name</code> should be a valid topic name for the middleware (useful when combining ROS with native middleware (e.g. DDS) apps). When the <code>no_mangle</code> parameter is <code>false</code>, the provided <code>topic_name</code> should follow ROS topic name conventions.</p>
<p><code>topic_name</code> may be a relative, private, or fully qualified topic name. A relative or private topic will be expanded using this node's namespace and name. The queried <code>topic_name</code> is not remapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topic_name</td><td>the actual topic name used; it will not be automatically remapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_mangle</td><td>if <code>true</code>, <code>topic_name</code> needs to be a valid middleware topic name, otherwise it should be a valid ROS topic name. Defaults to <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of <a class="el" href="classrclcpp_1_1TopicEndpointInfo.html">TopicEndpointInfo</a> representing all the publishers on this topic. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidTopicNameError</td><td>if the given topic_name is invalid. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if internal error happens. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afba993c401901433b3c8647ef716c7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba993c401901433b3c8647ef716c7e4">&#9670;&nbsp;</a></span>get_subscriptions_info_by_topic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classrclcpp_1_1TopicEndpointInfo.html">rclcpp::TopicEndpointInfo</a>&gt; rclcpp::Node::get_subscriptions_info_by_topic </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_mangle</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the topic endpoint information about subscriptions on a given topic. </p>
<p>The returned parameter is a list of topic endpoint information, where each item will contain the node name, node namespace, topic type, endpoint type, topic endpoint's GID, and its <a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">QoS</a> profile.</p>
<p>When the <code>no_mangle</code> parameter is <code>true</code>, the provided <code>topic_name</code> should be a valid topic name for the middleware (useful when combining ROS with native middleware (e.g. DDS) apps). When the <code>no_mangle</code> parameter is <code>false</code>, the provided <code>topic_name</code> should follow ROS topic name conventions.</p>
<p><code>topic_name</code> may be a relative, private, or fully qualified topic name. A relative or private topic will be expanded using this node's namespace and name. The queried <code>topic_name</code> is not remapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topic_name</td><td>the actual topic name used; it will not be automatically remapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_mangle</td><td>if <code>true</code>, <code>topic_name</code> needs to be a valid middleware topic name, otherwise it should be a valid ROS topic name. Defaults to <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of <a class="el" href="classrclcpp_1_1TopicEndpointInfo.html">TopicEndpointInfo</a> representing all the subscriptions on this topic. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidTopicNameError</td><td>if the given topic_name is invalid. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if internal error happens. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e5851844ecb1794503b8fc0f9f5c898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e5851844ecb1794503b8fc0f9f5c898">&#9670;&nbsp;</a></span>get_graph_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::Event::SharedPtr rclcpp::Node::get_graph_event </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a graph event, which will be set anytime a graph change occurs. </p>

</div>
</div>
<a id="ab72e2c59951c08c515fd597bfc9e8cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab72e2c59951c08c515fd597bfc9e8cfd">&#9670;&nbsp;</a></span>wait_for_graph_change()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Node::wait_for_graph_change </td>
          <td>(</td>
          <td class="paramtype">rclcpp::Event::SharedPtr&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a graph event to occur by waiting on an <a class="el" href="classrclcpp_1_1Event.html">Event</a> to become set. </p>
<p>The given <a class="el" href="classrclcpp_1_1Event.html">Event</a> must be acquire through the <a class="el" href="classrclcpp_1_1Node.html#a9e5851844ecb1794503b8fc0f9f5c898" title="Return a graph event, which will be set anytime a graph change occurs.">get_graph_event()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>pointer to an <a class="el" href="classrclcpp_1_1Event.html">Event</a> to wait for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>nanoseconds to wait for the <a class="el" href="classrclcpp_1_1Event.html">Event</a> to change the state</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidEventError</td><td>if the given event is nullptr </td></tr>
    <tr><td class="paramname">EventNotRegisteredError</td><td>if the given event was not acquired with <a class="el" href="classrclcpp_1_1Node.html#a9e5851844ecb1794503b8fc0f9f5c898" title="Return a graph event, which will be set anytime a graph change occurs.">get_graph_event()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec0332887ae90caed727e5025cb62195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0332887ae90caed727e5025cb62195">&#9670;&nbsp;</a></span>get_clock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::Clock::SharedPtr rclcpp::Node::get_clock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a clock as a non-const shared pointer which is managed by the node. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeClock.html#a0998d27ad1fceaa0af4f101f54177f1a" title="Get a clock which will be kept up to date by the node.">rclcpp::node_interfaces::NodeClock::get_clock</a> </dd></dl>

</div>
</div>
<a id="a2c725f0bb2e36943ca5c0255ad0bc0cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c725f0bb2e36943ca5c0255ad0bc0cf">&#9670;&nbsp;</a></span>get_clock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::Clock::ConstSharedPtr rclcpp::Node::get_clock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a clock as a const shared pointer which is managed by the node. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeClock.html#a0998d27ad1fceaa0af4f101f54177f1a" title="Get a clock which will be kept up to date by the node.">rclcpp::node_interfaces::NodeClock::get_clock</a> </dd></dl>

</div>
</div>
<a id="a1db9cec1af19a994b3f1dad2059d2707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db9cec1af19a994b3f1dad2059d2707">&#9670;&nbsp;</a></span>now()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1Time.html">Time</a> rclcpp::Node::now </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns current time from the time source specified by clock_type. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Clock.html#a6375208429c40bd9d6e84b2b32557182">rclcpp::Clock::now</a> </dd></dl>

</div>
</div>
<a id="a37e5b136ef0a29853e01d5cecb8e4690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e5b136ef0a29853e01d5cecb8e4690">&#9670;&nbsp;</a></span>get_node_base_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr rclcpp::Node::get_node_base_interface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a>'s internal NodeBaseInterface implementation. </p>

</div>
</div>
<a id="a5495b9faae261feed33d8d8828840709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5495b9faae261feed33d8d8828840709">&#9670;&nbsp;</a></span>get_node_clock_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::node_interfaces::NodeClockInterface::SharedPtr rclcpp::Node::get_node_clock_interface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a>'s internal NodeClockInterface implementation. </p>

</div>
</div>
<a id="a2378e5b1486e58afdead52fa14928c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2378e5b1486e58afdead52fa14928c2b">&#9670;&nbsp;</a></span>get_node_graph_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::node_interfaces::NodeGraphInterface::SharedPtr rclcpp::Node::get_node_graph_interface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a>'s internal NodeGraphInterface implementation. </p>

</div>
</div>
<a id="af05394f5147dd263af2df15a99f5a4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05394f5147dd263af2df15a99f5a4bb">&#9670;&nbsp;</a></span>get_node_logging_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::node_interfaces::NodeLoggingInterface::SharedPtr rclcpp::Node::get_node_logging_interface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a>'s internal NodeLoggingInterface implementation. </p>

</div>
</div>
<a id="aa28869f473b562a08aa581fc7deae867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa28869f473b562a08aa581fc7deae867">&#9670;&nbsp;</a></span>get_node_timers_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::node_interfaces::NodeTimersInterface::SharedPtr rclcpp::Node::get_node_timers_interface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a>'s internal NodeTimersInterface implementation. </p>

</div>
</div>
<a id="a5ae76be5bac60aea82486a9b4c6b2ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae76be5bac60aea82486a9b4c6b2ff5">&#9670;&nbsp;</a></span>get_node_topics_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::node_interfaces::NodeTopicsInterface::SharedPtr rclcpp::Node::get_node_topics_interface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a>'s internal NodeTopicsInterface implementation. </p>

</div>
</div>
<a id="a588cb7990fd658e58c532d65e4872df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588cb7990fd658e58c532d65e4872df3">&#9670;&nbsp;</a></span>get_node_services_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::node_interfaces::NodeServicesInterface::SharedPtr rclcpp::Node::get_node_services_interface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a>'s internal NodeServicesInterface implementation. </p>

</div>
</div>
<a id="a6708bb439e1d3bb1ea44fbae50e460b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6708bb439e1d3bb1ea44fbae50e460b2">&#9670;&nbsp;</a></span>get_node_waitables_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::node_interfaces::NodeWaitablesInterface::SharedPtr rclcpp::Node::get_node_waitables_interface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a>'s internal NodeWaitablesInterface implementation. </p>

</div>
</div>
<a id="ab6272f2facdfb35f0ef9ce01ffedeec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6272f2facdfb35f0ef9ce01ffedeec9">&#9670;&nbsp;</a></span>get_node_parameters_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::node_interfaces::NodeParametersInterface::SharedPtr rclcpp::Node::get_node_parameters_interface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a>'s internal NodeParametersInterface implementation. </p>

</div>
</div>
<a id="afa70b6e8bd3ecc39c5928d822024db39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa70b6e8bd3ecc39c5928d822024db39">&#9670;&nbsp;</a></span>get_node_time_source_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::node_interfaces::NodeTimeSourceInterface::SharedPtr rclcpp::Node::get_node_time_source_interface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a>'s internal NodeTimeSourceInterface implementation. </p>

</div>
</div>
<a id="aa9ac5055f3f7a3537642482bd505d4bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ac5055f3f7a3537642482bd505d4bd">&#9670;&nbsp;</a></span>get_sub_namespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; rclcpp::Node::get_sub_namespace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the sub-namespace, if this is a sub-node, otherwise an empty string. </p>
<p>The returned sub-namespace is either the accumulated sub-namespaces which were given to one-to-many <a class="el" href="classrclcpp_1_1Node.html#a1df8e4507d17a503630317432449d69d" title="Create a sub-node, which will extend the namespace of all entities created with it.">create_sub_node()</a> calls, or an empty string if this is an original node instance, i.e. not a sub-node.</p>
<p>For example, consider:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> node = std::make_shared&lt;rclcpp::Node&gt;(<span class="stringliteral">&quot;my_node&quot;</span>, <span class="stringliteral">&quot;my_ns&quot;</span>);</div>
<div class="line">node-&gt;get_sub_namespace();  <span class="comment">// -&gt; &quot;&quot;</span></div>
<div class="line"><span class="keyword">auto</span> sub_node1 = node-&gt;create_sub_node(<span class="stringliteral">&quot;a&quot;</span>);</div>
<div class="line">sub_node1-&gt;get_sub_namespace();  <span class="comment">// -&gt; &quot;a&quot;</span></div>
<div class="line"><span class="keyword">auto</span> sub_node2 = sub_node1-&gt;create_sub_node(<span class="stringliteral">&quot;b&quot;</span>);</div>
<div class="line">sub_node2-&gt;get_sub_namespace();  <span class="comment">// -&gt; &quot;a/b&quot;</span></div>
<div class="line"><span class="keyword">auto</span> sub_node3 = node-&gt;create_sub_node(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line">sub_node3-&gt;get_sub_namespace();  <span class="comment">// -&gt; &quot;foo&quot;</span></div>
<div class="line">node-&gt;get_sub_namespace();  <span class="comment">// -&gt; &quot;&quot;</span></div>
</div><!-- fragment --><p><a class="el" href="classrclcpp_1_1Node.html#a7be04e55e2934e05df992b188d9dce6d" title="Get the namespace of the node.">get_namespace()</a> will return the original node namespace, and will not include the sub-namespace if one exists. To get that you need to call the <a class="el" href="classrclcpp_1_1Node.html#afe4790bba38942b795d24b6ccb3e9c5a" title="Return the effective namespace that is used when creating entities.">get_effective_namespace()</a> method.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Node.html#a7be04e55e2934e05df992b188d9dce6d" title="Get the namespace of the node.">get_namespace()</a> </dd>
<dd>
<a class="el" href="classrclcpp_1_1Node.html#afe4790bba38942b795d24b6ccb3e9c5a" title="Return the effective namespace that is used when creating entities.">get_effective_namespace()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the sub-namespace string, not including the node's original namespace </dd></dl>

</div>
</div>
<a id="afe4790bba38942b795d24b6ccb3e9c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4790bba38942b795d24b6ccb3e9c5a">&#9670;&nbsp;</a></span>get_effective_namespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; rclcpp::Node::get_effective_namespace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the effective namespace that is used when creating entities. </p>
<p>The returned namespace is a concatenation of the node namespace and the accumulated sub-namespaces, which is used as the namespace when creating entities which have relative names.</p>
<p>For example, consider:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> node = std::make_shared&lt;rclcpp::Node&gt;(<span class="stringliteral">&quot;my_node&quot;</span>, <span class="stringliteral">&quot;my_ns&quot;</span>);</div>
<div class="line">node-&gt;get_effective_namespace();  <span class="comment">// -&gt; &quot;/my_ns&quot;</span></div>
<div class="line"><span class="keyword">auto</span> sub_node1 = node-&gt;create_sub_node(<span class="stringliteral">&quot;a&quot;</span>);</div>
<div class="line">sub_node1-&gt;get_effective_namespace();  <span class="comment">// -&gt; &quot;/my_ns/a&quot;</span></div>
<div class="line"><span class="keyword">auto</span> sub_node2 = sub_node1-&gt;create_sub_node(<span class="stringliteral">&quot;b&quot;</span>);</div>
<div class="line">sub_node2-&gt;get_effective_namespace();  <span class="comment">// -&gt; &quot;/my_ns/a/b&quot;</span></div>
<div class="line"><span class="keyword">auto</span> sub_node3 = node-&gt;create_sub_node(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line">sub_node3-&gt;get_effective_namespace();  <span class="comment">// -&gt; &quot;/my_ns/foo&quot;</span></div>
<div class="line">node-&gt;get_effective_namespace();  <span class="comment">// -&gt; &quot;/my_ns&quot;</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Node.html#a7be04e55e2934e05df992b188d9dce6d" title="Get the namespace of the node.">get_namespace()</a> </dd>
<dd>
<a class="el" href="classrclcpp_1_1Node.html#aa9ac5055f3f7a3537642482bd505d4bd" title="Return the sub-namespace, if this is a sub-node, otherwise an empty string.">get_sub_namespace()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the sub-namespace string, not including the node's original namespace </dd></dl>

</div>
</div>
<a id="a1df8e4507d17a503630317432449d69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df8e4507d17a503630317432449d69d">&#9670;&nbsp;</a></span>create_sub_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::Node::SharedPtr rclcpp::Node::create_sub_node </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sub_namespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a sub-node, which will extend the namespace of all entities created with it. </p>
<p>A sub-node (short for subordinate node) is an instance of this class which has been created using an existing instance of this class, but which has an additional sub-namespace (short for subordinate namespace) associated with it. The sub-namespace will extend the node's namespace for the purpose of creating additional entities, such as Publishers, Subscriptions, <a class="el" href="classrclcpp_1_1Service.html">Service</a> Clients and Servers, and so on.</p>
<p>By default, when an instance of this class is created using one of the public constructors, it has no sub-namespace associated with it, and therefore is not a sub-node. That "normal" node instance may, however, be used to create further instances of this class, based on the original instance, which have an additional sub-namespace associated with them. This may be done by using this method, <a class="el" href="classrclcpp_1_1Node.html#a1df8e4507d17a503630317432449d69d" title="Create a sub-node, which will extend the namespace of all entities created with it.">create_sub_node()</a>.</p>
<p>Furthermore, a sub-node may be used to create additional sub-node's, in which case the sub-namespace passed to this function will further extend the sub-namespace of the existing sub-node. See <a class="el" href="classrclcpp_1_1Node.html#aa9ac5055f3f7a3537642482bd505d4bd" title="Return the sub-namespace, if this is a sub-node, otherwise an empty string.">get_sub_namespace()</a> and <a class="el" href="classrclcpp_1_1Node.html#afe4790bba38942b795d24b6ccb3e9c5a" title="Return the effective namespace that is used when creating entities.">get_effective_namespace()</a> for examples.</p>
<p>Note that entities which use absolute names are not affected by any namespaces, neither the normal node namespace nor any sub-namespace. Note also that the fully qualified node name is unaffected by a sub-namespace.</p>
<p>The sub-namespace should be relative, and an exception will be thrown if the sub-namespace is absolute, i.e. if it starts with a leading '/'.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Node.html#aa9ac5055f3f7a3537642482bd505d4bd" title="Return the sub-namespace, if this is a sub-node, otherwise an empty string.">get_sub_namespace()</a> </dd>
<dd>
<a class="el" href="classrclcpp_1_1Node.html#afe4790bba38942b795d24b6ccb3e9c5a" title="Return the effective namespace that is used when creating entities.">get_effective_namespace()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sub_namespace</td><td>sub-namespace of the sub-node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>newly created sub-node </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NameValidationError</td><td>if the sub-namespace is absolute, i.e. starts with a leading '/'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53b6a37589d4371c9e0675acfc0f197a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b6a37589d4371c9e0675acfc0f197a">&#9670;&nbsp;</a></span>get_node_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classrclcpp_1_1NodeOptions.html">rclcpp::NodeOptions</a>&amp; rclcpp::Node::get_node_options </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classrclcpp_1_1NodeOptions.html" title="Encapsulation of options for node initialization.">NodeOptions</a> used when creating this node. </p>

</div>
</div>
<a id="ac9aed5a03eb2420254745528a7d20443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9aed5a03eb2420254745528a7d20443">&#9670;&nbsp;</a></span>create_client() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ServiceT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1Client.html">Client</a>&lt;ServiceT&gt;::SharedPtr rclcpp::Node::create_client </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rmw_qos_profile_t &amp;&#160;</td>
          <td class="paramname"><em>qos_profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rclcpp::CallbackGroup::SharedPtr&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/rclcpp/<a class="el" href="node_8hpp_source.html">node.hpp</a></li>
<li>include/rclcpp/<a class="el" href="node__impl_8hpp_source.html">node_impl.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
