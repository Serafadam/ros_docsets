<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rclcpp: rclcpp::SubscriptionBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rclcpp
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C++ ROS Client Library API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerclcpp.html">rclcpp</a></li><li class="navelem"><a class="el" href="classrclcpp_1_1SubscriptionBase.html">SubscriptionBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classrclcpp_1_1SubscriptionBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rclcpp::SubscriptionBase Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="subscription__base_8hpp_source.html">subscription_base.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rclcpp::SubscriptionBase:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1SubscriptionBase__inherit__graph.png" border="0" usemap="#arclcpp_1_1SubscriptionBase_inherit__map" alt="Inheritance graph"/></div>
<map name="arclcpp_1_1SubscriptionBase_inherit__map" id="arclcpp_1_1SubscriptionBase_inherit__map">
<area shape="rect" title=" " alt="" coords="287,85,468,112"/>
<area shape="rect" href="classrclcpp_1_1Subscription.html" title=" " alt="" coords="543,5,705,61"/>
<area shape="rect" href="classrclcpp_1_1GenericSubscription.html" title="Subscription for serialized messages whose type is not known at compile time." alt="" coords="525,85,723,112"/>
<area shape="rect" href="classrclcpp_1_1Subscription.html" title="Subscription implementation, templated on the type of message this subscription receives." alt="" coords="516,137,732,207"/>
<area shape="rect" title=" " alt="" coords="5,78,239,119"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for rclcpp::SubscriptionBase:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1SubscriptionBase__coll__graph.png" border="0" usemap="#arclcpp_1_1SubscriptionBase_coll__map" alt="Collaboration graph"/></div>
<map name="arclcpp_1_1SubscriptionBase_coll__map" id="arclcpp_1_1SubscriptionBase_coll__map">
<area shape="rect" title=" " alt="" coords="379,78,560,105"/>
<area shape="rect" title=" " alt="" coords="5,5,239,47"/>
<area shape="rect" href="classrclcpp_1_1node__interfaces_1_1NodeBaseInterface.html" title="Pure virtual interface class for the NodeBase part of the Node API." alt="" coords="35,71,209,112"/>
<area shape="rect" href="classrclcpp_1_1Logger.html" title=" " alt="" coords="65,137,179,163"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5acbc58580037d661aa735fddad70ba9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a5acbc58580037d661aa735fddad70ba9">IntraProcessManagerWeakPtr</a> = std::weak_ptr&lt; <a class="el" href="classrclcpp_1_1experimental_1_1IntraProcessManager.html">rclcpp::experimental::IntraProcessManager</a> &gt;</td></tr>
<tr class="separator:a5acbc58580037d661aa735fddad70ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9f68a3c9cf39f5d8ddd0e318e23a0ada"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a9f68a3c9cf39f5d8ddd0e318e23a0ada">SubscriptionBase</a> (<a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeBaseInterface.html">rclcpp::node_interfaces::NodeBaseInterface</a> *node_base, const rosidl_message_type_support_t &amp;type_support_handle, const std::string &amp;topic_name, const rcl_subscription_options_t &amp;subscription_options, bool <a class="el" href="classrclcpp_1_1SubscriptionBase.html#a03df6a21a75e1eb4619a31b1b0ef852a">is_serialized</a>=false)</td></tr>
<tr class="memdesc:a9f68a3c9cf39f5d8ddd0e318e23a0ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classrclcpp_1_1SubscriptionBase.html#a9f68a3c9cf39f5d8ddd0e318e23a0ada">More...</a><br /></td></tr>
<tr class="separator:a9f68a3c9cf39f5d8ddd0e318e23a0ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b8cda0f87d9c1200b32800a39c0363"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a52b8cda0f87d9c1200b32800a39c0363">~SubscriptionBase</a> ()</td></tr>
<tr class="memdesc:a52b8cda0f87d9c1200b32800a39c0363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classrclcpp_1_1SubscriptionBase.html#a52b8cda0f87d9c1200b32800a39c0363">More...</a><br /></td></tr>
<tr class="separator:a52b8cda0f87d9c1200b32800a39c0363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b149cae2bcec14c99ee32828ef7d8c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a71b149cae2bcec14c99ee32828ef7d8c">get_topic_name</a> () const</td></tr>
<tr class="memdesc:a71b149cae2bcec14c99ee32828ef7d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the topic that this subscription is subscribed on.  <a href="classrclcpp_1_1SubscriptionBase.html#a71b149cae2bcec14c99ee32828ef7d8c">More...</a><br /></td></tr>
<tr class="separator:a71b149cae2bcec14c99ee32828ef7d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819a46b4c3ffba9bef8d05ad7eab7344"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; rcl_subscription_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a819a46b4c3ffba9bef8d05ad7eab7344">get_subscription_handle</a> ()</td></tr>
<tr class="separator:a819a46b4c3ffba9bef8d05ad7eab7344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab065197aa67d19cf4eba0688ffedfccf"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const rcl_subscription_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#ab065197aa67d19cf4eba0688ffedfccf">get_subscription_handle</a> () const</td></tr>
<tr class="separator:ab065197aa67d19cf4eba0688ffedfccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fd6e4355071cdd5aa6b4c8e623d4cc"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; rcl_subscription_event_type_t, std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1QOSEventHandlerBase.html">rclcpp::QOSEventHandlerBase</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#ac6fd6e4355071cdd5aa6b4c8e623d4cc">get_event_handlers</a> () const</td></tr>
<tr class="memdesc:ac6fd6e4355071cdd5aa6b4c8e623d4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the <a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">QoS</a> event handlers associated with this subscription.  <a href="classrclcpp_1_1SubscriptionBase.html#ac6fd6e4355071cdd5aa6b4c8e623d4cc">More...</a><br /></td></tr>
<tr class="separator:ac6fd6e4355071cdd5aa6b4c8e623d4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdaeff8614370f5e8b896f815928601a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#abdaeff8614370f5e8b896f815928601a">get_actual_qos</a> () const</td></tr>
<tr class="memdesc:abdaeff8614370f5e8b896f815928601a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the actual <a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">QoS</a> settings, after the defaults have been determined.  <a href="classrclcpp_1_1SubscriptionBase.html#abdaeff8614370f5e8b896f815928601a">More...</a><br /></td></tr>
<tr class="separator:abdaeff8614370f5e8b896f815928601a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee028d0dc23bcd2c0bfded09b5012cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#aaee028d0dc23bcd2c0bfded09b5012cb">take_type_erased</a> (void *message_out, <a class="el" href="classrclcpp_1_1MessageInfo.html">rclcpp::MessageInfo</a> &amp;message_info_out)</td></tr>
<tr class="memdesc:aaee028d0dc23bcd2c0bfded09b5012cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the next inter-process message from the subscription as a type erased pointer.  <a href="classrclcpp_1_1SubscriptionBase.html#aaee028d0dc23bcd2c0bfded09b5012cb">More...</a><br /></td></tr>
<tr class="separator:aaee028d0dc23bcd2c0bfded09b5012cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ac489152fd7aa9ca31610cf6fb14dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a25ac489152fd7aa9ca31610cf6fb14dd">take_serialized</a> (<a class="el" href="classrclcpp_1_1SerializedMessage.html">rclcpp::SerializedMessage</a> &amp;message_out, <a class="el" href="classrclcpp_1_1MessageInfo.html">rclcpp::MessageInfo</a> &amp;message_info_out)</td></tr>
<tr class="memdesc:a25ac489152fd7aa9ca31610cf6fb14dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the next inter-process message, in its serialized form, from the subscription.  <a href="classrclcpp_1_1SubscriptionBase.html#a25ac489152fd7aa9ca31610cf6fb14dd">More...</a><br /></td></tr>
<tr class="separator:a25ac489152fd7aa9ca31610cf6fb14dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e353f7653570b836051428f02a2171"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a82e353f7653570b836051428f02a2171">create_message</a> ()=0</td></tr>
<tr class="memdesc:a82e353f7653570b836051428f02a2171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Borrow a new message.  <a href="classrclcpp_1_1SubscriptionBase.html#a82e353f7653570b836051428f02a2171">More...</a><br /></td></tr>
<tr class="separator:a82e353f7653570b836051428f02a2171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44968e2dc8ae425dfc85c1882f67df7"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1SerializedMessage.html">rclcpp::SerializedMessage</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#ab44968e2dc8ae425dfc85c1882f67df7">create_serialized_message</a> ()=0</td></tr>
<tr class="memdesc:ab44968e2dc8ae425dfc85c1882f67df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Borrow a new serialized message.  <a href="classrclcpp_1_1SubscriptionBase.html#ab44968e2dc8ae425dfc85c1882f67df7">More...</a><br /></td></tr>
<tr class="separator:ab44968e2dc8ae425dfc85c1882f67df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9859bf785042e896c8a9962ead8f89"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a9e9859bf785042e896c8a9962ead8f89">handle_message</a> (std::shared_ptr&lt; void &gt; &amp;message, const <a class="el" href="classrclcpp_1_1MessageInfo.html">rclcpp::MessageInfo</a> &amp;message_info)=0</td></tr>
<tr class="memdesc:a9e9859bf785042e896c8a9962ead8f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if we need to handle the message, and execute the callback if we do.  <a href="classrclcpp_1_1SubscriptionBase.html#a9e9859bf785042e896c8a9962ead8f89">More...</a><br /></td></tr>
<tr class="separator:a9e9859bf785042e896c8a9962ead8f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d583c8c1d5c667b03c4bc08f05eadd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#aa4d583c8c1d5c667b03c4bc08f05eadd">handle_serialized_message</a> (const std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1SerializedMessage.html">rclcpp::SerializedMessage</a> &gt; &amp;serialized_message, const <a class="el" href="classrclcpp_1_1MessageInfo.html">rclcpp::MessageInfo</a> &amp;message_info)=0</td></tr>
<tr class="separator:aa4d583c8c1d5c667b03c4bc08f05eadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b7009c6a6b7f2363009f154243c86e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#af6b7009c6a6b7f2363009f154243c86e">handle_loaned_message</a> (void *loaned_message, const <a class="el" href="classrclcpp_1_1MessageInfo.html">rclcpp::MessageInfo</a> &amp;message_info)=0</td></tr>
<tr class="separator:af6b7009c6a6b7f2363009f154243c86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44162910e6e0c184eaa1bf729287c55"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#ac44162910e6e0c184eaa1bf729287c55">return_message</a> (std::shared_ptr&lt; void &gt; &amp;message)=0</td></tr>
<tr class="memdesc:ac44162910e6e0c184eaa1bf729287c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the message borrowed in create_message.  <a href="classrclcpp_1_1SubscriptionBase.html#ac44162910e6e0c184eaa1bf729287c55">More...</a><br /></td></tr>
<tr class="separator:ac44162910e6e0c184eaa1bf729287c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6b7186400304c5a7f4fd97198442a6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a9b6b7186400304c5a7f4fd97198442a6">return_serialized_message</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1SerializedMessage.html">rclcpp::SerializedMessage</a> &gt; &amp;message)=0</td></tr>
<tr class="memdesc:a9b6b7186400304c5a7f4fd97198442a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the message borrowed in create_serialized_message.  <a href="classrclcpp_1_1SubscriptionBase.html#a9b6b7186400304c5a7f4fd97198442a6">More...</a><br /></td></tr>
<tr class="separator:a9b6b7186400304c5a7f4fd97198442a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1640e5f85ee0117f55f69b435723070"><td class="memItemLeft" align="right" valign="top">const rosidl_message_type_support_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#aa1640e5f85ee0117f55f69b435723070">get_message_type_support_handle</a> () const</td></tr>
<tr class="separator:aa1640e5f85ee0117f55f69b435723070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03df6a21a75e1eb4619a31b1b0ef852a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a03df6a21a75e1eb4619a31b1b0ef852a">is_serialized</a> () const</td></tr>
<tr class="memdesc:a03df6a21a75e1eb4619a31b1b0ef852a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if the subscription is serialized.  <a href="classrclcpp_1_1SubscriptionBase.html#a03df6a21a75e1eb4619a31b1b0ef852a">More...</a><br /></td></tr>
<tr class="separator:a03df6a21a75e1eb4619a31b1b0ef852a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f61104666e697839925e0edc060359a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a0f61104666e697839925e0edc060359a">get_publisher_count</a> () const</td></tr>
<tr class="memdesc:a0f61104666e697839925e0edc060359a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get matching publisher count.  <a href="classrclcpp_1_1SubscriptionBase.html#a0f61104666e697839925e0edc060359a">More...</a><br /></td></tr>
<tr class="separator:a0f61104666e697839925e0edc060359a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec59d8a5befb5d79c33b8701c86302bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#aec59d8a5befb5d79c33b8701c86302bf">can_loan_messages</a> () const</td></tr>
<tr class="memdesc:aec59d8a5befb5d79c33b8701c86302bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if subscription instance can loan messages.  <a href="classrclcpp_1_1SubscriptionBase.html#aec59d8a5befb5d79c33b8701c86302bf">More...</a><br /></td></tr>
<tr class="separator:aec59d8a5befb5d79c33b8701c86302bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d01277c7ddfe0c33074154d1385c9c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a1d01277c7ddfe0c33074154d1385c9c6">setup_intra_process</a> (uint64_t intra_process_subscription_id, <a class="el" href="classrclcpp_1_1SubscriptionBase.html#a5acbc58580037d661aa735fddad70ba9">IntraProcessManagerWeakPtr</a> weak_ipm)</td></tr>
<tr class="memdesc:a1d01277c7ddfe0c33074154d1385c9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implemenation detail.  <a href="classrclcpp_1_1SubscriptionBase.html#a1d01277c7ddfe0c33074154d1385c9c6">More...</a><br /></td></tr>
<tr class="separator:a1d01277c7ddfe0c33074154d1385c9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c46f29106172b169769900e1ba63341"><td class="memItemLeft" align="right" valign="top">rclcpp::Waitable::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a1c46f29106172b169769900e1ba63341">get_intra_process_waitable</a> () const</td></tr>
<tr class="memdesc:a1c46f29106172b169769900e1ba63341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the waitable for intra-process.  <a href="classrclcpp_1_1SubscriptionBase.html#a1c46f29106172b169769900e1ba63341">More...</a><br /></td></tr>
<tr class="separator:a1c46f29106172b169769900e1ba63341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb36042e8da7c498f881b7581feba649"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#afb36042e8da7c498f881b7581feba649">exchange_in_use_by_wait_set_state</a> (void *pointer_to_subscription_part, bool in_use_state)</td></tr>
<tr class="memdesc:afb36042e8da7c498f881b7581feba649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange state of whether or not a part of the subscription is used by a wait set.  <a href="classrclcpp_1_1SubscriptionBase.html#afb36042e8da7c498f881b7581feba649">More...</a><br /></td></tr>
<tr class="separator:afb36042e8da7c498f881b7581feba649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364fdf5cb7779b5945d05b5dedf08697"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classrclcpp_1_1NetworkFlowEndpoint.html">rclcpp::NetworkFlowEndpoint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a364fdf5cb7779b5945d05b5dedf08697">get_network_flow_endpoints</a> () const</td></tr>
<tr class="memdesc:a364fdf5cb7779b5945d05b5dedf08697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get network flow endpoints.  <a href="classrclcpp_1_1SubscriptionBase.html#a364fdf5cb7779b5945d05b5dedf08697">More...</a><br /></td></tr>
<tr class="separator:a364fdf5cb7779b5945d05b5dedf08697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521736fb9ae74f0ae6c206d596387cd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a521736fb9ae74f0ae6c206d596387cd5">set_on_new_message_callback</a> (std::function&lt; void(size_t)&gt; callback)</td></tr>
<tr class="memdesc:a521736fb9ae74f0ae6c206d596387cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a callback to be called when each new message is received.  <a href="classrclcpp_1_1SubscriptionBase.html#a521736fb9ae74f0ae6c206d596387cd5">More...</a><br /></td></tr>
<tr class="separator:a521736fb9ae74f0ae6c206d596387cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98435bc530dce9856b0e54396bd2feff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a98435bc530dce9856b0e54396bd2feff">clear_on_new_message_callback</a> ()</td></tr>
<tr class="memdesc:a98435bc530dce9856b0e54396bd2feff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unset the callback registered for new messages, if any.  <a href="classrclcpp_1_1SubscriptionBase.html#a98435bc530dce9856b0e54396bd2feff">More...</a><br /></td></tr>
<tr class="separator:a98435bc530dce9856b0e54396bd2feff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ed26098c94e49f38e82281e5cf1a74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a30ed26098c94e49f38e82281e5cf1a74">set_on_new_intra_process_message_callback</a> (std::function&lt; void(size_t)&gt; callback)</td></tr>
<tr class="memdesc:a30ed26098c94e49f38e82281e5cf1a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a callback to be called when each new intra-process message is received.  <a href="classrclcpp_1_1SubscriptionBase.html#a30ed26098c94e49f38e82281e5cf1a74">More...</a><br /></td></tr>
<tr class="separator:a30ed26098c94e49f38e82281e5cf1a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed55624362036446169c4c810c27c57e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#aed55624362036446169c4c810c27c57e">clear_on_new_intra_process_message_callback</a> ()</td></tr>
<tr class="memdesc:aed55624362036446169c4c810c27c57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unset the callback registered for new intra-process messages, if any.  <a href="classrclcpp_1_1SubscriptionBase.html#aed55624362036446169c4c810c27c57e">More...</a><br /></td></tr>
<tr class="separator:aed55624362036446169c4c810c27c57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670ff66837efc2c9f6d12b9db5e10623"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a670ff66837efc2c9f6d12b9db5e10623">set_on_new_qos_event_callback</a> (std::function&lt; void(size_t)&gt; callback, rcl_subscription_event_type_t event_type)</td></tr>
<tr class="memdesc:a670ff66837efc2c9f6d12b9db5e10623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a callback to be called when each new qos event instance occurs.  <a href="classrclcpp_1_1SubscriptionBase.html#a670ff66837efc2c9f6d12b9db5e10623">More...</a><br /></td></tr>
<tr class="separator:a670ff66837efc2c9f6d12b9db5e10623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc38e749f90df367503a9ddc7c87941"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#abfc38e749f90df367503a9ddc7c87941">clear_on_new_qos_event_callback</a> (rcl_subscription_event_type_t event_type)</td></tr>
<tr class="memdesc:abfc38e749f90df367503a9ddc7c87941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unset the callback registered for new qos events, if any.  <a href="classrclcpp_1_1SubscriptionBase.html#abfc38e749f90df367503a9ddc7c87941">More...</a><br /></td></tr>
<tr class="separator:abfc38e749f90df367503a9ddc7c87941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3396d53d07b0e5a9c8329aaa2059e36"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#ab3396d53d07b0e5a9c8329aaa2059e36">is_cft_enabled</a> () const</td></tr>
<tr class="memdesc:ab3396d53d07b0e5a9c8329aaa2059e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if content filtered topic feature of the subscription instance is enabled.  <a href="classrclcpp_1_1SubscriptionBase.html#ab3396d53d07b0e5a9c8329aaa2059e36">More...</a><br /></td></tr>
<tr class="separator:ab3396d53d07b0e5a9c8329aaa2059e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9ba7854936b7e38e03505aef318680"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a8b9ba7854936b7e38e03505aef318680">set_content_filter</a> (const std::string &amp;filter_expression, const std::vector&lt; std::string &gt; &amp;expression_parameters={})</td></tr>
<tr class="memdesc:a8b9ba7854936b7e38e03505aef318680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the filter expression and expression parameters for the subscription.  <a href="classrclcpp_1_1SubscriptionBase.html#a8b9ba7854936b7e38e03505aef318680">More...</a><br /></td></tr>
<tr class="separator:a8b9ba7854936b7e38e03505aef318680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b02ecef0eeeb3c3c017f34cd799ec6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrclcpp_1_1ContentFilterOptions.html">rclcpp::ContentFilterOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a4b02ecef0eeeb3c3c017f34cd799ec6b">get_content_filter</a> () const</td></tr>
<tr class="memdesc:a4b02ecef0eeeb3c3c017f34cd799ec6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the filter expression and expression parameters for the subscription.  <a href="classrclcpp_1_1SubscriptionBase.html#a4b02ecef0eeeb3c3c017f34cd799ec6b">More...</a><br /></td></tr>
<tr class="separator:a4b02ecef0eeeb3c3c017f34cd799ec6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9f57c010a428149762b8165ca5438619"><td class="memTemplParams" colspan="2">template&lt;typename EventCallbackT &gt; </td></tr>
<tr class="memitem:a9f57c010a428149762b8165ca5438619"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a9f57c010a428149762b8165ca5438619">add_event_handler</a> (const EventCallbackT &amp;callback, const rcl_subscription_event_type_t event_type)</td></tr>
<tr class="separator:a9f57c010a428149762b8165ca5438619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537c2376954a0a29aa8a5ef3f1cfe9f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a537c2376954a0a29aa8a5ef3f1cfe9f7">default_incompatible_qos_callback</a> (<a class="el" href="namespacerclcpp.html#a26c69f1ce0937b36bc3915e989fb9faf">QOSRequestedIncompatibleQoSInfo</a> &amp;info) const</td></tr>
<tr class="separator:a537c2376954a0a29aa8a5ef3f1cfe9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ade691372f06d72bbe36fd133b260b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a99ade691372f06d72bbe36fd133b260b">matches_any_intra_process_publishers</a> (const rmw_gid_t *sender_gid) const</td></tr>
<tr class="separator:a99ade691372f06d72bbe36fd133b260b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed8917fb3bc13c76aa814bebeddb7a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#aeed8917fb3bc13c76aa814bebeddb7a9">set_on_new_message_callback</a> (rcl_event_callback_t callback, const void *user_data)</td></tr>
<tr class="separator:aeed8917fb3bc13c76aa814bebeddb7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a020f78aa2f16e4f01be1a6dc6826d32c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeBaseInterface.html">rclcpp::node_interfaces::NodeBaseInterface</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a020f78aa2f16e4f01be1a6dc6826d32c">node_base_</a></td></tr>
<tr class="separator:a020f78aa2f16e4f01be1a6dc6826d32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fe91f64668b491050809168da7b101"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; rcl_node_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a83fe91f64668b491050809168da7b101">node_handle_</a></td></tr>
<tr class="separator:a83fe91f64668b491050809168da7b101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86dccb346d0f8442dd7add518bcbc648"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; rcl_subscription_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a86dccb346d0f8442dd7add518bcbc648">subscription_handle_</a></td></tr>
<tr class="separator:a86dccb346d0f8442dd7add518bcbc648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7897b9def45164032b896f1f685ef24"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; rcl_subscription_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#ad7897b9def45164032b896f1f685ef24">intra_process_subscription_handle_</a></td></tr>
<tr class="separator:ad7897b9def45164032b896f1f685ef24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072dfab20f412a16383f44347ff3a77f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1Logger.html">rclcpp::Logger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a072dfab20f412a16383f44347ff3a77f">node_logger_</a></td></tr>
<tr class="separator:a072dfab20f412a16383f44347ff3a77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a670e7f2ffd005d54a06d48a63ccf2c"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; rcl_subscription_event_type_t, std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1QOSEventHandlerBase.html">rclcpp::QOSEventHandlerBase</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a1a670e7f2ffd005d54a06d48a63ccf2c">event_handlers_</a></td></tr>
<tr class="separator:a1a670e7f2ffd005d54a06d48a63ccf2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2b849f3a01c83d1ae56d372c87a35d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a3e2b849f3a01c83d1ae56d372c87a35d">use_intra_process_</a></td></tr>
<tr class="separator:a3e2b849f3a01c83d1ae56d372c87a35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a63c78489d556b95530b722ae80a1d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a5acbc58580037d661aa735fddad70ba9">IntraProcessManagerWeakPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a9a63c78489d556b95530b722ae80a1d5">weak_ipm_</a></td></tr>
<tr class="separator:a9a63c78489d556b95530b722ae80a1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e75ff6f8331e308cdb0c96fda52706"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a56e75ff6f8331e308cdb0c96fda52706">intra_process_subscription_id_</a></td></tr>
<tr class="separator:a56e75ff6f8331e308cdb0c96fda52706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa992ad92d16db051a81b9c4819d1e3ac"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html">rclcpp::experimental::SubscriptionIntraProcessBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#aa992ad92d16db051a81b9c4819d1e3ac">subscription_intra_process_</a></td></tr>
<tr class="separator:aa992ad92d16db051a81b9c4819d1e3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Virtual base class for subscriptions. This pattern allows us to iterate over different template specializations of <a class="el" href="classrclcpp_1_1Subscription.html" title="Subscription implementation, templated on the type of message this subscription receives.">Subscription</a>, among other things. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5acbc58580037d661aa735fddad70ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5acbc58580037d661aa735fddad70ba9">&#9670;&nbsp;</a></span>IntraProcessManagerWeakPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrclcpp_1_1SubscriptionBase.html#a5acbc58580037d661aa735fddad70ba9">rclcpp::SubscriptionBase::IntraProcessManagerWeakPtr</a> =  std::weak_ptr&lt;<a class="el" href="classrclcpp_1_1experimental_1_1IntraProcessManager.html">rclcpp::experimental::IntraProcessManager</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9f68a3c9cf39f5d8ddd0e318e23a0ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f68a3c9cf39f5d8ddd0e318e23a0ada">&#9670;&nbsp;</a></span>SubscriptionBase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::SubscriptionBase::SubscriptionBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeBaseInterface.html">rclcpp::node_interfaces::NodeBaseInterface</a> *&#160;</td>
          <td class="paramname"><em>node_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_message_type_support_t &amp;&#160;</td>
          <td class="paramname"><em>type_support_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rcl_subscription_options_t &amp;&#160;</td>
          <td class="paramname"><em>subscription_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_serialized</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>This accepts rcl_subscription_options_t instead of <a class="el" href="namespacerclcpp.html#aa0ce420d67bb40b61156347455d3ad23">rclcpp::SubscriptionOptions</a> because <a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html#ab2bc5d54e007194575937548a2b809a4" title="Convert this class, with a rclcpp::QoS, into an rcl_subscription_options_t.">rclcpp::SubscriptionOptions::to_rcl_subscription_options</a> depends on the message type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_base</td><td>NodeBaseInterface pointer used in parts of the setup. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_support_handle</td><td>rosidl type support struct, for the Message type of the topic. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topic_name</td><td>Name of the topic to subscribe to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription_options</td><td>Options for the subscription. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_serialized</td><td>is true if the message will be delivered still serialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52b8cda0f87d9c1200b32800a39c0363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b8cda0f87d9c1200b32800a39c0363">&#9670;&nbsp;</a></span>~SubscriptionBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual rclcpp::SubscriptionBase::~SubscriptionBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a71b149cae2bcec14c99ee32828ef7d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b149cae2bcec14c99ee32828ef7d8c">&#9670;&nbsp;</a></span>get_topic_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rclcpp::SubscriptionBase::get_topic_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the topic that this subscription is subscribed on. </p>

</div>
</div>
<a id="a819a46b4c3ffba9bef8d05ad7eab7344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819a46b4c3ffba9bef8d05ad7eab7344">&#9670;&nbsp;</a></span>get_subscription_handle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;rcl_subscription_t&gt; rclcpp::SubscriptionBase::get_subscription_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab065197aa67d19cf4eba0688ffedfccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab065197aa67d19cf4eba0688ffedfccf">&#9670;&nbsp;</a></span>get_subscription_handle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const rcl_subscription_t&gt; rclcpp::SubscriptionBase::get_subscription_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6fd6e4355071cdd5aa6b4c8e623d4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6fd6e4355071cdd5aa6b4c8e623d4cc">&#9670;&nbsp;</a></span>get_event_handlers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt;rcl_subscription_event_type_t, std::shared_ptr&lt;<a class="el" href="classrclcpp_1_1QOSEventHandlerBase.html">rclcpp::QOSEventHandlerBase</a>&gt; &gt;&amp; rclcpp::SubscriptionBase::get_event_handlers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all the <a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">QoS</a> event handlers associated with this subscription. </p>
<dl class="section return"><dt>Returns</dt><dd>The map of <a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">QoS</a> event handlers. </dd></dl>

</div>
</div>
<a id="abdaeff8614370f5e8b896f815928601a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdaeff8614370f5e8b896f815928601a">&#9670;&nbsp;</a></span>get_actual_qos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> rclcpp::SubscriptionBase::get_actual_qos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the actual <a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">QoS</a> settings, after the defaults have been determined. </p>
<p>The actual configuration applied when using RMW_QOS_POLICY_*_SYSTEM_DEFAULT can only be resolved after the creation of the subscription, and it depends on the underlying rmw implementation. If the underlying setting in use can't be represented in ROS terms, it will be set to RMW_QOS_POLICY_*_UNKNOWN. May throw runtime_error when an unexpected error occurs.</p>
<dl class="section return"><dt>Returns</dt><dd>The actual qos settings. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if failed to get qos settings </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaee028d0dc23bcd2c0bfded09b5012cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee028d0dc23bcd2c0bfded09b5012cb">&#9670;&nbsp;</a></span>take_type_erased()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::SubscriptionBase::take_type_erased </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>message_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1MessageInfo.html">rclcpp::MessageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>message_info_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take the next inter-process message from the subscription as a type erased pointer. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Subscription.html#af53ab20db04013e1b1a8b8af062e9fbe" title="Take the next message from the inter-process subscription.">Subscription::take()</a> for details on how this function works.</dd></dl>
<p>The only difference is that it takes a type erased pointer rather than a reference to the exact message type.</p>
<p>This type erased version facilitates using the subscriptions in a type agnostic way using <a class="el" href="classrclcpp_1_1SubscriptionBase.html#a82e353f7653570b836051428f02a2171" title="Borrow a new message.">SubscriptionBase::create_message()</a> and <a class="el" href="classrclcpp_1_1SubscriptionBase.html#a9e9859bf785042e896c8a9962ead8f89" title="Check if we need to handle the message, and execute the callback if we do.">SubscriptionBase::handle_message()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">message_out</td><td>The type erased message pointer into which take will copy the data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message_info_out</td><td>The message info for the taken message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if data was taken and is valid, otherwise false </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">any</td><td>rcl errors from rcl_take, </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacerclcpp_1_1exceptions.html#a1d5126c081e6f2e015ef4bb1447edec5" title="Throw a C++ std::exception which was created based on an rcl error.">rclcpp::exceptions::throw_from_rcl_error()</a> </dd></dl>

</div>
</div>
<a id="a25ac489152fd7aa9ca31610cf6fb14dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ac489152fd7aa9ca31610cf6fb14dd">&#9670;&nbsp;</a></span>take_serialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::SubscriptionBase::take_serialized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1SerializedMessage.html">rclcpp::SerializedMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>message_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1MessageInfo.html">rclcpp::MessageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>message_info_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take the next inter-process message, in its serialized form, from the subscription. </p>
<p>For now, if data is taken (written) into the message_out and message_info_out then true will be returned. Unlike <a class="el" href="classrclcpp_1_1Subscription.html#af53ab20db04013e1b1a8b8af062e9fbe" title="Take the next message from the inter-process subscription.">Subscription::take()</a>, taking data serialized is not possible via intra-process for the time being, so it will not need to de-duplicate data in any case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">message_out</td><td>The serialized message data structure used to store the taken message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message_info_out</td><td>The message info for the taken message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if data was taken and is valid, otherwise false </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">any</td><td>rcl errors from rcl_take, </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacerclcpp_1_1exceptions.html#a1d5126c081e6f2e015ef4bb1447edec5" title="Throw a C++ std::exception which was created based on an rcl error.">rclcpp::exceptions::throw_from_rcl_error()</a> </dd></dl>

</div>
</div>
<a id="a82e353f7653570b836051428f02a2171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e353f7653570b836051428f02a2171">&#9670;&nbsp;</a></span>create_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;void&gt; rclcpp::SubscriptionBase::create_message </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Borrow a new message. </p>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to the fresh message. </dd></dl>

<p>Implemented in <a class="el" href="classrclcpp_1_1Subscription.html#aef09f4278d597f581de2d9942595fd39">rclcpp::Subscription&lt; MessageT, AllocatorT, SubscribedT, ROSMessageT, MessageMemoryStrategyT &gt;</a>, <a class="el" href="classrclcpp_1_1Subscription.html#aef09f4278d597f581de2d9942595fd39">rclcpp::Subscription&lt; rcl_interfaces::msg::ParameterEvent &gt;</a>, and <a class="el" href="classrclcpp_1_1GenericSubscription.html#af13ec8c4eb86cc7da5c3969d46df1ea9">rclcpp::GenericSubscription</a>.</p>

</div>
</div>
<a id="ab44968e2dc8ae425dfc85c1882f67df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44968e2dc8ae425dfc85c1882f67df7">&#9670;&nbsp;</a></span>create_serialized_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="classrclcpp_1_1SerializedMessage.html">rclcpp::SerializedMessage</a>&gt; rclcpp::SubscriptionBase::create_serialized_message </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Borrow a new serialized message. </p>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to a rcl_message_serialized_t. </dd></dl>

<p>Implemented in <a class="el" href="classrclcpp_1_1Subscription.html#aa01f5d5ff83825e5d5480bf07cde1111">rclcpp::Subscription&lt; MessageT, AllocatorT, SubscribedT, ROSMessageT, MessageMemoryStrategyT &gt;</a>, <a class="el" href="classrclcpp_1_1Subscription.html#aa01f5d5ff83825e5d5480bf07cde1111">rclcpp::Subscription&lt; rcl_interfaces::msg::ParameterEvent &gt;</a>, and <a class="el" href="classrclcpp_1_1GenericSubscription.html#af00ee5aa29d54a2ff6ca4dd111b12525">rclcpp::GenericSubscription</a>.</p>

</div>
</div>
<a id="a9e9859bf785042e896c8a9962ead8f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9859bf785042e896c8a9962ead8f89">&#9670;&nbsp;</a></span>handle_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::SubscriptionBase::handle_message </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1MessageInfo.html">rclcpp::MessageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>message_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if we need to handle the message, and execute the callback if we do. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Shared pointer to the message to handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message_info</td><td>Metadata associated with this message. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classrclcpp_1_1Subscription.html#aea947da5bbae89abadc480b68b3cf475">rclcpp::Subscription&lt; MessageT, AllocatorT, SubscribedT, ROSMessageT, MessageMemoryStrategyT &gt;</a>, <a class="el" href="classrclcpp_1_1Subscription.html#aea947da5bbae89abadc480b68b3cf475">rclcpp::Subscription&lt; rcl_interfaces::msg::ParameterEvent &gt;</a>, and <a class="el" href="classrclcpp_1_1GenericSubscription.html#a3841ba7062bc327bc444946e73286e6c">rclcpp::GenericSubscription</a>.</p>

</div>
</div>
<a id="aa4d583c8c1d5c667b03c4bc08f05eadd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d583c8c1d5c667b03c4bc08f05eadd">&#9670;&nbsp;</a></span>handle_serialized_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::SubscriptionBase::handle_serialized_message </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1SerializedMessage.html">rclcpp::SerializedMessage</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>serialized_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1MessageInfo.html">rclcpp::MessageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>message_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classrclcpp_1_1Subscription.html#a28cee26a073de3c0496c4be3b7398b49">rclcpp::Subscription&lt; MessageT, AllocatorT, SubscribedT, ROSMessageT, MessageMemoryStrategyT &gt;</a>, <a class="el" href="classrclcpp_1_1Subscription.html#a28cee26a073de3c0496c4be3b7398b49">rclcpp::Subscription&lt; rcl_interfaces::msg::ParameterEvent &gt;</a>, and <a class="el" href="classrclcpp_1_1GenericSubscription.html#ae865a44f31c5bdfee06cde1d07f8c625">rclcpp::GenericSubscription</a>.</p>

</div>
</div>
<a id="af6b7009c6a6b7f2363009f154243c86e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b7009c6a6b7f2363009f154243c86e">&#9670;&nbsp;</a></span>handle_loaned_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::SubscriptionBase::handle_loaned_message </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>loaned_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1MessageInfo.html">rclcpp::MessageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>message_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classrclcpp_1_1Subscription.html#a3f7edf542d07fe4aa348c00cc1df68bf">rclcpp::Subscription&lt; MessageT, AllocatorT, SubscribedT, ROSMessageT, MessageMemoryStrategyT &gt;</a>, <a class="el" href="classrclcpp_1_1Subscription.html#a3f7edf542d07fe4aa348c00cc1df68bf">rclcpp::Subscription&lt; rcl_interfaces::msg::ParameterEvent &gt;</a>, and <a class="el" href="classrclcpp_1_1GenericSubscription.html#a8a376dcd01e387485bdfddc3ac7ab8da">rclcpp::GenericSubscription</a>.</p>

</div>
</div>
<a id="ac44162910e6e0c184eaa1bf729287c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44162910e6e0c184eaa1bf729287c55">&#9670;&nbsp;</a></span>return_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::SubscriptionBase::return_message </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the message borrowed in create_message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Shared pointer to the returned message. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classrclcpp_1_1Subscription.html#ac1fe32eee17be2818bcb598fdcf6a6ba">rclcpp::Subscription&lt; MessageT, AllocatorT, SubscribedT, ROSMessageT, MessageMemoryStrategyT &gt;</a>, <a class="el" href="classrclcpp_1_1Subscription.html#ac1fe32eee17be2818bcb598fdcf6a6ba">rclcpp::Subscription&lt; rcl_interfaces::msg::ParameterEvent &gt;</a>, and <a class="el" href="classrclcpp_1_1GenericSubscription.html#a0e1e2a49c965e4c7909b5238f2d61671">rclcpp::GenericSubscription</a>.</p>

</div>
</div>
<a id="a9b6b7186400304c5a7f4fd97198442a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6b7186400304c5a7f4fd97198442a6">&#9670;&nbsp;</a></span>return_serialized_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::SubscriptionBase::return_serialized_message </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1SerializedMessage.html">rclcpp::SerializedMessage</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the message borrowed in create_serialized_message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Shared pointer to the returned message. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classrclcpp_1_1Subscription.html#a87fabff15cf74832208c4f420bc0b321">rclcpp::Subscription&lt; MessageT, AllocatorT, SubscribedT, ROSMessageT, MessageMemoryStrategyT &gt;</a>, <a class="el" href="classrclcpp_1_1Subscription.html#a87fabff15cf74832208c4f420bc0b321">rclcpp::Subscription&lt; rcl_interfaces::msg::ParameterEvent &gt;</a>, and <a class="el" href="classrclcpp_1_1GenericSubscription.html#a2fa0928a95aaf82bf32556d8089f967f">rclcpp::GenericSubscription</a>.</p>

</div>
</div>
<a id="aa1640e5f85ee0117f55f69b435723070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1640e5f85ee0117f55f69b435723070">&#9670;&nbsp;</a></span>get_message_type_support_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const rosidl_message_type_support_t&amp; rclcpp::SubscriptionBase::get_message_type_support_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03df6a21a75e1eb4619a31b1b0ef852a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03df6a21a75e1eb4619a31b1b0ef852a">&#9670;&nbsp;</a></span>is_serialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::SubscriptionBase::is_serialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return if the subscription is serialized. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the subscription is serialized, <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="a0f61104666e697839925e0edc060359a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f61104666e697839925e0edc060359a">&#9670;&nbsp;</a></span>get_publisher_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t rclcpp::SubscriptionBase::get_publisher_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get matching publisher count. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of publishers on this topic. </dd></dl>

</div>
</div>
<a id="aec59d8a5befb5d79c33b8701c86302bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec59d8a5befb5d79c33b8701c86302bf">&#9670;&nbsp;</a></span>can_loan_messages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::SubscriptionBase::can_loan_messages </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if subscription instance can loan messages. </p>
<p>Depending on the middleware and the message type, this will return true if the middleware can allocate a ROS message instance.</p>
<dl class="section return"><dt>Returns</dt><dd>boolean flag indicating if middleware can loan messages. </dd></dl>

</div>
</div>
<a id="a1d01277c7ddfe0c33074154d1385c9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d01277c7ddfe0c33074154d1385c9c6">&#9670;&nbsp;</a></span>setup_intra_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::SubscriptionBase::setup_intra_process </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>intra_process_subscription_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a5acbc58580037d661aa735fddad70ba9">IntraProcessManagerWeakPtr</a>&#160;</td>
          <td class="paramname"><em>weak_ipm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implemenation detail. </p>

</div>
</div>
<a id="a1c46f29106172b169769900e1ba63341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c46f29106172b169769900e1ba63341">&#9670;&nbsp;</a></span>get_intra_process_waitable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::Waitable::SharedPtr rclcpp::SubscriptionBase::get_intra_process_waitable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the waitable for intra-process. </p>
<dl class="section return"><dt>Returns</dt><dd>the waitable sharedpointer for intra-process, or nullptr if intra-process is not setup. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the intra process manager is destroyed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb36042e8da7c498f881b7581feba649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb36042e8da7c498f881b7581feba649">&#9670;&nbsp;</a></span>exchange_in_use_by_wait_set_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::SubscriptionBase::exchange_in_use_by_wait_set_state </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pointer_to_subscription_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>in_use_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchange state of whether or not a part of the subscription is used by a wait set. </p>
<p>Used to ensure parts of the subscription are not used with multiple wait sets simultaneously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer_to_subscription_part</td><td>address of a subscription part </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_use_state</td><td>the new state to exchange, true means "now in use", and false means "no longer in use". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current "in use" state. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If pointer_to_subscription_part is nullptr. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>If the pointer given is not a pointer to one of the parts of the subscription which can be used with a wait set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a364fdf5cb7779b5945d05b5dedf08697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364fdf5cb7779b5945d05b5dedf08697">&#9670;&nbsp;</a></span>get_network_flow_endpoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classrclcpp_1_1NetworkFlowEndpoint.html">rclcpp::NetworkFlowEndpoint</a>&gt; rclcpp::SubscriptionBase::get_network_flow_endpoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get network flow endpoints. </p>
<p>Describes network flow endpoints that this subscription is receiving messages on </p><dl class="section return"><dt>Returns</dt><dd>vector of <a class="el" href="classrclcpp_1_1NetworkFlowEndpoint.html">NetworkFlowEndpoint</a> </dd></dl>

</div>
</div>
<a id="a521736fb9ae74f0ae6c206d596387cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521736fb9ae74f0ae6c206d596387cd5">&#9670;&nbsp;</a></span>set_on_new_message_callback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::SubscriptionBase::set_on_new_message_callback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(size_t)&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a callback to be called when each new message is received. </p>
<p>The callback receives a size_t which is the number of messages received since the last time this callback was called. Normally this is 1, but can be &gt; 1 if messages were received before any callback was set.</p>
<p>Since this callback is called from the middleware, you should aim to make it fast and not blocking. If you need to do a lot of work or wait for some other event, you should spin it off to another thread, otherwise you risk blocking the middleware.</p>
<p>Calling it again will clear any previously set callback.</p>
<p>This function is thread-safe.</p>
<p>If you want more information available in the callback, like the subscription or other information, you may use a lambda with captures or std::bind.</p>
<dl class="section see"><dt>See also</dt><dd>rmw_subscription_set_on_new_message_callback </dd>
<dd>
rcl_subscription_set_on_new_message_callback</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>functor to be called when a new message is received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98435bc530dce9856b0e54396bd2feff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98435bc530dce9856b0e54396bd2feff">&#9670;&nbsp;</a></span>clear_on_new_message_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::SubscriptionBase::clear_on_new_message_callback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unset the callback registered for new messages, if any. </p>

</div>
</div>
<a id="a30ed26098c94e49f38e82281e5cf1a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ed26098c94e49f38e82281e5cf1a74">&#9670;&nbsp;</a></span>set_on_new_intra_process_message_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::SubscriptionBase::set_on_new_intra_process_message_callback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(size_t)&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a callback to be called when each new intra-process message is received. </p>
<p>The callback receives a size_t which is the number of messages received since the last time this callback was called. Normally this is 1, but can be &gt; 1 if messages were received before any callback was set.</p>
<p>Calling it again will clear any previously set callback.</p>
<p>This function is thread-safe.</p>
<p>If you want more information available in the callback, like the subscription or other information, you may use a lambda with captures or std::bind.</p>
<dl class="section see"><dt>See also</dt><dd>rclcpp::SubscriptionIntraProcessBase::set_on_ready_callback</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>functor to be called when a new message is received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed55624362036446169c4c810c27c57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed55624362036446169c4c810c27c57e">&#9670;&nbsp;</a></span>clear_on_new_intra_process_message_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::SubscriptionBase::clear_on_new_intra_process_message_callback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unset the callback registered for new intra-process messages, if any. </p>

</div>
</div>
<a id="a670ff66837efc2c9f6d12b9db5e10623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670ff66837efc2c9f6d12b9db5e10623">&#9670;&nbsp;</a></span>set_on_new_qos_event_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::SubscriptionBase::set_on_new_qos_event_callback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(size_t)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rcl_subscription_event_type_t&#160;</td>
          <td class="paramname"><em>event_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a callback to be called when each new qos event instance occurs. </p>
<p>The callback receives a size_t which is the number of events that occurred since the last time this callback was called. Normally this is 1, but can be &gt; 1 if events occurred before any callback was set.</p>
<p>Since this callback is called from the middleware, you should aim to make it fast and not blocking. If you need to do a lot of work or wait for some other event, you should spin it off to another thread, otherwise you risk blocking the middleware.</p>
<p>Calling it again will clear any previously set callback.</p>
<p>An exception will be thrown if the callback is not callable.</p>
<p>This function is thread-safe.</p>
<p>If you want more information available in the callback, like the qos event or other information, you may use a lambda with captures or std::bind.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1QOSEventHandlerBase.html#aa792523eeb1f79c02f73dec5643ed948" title="Set a callback to be called when each new event instance occurs.">rclcpp::QOSEventHandlerBase::set_on_ready_callback</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>functor to be called when a new event occurs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event_type</td><td>identifier for the qos event we want to attach the callback to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfc38e749f90df367503a9ddc7c87941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc38e749f90df367503a9ddc7c87941">&#9670;&nbsp;</a></span>clear_on_new_qos_event_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::SubscriptionBase::clear_on_new_qos_event_callback </td>
          <td>(</td>
          <td class="paramtype">rcl_subscription_event_type_t&#160;</td>
          <td class="paramname"><em>event_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unset the callback registered for new qos events, if any. </p>

</div>
</div>
<a id="ab3396d53d07b0e5a9c8329aaa2059e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3396d53d07b0e5a9c8329aaa2059e36">&#9670;&nbsp;</a></span>is_cft_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::SubscriptionBase::is_cft_enabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if content filtered topic feature of the subscription instance is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>boolean flag indicating if the content filtered topic of this subscription is enabled. </dd></dl>

</div>
</div>
<a id="a8b9ba7854936b7e38e03505aef318680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9ba7854936b7e38e03505aef318680">&#9670;&nbsp;</a></span>set_content_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::SubscriptionBase::set_content_filter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filter_expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>expression_parameters</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the filter expression and expression parameters for the subscription. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_expression</td><td>A filter expression to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structrclcpp_1_1ContentFilterOptions.html#a53dabc96624c9fa5528516e5761043dd" title="Filter expression is similar to the WHERE part of an SQL clause.">ContentFilterOptions::filter_expression</a> An empty string ("") will clear the content filter setting of the subscription. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expression_parameters</td><td>Array of expression parameters to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structrclcpp_1_1ContentFilterOptions.html#aae40c169530b5975003ce7e68ea63fd1">ContentFilterOptions::expression_parameters</a> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">RCLBadAlloc</td><td>if memory cannot be allocated </td></tr>
    <tr><td class="paramname">RCLError</td><td>if an unexpect error occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b02ecef0eeeb3c3c017f34cd799ec6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b02ecef0eeeb3c3c017f34cd799ec6b">&#9670;&nbsp;</a></span>get_content_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrclcpp_1_1ContentFilterOptions.html">rclcpp::ContentFilterOptions</a> rclcpp::SubscriptionBase::get_content_filter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the filter expression and expression parameters for the subscription. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structrclcpp_1_1ContentFilterOptions.html" title="Options to configure content filtered topic in the subscription.">rclcpp::ContentFilterOptions</a> The content filter options to get. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">RCLBadAlloc</td><td>if memory cannot be allocated </td></tr>
    <tr><td class="paramname">RCLError</td><td>if an unexpect error occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f57c010a428149762b8165ca5438619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f57c010a428149762b8165ca5438619">&#9670;&nbsp;</a></span>add_event_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventCallbackT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::SubscriptionBase::add_event_handler </td>
          <td>(</td>
          <td class="paramtype">const EventCallbackT &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rcl_subscription_event_type_t&#160;</td>
          <td class="paramname"><em>event_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a537c2376954a0a29aa8a5ef3f1cfe9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537c2376954a0a29aa8a5ef3f1cfe9f7">&#9670;&nbsp;</a></span>default_incompatible_qos_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::SubscriptionBase::default_incompatible_qos_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerclcpp.html#a26c69f1ce0937b36bc3915e989fb9faf">QOSRequestedIncompatibleQoSInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a99ade691372f06d72bbe36fd133b260b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ade691372f06d72bbe36fd133b260b">&#9670;&nbsp;</a></span>matches_any_intra_process_publishers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::SubscriptionBase::matches_any_intra_process_publishers </td>
          <td>(</td>
          <td class="paramtype">const rmw_gid_t *&#160;</td>
          <td class="paramname"><em>sender_gid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeed8917fb3bc13c76aa814bebeddb7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed8917fb3bc13c76aa814bebeddb7a9">&#9670;&nbsp;</a></span>set_on_new_message_callback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::SubscriptionBase::set_on_new_message_callback </td>
          <td>(</td>
          <td class="paramtype">rcl_event_callback_t&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a020f78aa2f16e4f01be1a6dc6826d32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020f78aa2f16e4f01be1a6dc6826d32c">&#9670;&nbsp;</a></span>node_base_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeBaseInterface.html">rclcpp::node_interfaces::NodeBaseInterface</a>* const rclcpp::SubscriptionBase::node_base_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a83fe91f64668b491050809168da7b101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83fe91f64668b491050809168da7b101">&#9670;&nbsp;</a></span>node_handle_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;rcl_node_t&gt; rclcpp::SubscriptionBase::node_handle_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a86dccb346d0f8442dd7add518bcbc648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86dccb346d0f8442dd7add518bcbc648">&#9670;&nbsp;</a></span>subscription_handle_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;rcl_subscription_t&gt; rclcpp::SubscriptionBase::subscription_handle_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7897b9def45164032b896f1f685ef24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7897b9def45164032b896f1f685ef24">&#9670;&nbsp;</a></span>intra_process_subscription_handle_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;rcl_subscription_t&gt; rclcpp::SubscriptionBase::intra_process_subscription_handle_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a072dfab20f412a16383f44347ff3a77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072dfab20f412a16383f44347ff3a77f">&#9670;&nbsp;</a></span>node_logger_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1Logger.html">rclcpp::Logger</a> rclcpp::SubscriptionBase::node_logger_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a670e7f2ffd005d54a06d48a63ccf2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a670e7f2ffd005d54a06d48a63ccf2c">&#9670;&nbsp;</a></span>event_handlers_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;rcl_subscription_event_type_t, std::shared_ptr&lt;<a class="el" href="classrclcpp_1_1QOSEventHandlerBase.html">rclcpp::QOSEventHandlerBase</a>&gt; &gt; rclcpp::SubscriptionBase::event_handlers_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e2b849f3a01c83d1ae56d372c87a35d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2b849f3a01c83d1ae56d372c87a35d">&#9670;&nbsp;</a></span>use_intra_process_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::SubscriptionBase::use_intra_process_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a63c78489d556b95530b722ae80a1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a63c78489d556b95530b722ae80a1d5">&#9670;&nbsp;</a></span>weak_ipm_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1SubscriptionBase.html#a5acbc58580037d661aa735fddad70ba9">IntraProcessManagerWeakPtr</a> rclcpp::SubscriptionBase::weak_ipm_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a56e75ff6f8331e308cdb0c96fda52706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e75ff6f8331e308cdb0c96fda52706">&#9670;&nbsp;</a></span>intra_process_subscription_id_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t rclcpp::SubscriptionBase::intra_process_subscription_id_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa992ad92d16db051a81b9c4819d1e3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa992ad92d16db051a81b9c4819d1e3ac">&#9670;&nbsp;</a></span>subscription_intra_process_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html">rclcpp::experimental::SubscriptionIntraProcessBase</a>&gt; rclcpp::SubscriptionBase::subscription_intra_process_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/rclcpp/<a class="el" href="subscription__base_8hpp_source.html">subscription_base.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
