<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rclcpp: rclcpp::node_interfaces::NodeGraph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rclcpp
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C++ ROS Client Library API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerclcpp.html">rclcpp</a></li><li class="navelem"><a class="el" href="namespacerclcpp_1_1node__interfaces.html">node_interfaces</a></li><li class="navelem"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html">NodeGraph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classrclcpp_1_1node__interfaces_1_1NodeGraph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rclcpp::node_interfaces::NodeGraph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation the <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html" title="Implementation the NodeGraph part of the Node API.">NodeGraph</a> part of the <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> API.  
 <a href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="node__graph_8hpp_source.html">node_graph.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rclcpp::node_interfaces::NodeGraph:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1node__interfaces_1_1NodeGraph__inherit__graph.png" border="0" usemap="#arclcpp_1_1node__interfaces_1_1NodeGraph_inherit__map" alt="Inheritance graph"/></div>
<map name="arclcpp_1_1node__interfaces_1_1NodeGraph_inherit__map" id="arclcpp_1_1node__interfaces_1_1NodeGraph_inherit__map">
<area shape="rect" title="Implementation the NodeGraph part of the Node API." alt="" coords="5,95,179,136"/>
<area shape="rect" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html" title="Pure virtual interface class for the NodeGraph part of the Node API." alt="" coords="5,5,179,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for rclcpp::node_interfaces::NodeGraph:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1node__interfaces_1_1NodeGraph__coll__graph.png" border="0" usemap="#arclcpp_1_1node__interfaces_1_1NodeGraph_coll__map" alt="Collaboration graph"/></div>
<map name="arclcpp_1_1node__interfaces_1_1NodeGraph_coll__map" id="arclcpp_1_1node__interfaces_1_1NodeGraph_coll__map">
<area shape="rect" title="Implementation the NodeGraph part of the Node API." alt="" coords="5,95,179,136"/>
<area shape="rect" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html" title="Pure virtual interface class for the NodeGraph part of the Node API." alt="" coords="5,5,179,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abea4083c438b551d7c366c26921da996"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#abea4083c438b551d7c366c26921da996">NodeGraph</a> (<a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeBaseInterface.html">rclcpp::node_interfaces::NodeBaseInterface</a> *node_base)</td></tr>
<tr class="separator:abea4083c438b551d7c366c26921da996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ecc3b6e983cea9a9bb3b3296b10ae7"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#ad1ecc3b6e983cea9a9bb3b3296b10ae7">~NodeGraph</a> ()</td></tr>
<tr class="separator:ad1ecc3b6e983cea9a9bb3b3296b10ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf450c64125a78006d1f0d6a4da1366a"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#adf450c64125a78006d1f0d6a4da1366a">get_topic_names_and_types</a> (bool no_demangle=false) const override</td></tr>
<tr class="memdesc:adf450c64125a78006d1f0d6a4da1366a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a map of existing topic names to list of topic types.  <a href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#adf450c64125a78006d1f0d6a4da1366a">More...</a><br /></td></tr>
<tr class="separator:adf450c64125a78006d1f0d6a4da1366a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2bec35db8658c83f4b8d4662fc9e44c"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#aa2bec35db8658c83f4b8d4662fc9e44c">get_service_names_and_types</a> () const override</td></tr>
<tr class="memdesc:aa2bec35db8658c83f4b8d4662fc9e44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a map of existing service names to list of service types.  <a href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#aa2bec35db8658c83f4b8d4662fc9e44c">More...</a><br /></td></tr>
<tr class="separator:aa2bec35db8658c83f4b8d4662fc9e44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f80f5fc9ef461c882a7e5f32c4a06eb"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#a5f80f5fc9ef461c882a7e5f32c4a06eb">get_service_names_and_types_by_node</a> (const std::string &amp;node_name, const std::string &amp;namespace_) const override</td></tr>
<tr class="memdesc:a5f80f5fc9ef461c882a7e5f32c4a06eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a map of existing service names to list of service types for a specific node.  <a href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#a5f80f5fc9ef461c882a7e5f32c4a06eb">More...</a><br /></td></tr>
<tr class="separator:a5f80f5fc9ef461c882a7e5f32c4a06eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17246b452029213ac991ebe4cb7a6690"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#a17246b452029213ac991ebe4cb7a6690">get_client_names_and_types_by_node</a> (const std::string &amp;node_name, const std::string &amp;namespace_) const override</td></tr>
<tr class="memdesc:a17246b452029213ac991ebe4cb7a6690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a map of existing service names and types with a specific node.  <a href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#a17246b452029213ac991ebe4cb7a6690">More...</a><br /></td></tr>
<tr class="separator:a17246b452029213ac991ebe4cb7a6690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f3150c90c0e2a78e4f38b68a9aabb1"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#a33f3150c90c0e2a78e4f38b68a9aabb1">get_publisher_names_and_types_by_node</a> (const std::string &amp;node_name, const std::string &amp;namespace_, bool no_demangle=false) const override</td></tr>
<tr class="memdesc:a33f3150c90c0e2a78e4f38b68a9aabb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a map of existing topic names to list of topic types for a specific node.  <a href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#a33f3150c90c0e2a78e4f38b68a9aabb1">More...</a><br /></td></tr>
<tr class="separator:a33f3150c90c0e2a78e4f38b68a9aabb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94ccd3bf802eb1875b54765cb47fb71"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#ae94ccd3bf802eb1875b54765cb47fb71">get_subscriber_names_and_types_by_node</a> (const std::string &amp;node_name, const std::string &amp;namespace_, bool no_demangle=false) const override</td></tr>
<tr class="memdesc:ae94ccd3bf802eb1875b54765cb47fb71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a map of existing topic names to list of topic types for a specific node.  <a href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#ae94ccd3bf802eb1875b54765cb47fb71">More...</a><br /></td></tr>
<tr class="separator:ae94ccd3bf802eb1875b54765cb47fb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c21b9c5e4b53a54c84e22940d66d77b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#a2c21b9c5e4b53a54c84e22940d66d77b">get_node_names</a> () const override</td></tr>
<tr class="memdesc:a2c21b9c5e4b53a54c84e22940d66d77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of existing node names (string).  <a href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#a2c21b9c5e4b53a54c84e22940d66d77b">More...</a><br /></td></tr>
<tr class="separator:a2c21b9c5e4b53a54c84e22940d66d77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac159de09cbe263aab8d71a1442b3c1c1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::tuple&lt; std::string, std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#ac159de09cbe263aab8d71a1442b3c1c1">get_node_names_with_enclaves</a> () const override</td></tr>
<tr class="memdesc:ac159de09cbe263aab8d71a1442b3c1c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of existing node names, namespaces and enclaves (tuple of string).  <a href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#ac159de09cbe263aab8d71a1442b3c1c1">More...</a><br /></td></tr>
<tr class="separator:ac159de09cbe263aab8d71a1442b3c1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4e4f4241d7487f9cf230399a097954"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#a8f4e4f4241d7487f9cf230399a097954">get_node_names_and_namespaces</a> () const override</td></tr>
<tr class="memdesc:a8f4e4f4241d7487f9cf230399a097954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of existing node names and namespaces (pair of string).  <a href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#a8f4e4f4241d7487f9cf230399a097954">More...</a><br /></td></tr>
<tr class="separator:a8f4e4f4241d7487f9cf230399a097954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1cad430f6099063f4149e36e338400c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#ad1cad430f6099063f4149e36e338400c">count_publishers</a> (const std::string &amp;topic_name) const override</td></tr>
<tr class="memdesc:ad1cad430f6099063f4149e36e338400c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of publishers that are advertised on a given topic.  <a href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#ad1cad430f6099063f4149e36e338400c">More...</a><br /></td></tr>
<tr class="separator:ad1cad430f6099063f4149e36e338400c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb2d765d4681532f1909b9410be1452"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#aceb2d765d4681532f1909b9410be1452">count_subscribers</a> (const std::string &amp;topic_name) const override</td></tr>
<tr class="memdesc:aceb2d765d4681532f1909b9410be1452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of subscribers who have created a subscription for a given topic.  <a href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#aceb2d765d4681532f1909b9410be1452">More...</a><br /></td></tr>
<tr class="separator:aceb2d765d4681532f1909b9410be1452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a92aaf6aff34687a431dafa4520e290"><td class="memItemLeft" align="right" valign="top">const rcl_guard_condition_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#a8a92aaf6aff34687a431dafa4520e290">get_graph_guard_condition</a> () const override</td></tr>
<tr class="memdesc:a8a92aaf6aff34687a431dafa4520e290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the rcl guard condition which is triggered when the ROS graph changes.  <a href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#a8a92aaf6aff34687a431dafa4520e290">More...</a><br /></td></tr>
<tr class="separator:a8a92aaf6aff34687a431dafa4520e290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3fb4a7f5c875f7dd126f2ceed8b2c4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#ab3fb4a7f5c875f7dd126f2ceed8b2c4c">notify_graph_change</a> () override</td></tr>
<tr class="memdesc:ab3fb4a7f5c875f7dd126f2ceed8b2c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify threads waiting on graph changes.  <a href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#ab3fb4a7f5c875f7dd126f2ceed8b2c4c">More...</a><br /></td></tr>
<tr class="separator:ab3fb4a7f5c875f7dd126f2ceed8b2c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde53f8adde6584712705b85c09c955a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#afde53f8adde6584712705b85c09c955a">notify_shutdown</a> () override</td></tr>
<tr class="memdesc:afde53f8adde6584712705b85c09c955a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify any and all blocking node actions that shutdown has occurred.  <a href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#afde53f8adde6584712705b85c09c955a">More...</a><br /></td></tr>
<tr class="separator:afde53f8adde6584712705b85c09c955a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7406637a5de005f8d25f1b68eb29db"><td class="memItemLeft" align="right" valign="top">rclcpp::Event::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#a5d7406637a5de005f8d25f1b68eb29db">get_graph_event</a> () override</td></tr>
<tr class="memdesc:a5d7406637a5de005f8d25f1b68eb29db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a graph event, which will be set anytime a graph change occurs.  <a href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#a5d7406637a5de005f8d25f1b68eb29db">More...</a><br /></td></tr>
<tr class="separator:a5d7406637a5de005f8d25f1b68eb29db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d5cf2d4d38cf410d72bf3ae459d6e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#a30d5cf2d4d38cf410d72bf3ae459d6e1">wait_for_graph_change</a> (rclcpp::Event::SharedPtr event, std::chrono::nanoseconds timeout) override</td></tr>
<tr class="memdesc:a30d5cf2d4d38cf410d72bf3ae459d6e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a graph event to occur by waiting on an <a class="el" href="classrclcpp_1_1Event.html">Event</a> to become set.  <a href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#a30d5cf2d4d38cf410d72bf3ae459d6e1">More...</a><br /></td></tr>
<tr class="separator:a30d5cf2d4d38cf410d72bf3ae459d6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45992a5266ddaf2195b50f078bfeab48"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#a45992a5266ddaf2195b50f078bfeab48">count_graph_users</a> () const override</td></tr>
<tr class="memdesc:a45992a5266ddaf2195b50f078bfeab48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of on loan graph events, see <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#a5d7406637a5de005f8d25f1b68eb29db" title="Return a graph event, which will be set anytime a graph change occurs.">get_graph_event()</a>.  <a href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#a45992a5266ddaf2195b50f078bfeab48">More...</a><br /></td></tr>
<tr class="separator:a45992a5266ddaf2195b50f078bfeab48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae191391ef7f70941f4c52256ac4e8e14"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classrclcpp_1_1TopicEndpointInfo.html">rclcpp::TopicEndpointInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#ae191391ef7f70941f4c52256ac4e8e14">get_publishers_info_by_topic</a> (const std::string &amp;topic_name, bool no_mangle=false) const override</td></tr>
<tr class="memdesc:ae191391ef7f70941f4c52256ac4e8e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the topic endpoint information about publishers on a given topic.  <a href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#ae191391ef7f70941f4c52256ac4e8e14">More...</a><br /></td></tr>
<tr class="separator:ae191391ef7f70941f4c52256ac4e8e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b268ba5135700db7e99bf9b7f1355b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classrclcpp_1_1TopicEndpointInfo.html">rclcpp::TopicEndpointInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#ae7b268ba5135700db7e99bf9b7f1355b">get_subscriptions_info_by_topic</a> (const std::string &amp;topic_name, bool no_mangle=false) const override</td></tr>
<tr class="memdesc:ae7b268ba5135700db7e99bf9b7f1355b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the topic endpoint information about subscriptions on a given topic.  <a href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#ae7b268ba5135700db7e99bf9b7f1355b">More...</a><br /></td></tr>
<tr class="separator:ae7b268ba5135700db7e99bf9b7f1355b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classrclcpp_1_1node__interfaces_1_1NodeGraphInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrclcpp_1_1node__interfaces_1_1NodeGraphInterface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html">rclcpp::node_interfaces::NodeGraphInterface</a></td></tr>
<tr class="memitem:acd12eb8eaa948669193d4a6516326527 inherit pub_methods_classrclcpp_1_1node__interfaces_1_1NodeGraphInterface"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html#acd12eb8eaa948669193d4a6516326527">~NodeGraphInterface</a> ()=default</td></tr>
<tr class="separator:acd12eb8eaa948669193d4a6516326527 inherit pub_methods_classrclcpp_1_1node__interfaces_1_1NodeGraphInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation the <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html" title="Implementation the NodeGraph part of the Node API.">NodeGraph</a> part of the <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> API. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abea4083c438b551d7c366c26921da996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea4083c438b551d7c366c26921da996">&#9670;&nbsp;</a></span>NodeGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::node_interfaces::NodeGraph::NodeGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeBaseInterface.html">rclcpp::node_interfaces::NodeBaseInterface</a> *&#160;</td>
          <td class="paramname"><em>node_base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1ecc3b6e983cea9a9bb3b3296b10ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ecc3b6e983cea9a9bb3b3296b10ae7">&#9670;&nbsp;</a></span>~NodeGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual rclcpp::node_interfaces::NodeGraph::~NodeGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adf450c64125a78006d1f0d6a4da1366a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf450c64125a78006d1f0d6a4da1366a">&#9670;&nbsp;</a></span>get_topic_names_and_types()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::vector&lt;std::string&gt; &gt; rclcpp::node_interfaces::NodeGraph::get_topic_names_and_types </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_demangle</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a map of existing topic names to list of topic types. </p>
<p>A topic is considered to exist when at least one publisher or subscriber exists for it, whether they be local or remote to this process. The returned names are the actual names of the topics, either announced by another nodes or by this one. Attempting to create publishers or subscribers using names returned by this function may not result in the desired topic name being used depending on the remap rules in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">no_demangle</td><td>if true, topic names and types are not demangled </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html#a778c5797486f5126edccd70dfe583acc">rclcpp::node_interfaces::NodeGraphInterface</a>.</p>

</div>
</div>
<a id="aa2bec35db8658c83f4b8d4662fc9e44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2bec35db8658c83f4b8d4662fc9e44c">&#9670;&nbsp;</a></span>get_service_names_and_types()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::vector&lt;std::string&gt; &gt; rclcpp::node_interfaces::NodeGraph::get_service_names_and_types </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a map of existing service names to list of service types. </p>
<p>A service is considered to exist when at least one service server or service client exists for it, whether they be local or remote to this process. The returned names are the actual names of the services, either announced by another nodes or by this one. Attempting to create clients or services using names returned by this function may not result in the desired service name being used depending on the remap rules in use. </p>

<p>Implements <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html#a5852d4535a2e61387ca2be874031bdc9">rclcpp::node_interfaces::NodeGraphInterface</a>.</p>

</div>
</div>
<a id="a5f80f5fc9ef461c882a7e5f32c4a06eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f80f5fc9ef461c882a7e5f32c4a06eb">&#9670;&nbsp;</a></span>get_service_names_and_types_by_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::vector&lt;std::string&gt; &gt; rclcpp::node_interfaces::NodeGraph::get_service_names_and_types_by_node </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>node_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>namespace_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a map of existing service names to list of service types for a specific node. </p>
<p>This function only considers services - not clients. The returned names are the actual names after remap rules applied. Attempting to create service clients using names returned by this function may not result in the desired service name being used depending on the remap rules in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_name</td><td>name of the node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">namespace_</td><td>namespace of the node </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html#adab93c48a10d8377316d73d861310787">rclcpp::node_interfaces::NodeGraphInterface</a>.</p>

</div>
</div>
<a id="a17246b452029213ac991ebe4cb7a6690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17246b452029213ac991ebe4cb7a6690">&#9670;&nbsp;</a></span>get_client_names_and_types_by_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::vector&lt;std::string&gt; &gt; rclcpp::node_interfaces::NodeGraph::get_client_names_and_types_by_node </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>node_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>namespace_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a map of existing service names and types with a specific node. </p>
<p>This function only considers clients - not service servers. The returned names are the actual names after remap rules applied. Attempting to create service servers using names returned by this function may not result in the desired service name being used depending on the remap rules in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_name</td><td>name of the node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">namespace_</td><td>namespace of the node </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html#a96fe64e0c2484742dcdb5fe663c66d76">rclcpp::node_interfaces::NodeGraphInterface</a>.</p>

</div>
</div>
<a id="a33f3150c90c0e2a78e4f38b68a9aabb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f3150c90c0e2a78e4f38b68a9aabb1">&#9670;&nbsp;</a></span>get_publisher_names_and_types_by_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::vector&lt;std::string&gt; &gt; rclcpp::node_interfaces::NodeGraph::get_publisher_names_and_types_by_node </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>node_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>namespace_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_demangle</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a map of existing topic names to list of topic types for a specific node. </p>
<p>This function only considers publishers - not subscribers. The returned names are the actual names after remap rules applied. Attempting to create publishers or subscribers using names returned by this function may not result in the desired topic name being used depending on the remap rules in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_name</td><td>name of the node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">namespace_</td><td>namespace of the node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_demangle</td><td>if true, topic names and types are not demangled </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html#a3f54e683a66ddbe32b135274e329aac0">rclcpp::node_interfaces::NodeGraphInterface</a>.</p>

</div>
</div>
<a id="ae94ccd3bf802eb1875b54765cb47fb71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94ccd3bf802eb1875b54765cb47fb71">&#9670;&nbsp;</a></span>get_subscriber_names_and_types_by_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::vector&lt;std::string&gt; &gt; rclcpp::node_interfaces::NodeGraph::get_subscriber_names_and_types_by_node </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>node_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>namespace_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_demangle</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a map of existing topic names to list of topic types for a specific node. </p>
<p>This function only considers subscribers - not publishers. The returned names are the actual names after remap rules applied. Attempting to create publishers or subscribers using names returned by this function may not result in the desired topic name being used depending on the remap rules in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_name</td><td>name of the node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">namespace_</td><td>namespace of the node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_demangle</td><td>if true, topic names and types are not demangled </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html#adf1aeb4c94ab0d2d415b7866165af57d">rclcpp::node_interfaces::NodeGraphInterface</a>.</p>

</div>
</div>
<a id="a2c21b9c5e4b53a54c84e22940d66d77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c21b9c5e4b53a54c84e22940d66d77b">&#9670;&nbsp;</a></span>get_node_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; rclcpp::node_interfaces::NodeGraph::get_node_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a vector of existing node names (string). </p>

<p>Implements <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html#a3227cff0d0c306c3a7ba8550ec36c92d">rclcpp::node_interfaces::NodeGraphInterface</a>.</p>

</div>
</div>
<a id="ac159de09cbe263aab8d71a1442b3c1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac159de09cbe263aab8d71a1442b3c1c1">&#9670;&nbsp;</a></span>get_node_names_with_enclaves()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::tuple&lt;std::string, std::string, std::string&gt; &gt; rclcpp::node_interfaces::NodeGraph::get_node_names_with_enclaves </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a vector of existing node names, namespaces and enclaves (tuple of string). </p>

<p>Implements <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html#af82bdcf92372e4a114c6e2ec84a57a58">rclcpp::node_interfaces::NodeGraphInterface</a>.</p>

</div>
</div>
<a id="a8f4e4f4241d7487f9cf230399a097954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4e4f4241d7487f9cf230399a097954">&#9670;&nbsp;</a></span>get_node_names_and_namespaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt; rclcpp::node_interfaces::NodeGraph::get_node_names_and_namespaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a vector of existing node names and namespaces (pair of string). </p>

<p>Implements <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html#acaebd5bddcc4f018e5250335e95bb2a0">rclcpp::node_interfaces::NodeGraphInterface</a>.</p>

</div>
</div>
<a id="ad1cad430f6099063f4149e36e338400c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1cad430f6099063f4149e36e338400c">&#9670;&nbsp;</a></span>count_publishers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t rclcpp::node_interfaces::NodeGraph::count_publishers </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of publishers that are advertised on a given topic. </p>

<p>Implements <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html#a916b41e6d63cf3abd929470b5f3e10b7">rclcpp::node_interfaces::NodeGraphInterface</a>.</p>

</div>
</div>
<a id="aceb2d765d4681532f1909b9410be1452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb2d765d4681532f1909b9410be1452">&#9670;&nbsp;</a></span>count_subscribers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t rclcpp::node_interfaces::NodeGraph::count_subscribers </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of subscribers who have created a subscription for a given topic. </p>

<p>Implements <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html#a45e3da58dd22b42abda51d45d5e17e7c">rclcpp::node_interfaces::NodeGraphInterface</a>.</p>

</div>
</div>
<a id="a8a92aaf6aff34687a431dafa4520e290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a92aaf6aff34687a431dafa4520e290">&#9670;&nbsp;</a></span>get_graph_guard_condition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const rcl_guard_condition_t* rclcpp::node_interfaces::NodeGraph::get_graph_guard_condition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the rcl guard condition which is triggered when the ROS graph changes. </p>

<p>Implements <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html#ac4bc15b80573f2139e131db5c66e35e0">rclcpp::node_interfaces::NodeGraphInterface</a>.</p>

</div>
</div>
<a id="ab3fb4a7f5c875f7dd126f2ceed8b2c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3fb4a7f5c875f7dd126f2ceed8b2c4c">&#9670;&nbsp;</a></span>notify_graph_change()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::node_interfaces::NodeGraph::notify_graph_change </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify threads waiting on graph changes. </p>
<p>Affects threads waiting on the notify guard condition, see: get_notify_guard_condition(), as well as the threads waiting on graph changes using a graph <a class="el" href="classrclcpp_1_1Event.html">Event</a>, see: <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#a30d5cf2d4d38cf410d72bf3ae459d6e1" title="Wait for a graph event to occur by waiting on an Event to become set.">wait_for_graph_change()</a>.</p>
<p>This is typically only used by the <a class="el" href="classrclcpp_1_1graph__listener_1_1GraphListener.html" title="Notifies many nodes of graph changes by listening in a thread.">rclcpp::graph_listener::GraphListener</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">RCLBaseError</td><td>(a child of that exception) when an rcl error occurs </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html#a5bd573aeebdbc9d70ed8f0e0fc7f1049">rclcpp::node_interfaces::NodeGraphInterface</a>.</p>

</div>
</div>
<a id="afde53f8adde6584712705b85c09c955a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde53f8adde6584712705b85c09c955a">&#9670;&nbsp;</a></span>notify_shutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::node_interfaces::NodeGraph::notify_shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify any and all blocking node actions that shutdown has occurred. </p>

<p>Implements <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html#ad4ea2c5addd1a4cd8b3866bfc935a681">rclcpp::node_interfaces::NodeGraphInterface</a>.</p>

</div>
</div>
<a id="a5d7406637a5de005f8d25f1b68eb29db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7406637a5de005f8d25f1b68eb29db">&#9670;&nbsp;</a></span>get_graph_event()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::Event::SharedPtr rclcpp::node_interfaces::NodeGraph::get_graph_event </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a graph event, which will be set anytime a graph change occurs. </p>
<p>The graph <a class="el" href="classrclcpp_1_1Event.html">Event</a> object is a loan which must be returned. The <a class="el" href="classrclcpp_1_1Event.html">Event</a> object is scoped and therefore to return the load just let it go out of scope. </p>

<p>Implements <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html#a6d80bdf76f79254fa80f1b1b527d1446">rclcpp::node_interfaces::NodeGraphInterface</a>.</p>

</div>
</div>
<a id="a30d5cf2d4d38cf410d72bf3ae459d6e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d5cf2d4d38cf410d72bf3ae459d6e1">&#9670;&nbsp;</a></span>wait_for_graph_change()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::node_interfaces::NodeGraph::wait_for_graph_change </td>
          <td>(</td>
          <td class="paramtype">rclcpp::Event::SharedPtr&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for a graph event to occur by waiting on an <a class="el" href="classrclcpp_1_1Event.html">Event</a> to become set. </p>
<p>The given <a class="el" href="classrclcpp_1_1Event.html">Event</a> must be acquire through the <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#a5d7406637a5de005f8d25f1b68eb29db" title="Return a graph event, which will be set anytime a graph change occurs.">get_graph_event()</a> method.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidEventError</td><td>if the given event is nullptr </td></tr>
    <tr><td class="paramname">EventNotRegisteredError</td><td>if the given event was not acquired with <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#a5d7406637a5de005f8d25f1b68eb29db" title="Return a graph event, which will be set anytime a graph change occurs.">get_graph_event()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html#a6da052e3f08251b5083b6af953c71a37">rclcpp::node_interfaces::NodeGraphInterface</a>.</p>

</div>
</div>
<a id="a45992a5266ddaf2195b50f078bfeab48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45992a5266ddaf2195b50f078bfeab48">&#9670;&nbsp;</a></span>count_graph_users()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t rclcpp::node_interfaces::NodeGraph::count_graph_users </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of on loan graph events, see <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraph.html#a5d7406637a5de005f8d25f1b68eb29db" title="Return a graph event, which will be set anytime a graph change occurs.">get_graph_event()</a>. </p>
<p>This is typically only used by the <a class="el" href="classrclcpp_1_1graph__listener_1_1GraphListener.html" title="Notifies many nodes of graph changes by listening in a thread.">rclcpp::graph_listener::GraphListener</a>. </p>

<p>Implements <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html#a098880c2cd29d8fb1253986301c125a1">rclcpp::node_interfaces::NodeGraphInterface</a>.</p>

</div>
</div>
<a id="ae191391ef7f70941f4c52256ac4e8e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae191391ef7f70941f4c52256ac4e8e14">&#9670;&nbsp;</a></span>get_publishers_info_by_topic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classrclcpp_1_1TopicEndpointInfo.html">rclcpp::TopicEndpointInfo</a>&gt; rclcpp::node_interfaces::NodeGraph::get_publishers_info_by_topic </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_mangle</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the topic endpoint information about publishers on a given topic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topic_name</td><td>the actual topic name used; it will not be automatically remapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_mangle</td><td>if <code>true</code>, <code>topic_name</code> needs to be a valid middleware topic name, otherwise it should be a valid ROS topic name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Node.html#a08220daf1d66596012e858d19efd1212" title="Return the topic endpoint information about publishers on a given topic.">rclcpp::Node::get_publishers_info_by_topic</a> </dd></dl>

<p>Implements <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html#ad2b5d4374ee406329dcc431a41bfa135">rclcpp::node_interfaces::NodeGraphInterface</a>.</p>

</div>
</div>
<a id="ae7b268ba5135700db7e99bf9b7f1355b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b268ba5135700db7e99bf9b7f1355b">&#9670;&nbsp;</a></span>get_subscriptions_info_by_topic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classrclcpp_1_1TopicEndpointInfo.html">rclcpp::TopicEndpointInfo</a>&gt; rclcpp::node_interfaces::NodeGraph::get_subscriptions_info_by_topic </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_mangle</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the topic endpoint information about subscriptions on a given topic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topic_name</td><td>the actual topic name used; it will not be automatically remapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_mangle</td><td>if <code>true</code>, <code>topic_name</code> needs to be a valid middleware topic name, otherwise it should be a valid ROS topic name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Node.html#afba993c401901433b3c8647ef716c7e4" title="Return the topic endpoint information about subscriptions on a given topic.">rclcpp::Node::get_subscriptions_info_by_topic</a> </dd></dl>

<p>Implements <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html#ab81e3c07e21c1abdead0a5e0822f77e1">rclcpp::node_interfaces::NodeGraphInterface</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/rclcpp/node_interfaces/<a class="el" href="node__graph_8hpp_source.html">node_graph.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
