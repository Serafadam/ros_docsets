<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rclcpp: rclcpp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rclcpp
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C++ ROS Client Library API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rclcpp Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Versions of rosidl_typesupport_cpp::get_message_type_support_handle that handle adapted types.  
<a href="namespacerclcpp.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacerclcpp_1_1allocator"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp_1_1allocator.html">allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerclcpp_1_1contexts"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp_1_1contexts.html">contexts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerclcpp_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerclcpp_1_1exceptions"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp_1_1exceptions.html">exceptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerclcpp_1_1executors"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp_1_1executors.html">executors</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerclcpp_1_1experimental"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp_1_1experimental.html">experimental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerclcpp_1_1function__traits"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp_1_1function__traits.html">function_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerclcpp_1_1graph__listener"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp_1_1graph__listener.html">graph_listener</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerclcpp_1_1memory__strategies"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp_1_1memory__strategies.html">memory_strategies</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerclcpp_1_1memory__strategy"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp_1_1memory__strategy.html">memory_strategy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerclcpp_1_1message__memory__strategy"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp_1_1message__memory__strategy.html">message_memory_strategy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerclcpp_1_1node__interfaces"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp_1_1node__interfaces.html">node_interfaces</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerclcpp_1_1serialization__traits"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp_1_1serialization__traits.html">serialization_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerclcpp_1_1strategies"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp_1_1strategies.html">strategies</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerclcpp_1_1subscription__traits"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp_1_1subscription__traits.html">subscription_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerclcpp_1_1topic__statistics"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp_1_1topic__statistics.html">topic_statistics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerclcpp_1_1type__support"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp_1_1type__support.html">type_support</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerclcpp_1_1wait__set__policies"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp_1_1wait__set__policies.html">wait_set_policies</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1AnyExecutable.html">AnyExecutable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Service.html">Service</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1AnyServiceCallback.html">AnyServiceCallback</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1AnySubscriptionCallback.html">AnySubscriptionCallback</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1CallbackGroup.html">CallbackGroup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1ClientBase.html">ClientBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Client.html">Client</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1JumpHandler.html">JumpHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Clock.html">Clock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1ContextAlreadyInitialized.html">ContextAlreadyInitialized</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when init is called on an already initialized context.  <a href="classrclcpp_1_1ContextAlreadyInitialized.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1ShutdownCallbackHandle.html">ShutdownCallbackHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Context.html">Context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classrclcpp_1_1Context.html" title="Context which encapsulates shared state between nodes and other similar entities.">Context</a> which encapsulates shared state between nodes and other similar entities.  <a href="classrclcpp_1_1Context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Duration.html">Duration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Event.html">Event</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html">Executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coordinate the order and timing of available communication tasks.  <a href="classrclcpp_1_1Executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1ExecutorOptions.html">ExecutorOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to be passed to the executor constructor.  <a href="structrclcpp_1_1ExecutorOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1GenericPublisher.html">GenericPublisher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publisher for serialized messages whose type is not known at compile time.  <a href="classrclcpp_1_1GenericPublisher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1GenericSubscription.html">GenericSubscription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscription for serialized messages whose type is not known at compile time.  <a href="classrclcpp_1_1GenericSubscription.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1GuardCondition.html">GuardCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A condition that can be waited on in a single wait set and asynchronously triggered.  <a href="classrclcpp_1_1GuardCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1InitOptions.html">InitOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulation of options for initializing rclcpp.  <a href="classrclcpp_1_1InitOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1is__ros__compatible__type.html">is_ros_compatible_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1LoanedMessage.html">LoanedMessage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Logger.html">Logger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1MessageInfo.html">MessageInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional meta data about messages taken from subscriptions.  <a href="classrclcpp_1_1MessageInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1NetworkFlowEndpoint.html">NetworkFlowEndpoint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> is the single point of entry for creating publishers and subscribers.  <a href="classrclcpp_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1TopicEndpointInfo.html">TopicEndpointInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1NodeOptions.html">NodeOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulation of options for node initialization.  <a href="classrclcpp_1_1NodeOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Parameter.html">Parameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to store an arbitrary parameter with templated get/set methods.  <a href="classrclcpp_1_1Parameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1AsyncParametersClient.html">AsyncParametersClient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SyncParametersClient.html">SyncParametersClient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1ParameterCallbackHandle.html">ParameterCallbackHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1ParameterEventCallbackHandle.html">ParameterEventCallbackHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1ParameterEventHandler.html">ParameterEventHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class used to "handle" (monitor and respond to) changes to parameters.  <a href="classrclcpp_1_1ParameterEventHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1ParameterEventsFilter.html">ParameterEventsFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1ParameterService.html">ParameterService</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1ParameterTypeException.html">ParameterTypeException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate the parameter type does not match the expected type.  <a href="classrclcpp_1_1ParameterTypeException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1ParameterValue.html">ParameterValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the type and value of a parameter.  <a href="classrclcpp_1_1ParameterValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Publisher.html">Publisher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A publisher publishes messages of any type to a topic.  <a href="classrclcpp_1_1Publisher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1PublisherBase.html">PublisherBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1PublisherFactory.html">PublisherFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory with functions used to create a MessageT specific PublisherT.  <a href="structrclcpp_1_1PublisherFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1PublisherOptionsBase.html">PublisherOptionsBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-templated part of PublisherOptionsWithAllocator&lt;Allocator&gt;.  <a href="structrclcpp_1_1PublisherOptionsBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">PublisherOptionsWithAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure containing optional configuration for Publishers.  <a href="structrclcpp_1_1PublisherOptionsWithAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1QoSInitialization.html">QoSInitialization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">QoS</a> initialization values, cannot be created directly, use <a class="el" href="structrclcpp_1_1KeepAll.html" title="Use to initialize the QoS with the keep_all history setting.">KeepAll</a> or <a class="el" href="structrclcpp_1_1KeepLast.html" title="Use to initialize the QoS with the keep_last history setting and the given depth.">KeepLast</a> instead.  <a href="structrclcpp_1_1QoSInitialization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1KeepAll.html">KeepAll</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to initialize the <a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">QoS</a> with the keep_all history setting.  <a href="structrclcpp_1_1KeepAll.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1KeepLast.html">KeepLast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to initialize the <a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">QoS</a> with the keep_last history setting and the given depth.  <a href="structrclcpp_1_1KeepLast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1QoS.html">QoS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulation of Quality of <a class="el" href="classrclcpp_1_1Service.html">Service</a> settings.  <a href="classrclcpp_1_1QoS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1QoSCheckCompatibleResult.html">QoSCheckCompatibleResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type for checking <a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">QoS</a> compatibility.  <a href="structrclcpp_1_1QoSCheckCompatibleResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1ClockQoS.html">ClockQoS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SensorDataQoS.html">SensorDataQoS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1ParametersQoS.html">ParametersQoS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1ServicesQoS.html">ServicesQoS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1ParameterEventsQoS.html">ParameterEventsQoS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1RosoutQoS.html">RosoutQoS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SystemDefaultsQoS.html">SystemDefaultsQoS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1PublisherEventCallbacks.html">PublisherEventCallbacks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains callbacks for various types of events a <a class="el" href="classrclcpp_1_1Publisher.html" title="A publisher publishes messages of any type to a topic.">Publisher</a> can receive from the middleware.  <a href="structrclcpp_1_1PublisherEventCallbacks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1SubscriptionEventCallbacks.html">SubscriptionEventCallbacks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains callbacks for non-message events that a <a class="el" href="classrclcpp_1_1Subscription.html" title="Subscription implementation, templated on the type of message this subscription receives.">Subscription</a> can receive from the middleware.  <a href="structrclcpp_1_1SubscriptionEventCallbacks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1UnsupportedEventTypeException.html">UnsupportedEventTypeException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1QOSEventHandlerBase.html">QOSEventHandlerBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1QOSEventHandler.html">QOSEventHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1QosOverridingOptions.html">QosOverridingOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options that are passed in subscription/publisher constructor to specify QoSConfigurability.  <a href="classrclcpp_1_1QosOverridingOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1RateBase.html">RateBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1GenericRate.html">GenericRate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1ScopeExit.html">ScopeExit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SerializationBase.html">SerializationBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to (de)serialize a message.  <a href="classrclcpp_1_1SerializationBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Serialization.html">Serialization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation to (de)serialize a message by using rmw_(de)serialize.  <a href="classrclcpp_1_1Serialization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SerializedMessage.html">SerializedMessage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object oriented version of rcl_serialized_message_t with destructor to avoid memory leaks.  <a href="classrclcpp_1_1SerializedMessage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1ServiceBase.html">ServiceBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Subscription.html">Subscription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classrclcpp_1_1Subscription.html" title="Subscription implementation, templated on the type of message this subscription receives.">Subscription</a> implementation, templated on the type of message this subscription receives.  <a href="classrclcpp_1_1Subscription.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionBase.html">SubscriptionBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1ContentFilterOptions.html">ContentFilterOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to configure content filtered topic in the subscription.  <a href="structrclcpp_1_1ContentFilterOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1SubscriptionFactory.html">SubscriptionFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory containing a function used to create a Subscription&lt;MessageT&gt;.  <a href="structrclcpp_1_1SubscriptionFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1SubscriptionOptionsBase.html">SubscriptionOptionsBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-template base class for subscription options.  <a href="structrclcpp_1_1SubscriptionOptionsBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">SubscriptionOptionsWithAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure containing optional configuration for Subscriptions.  <a href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1SubscriptionWaitSetMask.html">SubscriptionWaitSetMask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options used to determine what parts of a subscription get added to or removed from a wait set.  <a href="classrclcpp_1_1SubscriptionWaitSetMask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Time.html">Time</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1TimeSource.html">TimeSource</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1TimerBase.html">TimerBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1GenericTimer.html">GenericTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic timer. Periodically executes a user-specified callback.  <a href="classrclcpp_1_1GenericTimer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1WallTimer.html">WallTimer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1TypeAdapter.html">TypeAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template structure used to adapt custom, user-defined types to ROS types.  <a href="structrclcpp_1_1TypeAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1is__type__adapter.html">is_type_adapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template to determine if a type is a <a class="el" href="structrclcpp_1_1TypeAdapter.html" title="Template structure used to adapt custom, user-defined types to ROS types.">TypeAdapter</a>, false specialization.  <a href="structrclcpp_1_1is__type__adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1is__type__adapter_3_01TypeAdapter_3_01Ts_8_8_8_01_4_01_4.html">is_type_adapter&lt; TypeAdapter&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template to determine if a type is a <a class="el" href="structrclcpp_1_1TypeAdapter.html" title="Template structure used to adapt custom, user-defined types to ROS types.">TypeAdapter</a>, true specialization.  <a href="structrclcpp_1_1is__type__adapter_3_01TypeAdapter_3_01Ts_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1TypeAdapter_3_01T_00_01void_00_01std_1_1enable__if__t_3_01is__type__adapter_3_01T_01_4_1_1value_01_4_01_4.html">TypeAdapter&lt; T, void, std::enable_if_t&lt; is_type_adapter&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity specialization for <a class="el" href="structrclcpp_1_1TypeAdapter.html" title="Template structure used to adapt custom, user-defined types to ROS types.">TypeAdapter</a>.  <a href="structrclcpp_1_1TypeAdapter_3_01T_00_01void_00_01std_1_1enable__if__t_3_01is__type__adapter_3_01T_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1adapt__type.html">adapt_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metafunction that can make the type being adapted explicit.  <a href="structrclcpp_1_1adapt__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1ImplicitTypeAdapter.html">ImplicitTypeAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit type adapter used as a short hand way to create something with just the custom type.  <a href="structrclcpp_1_1ImplicitTypeAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrclcpp_1_1TypeAdapter_3_01T_00_01void_00_01std_1_1enable__if__t_3_01ImplicitTypeAdapter_3_306ff5daea470edb219db2c25130281c.html">TypeAdapter&lt; T, void, std::enable_if_t&lt; ImplicitTypeAdapter&lt; T &gt;::is_specialized::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structrclcpp_1_1TypeAdapter.html" title="Template structure used to adapt custom, user-defined types to ROS types.">TypeAdapter</a> for <a class="el" href="structrclcpp_1_1ImplicitTypeAdapter.html" title="Implicit type adapter used as a short hand way to create something with just the custom type.">ImplicitTypeAdapter</a>.  <a href="structrclcpp_1_1TypeAdapter_3_01T_00_01void_00_01std_1_1enable__if__t_3_01ImplicitTypeAdapter_3_306ff5daea470edb219db2c25130281c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1WaitResult.html">WaitResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for introspecting a wait set after waiting on it.  <a href="classrclcpp_1_1WaitResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1WaitSetTemplate.html">WaitSetTemplate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates sets of waitable items which can be waited on as a group.  <a href="classrclcpp_1_1WaitSetTemplate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5da79bfb6561c87736d5b49f30a4d0f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a5da79bfb6561c87736d5b49f30a4d0f2">OnShutdownCallbackHandle</a> = <a class="el" href="classrclcpp_1_1ShutdownCallbackHandle.html">ShutdownCallbackHandle</a></td></tr>
<tr class="separator:a5da79bfb6561c87736d5b49f30a4d0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c8d247dce6ecea5941201ba33ae2b4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a11c8d247dce6ecea5941201ba33ae2b4">PreShutdownCallbackHandle</a> = <a class="el" href="classrclcpp_1_1ShutdownCallbackHandle.html">ShutdownCallbackHandle</a></td></tr>
<tr class="separator:a11c8d247dce6ecea5941201ba33ae2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de5071053a1993f126aaa3a907ae649"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; rclcpp::CallbackGroup::WeakPtr, rclcpp::node_interfaces::NodeBaseInterface::WeakPtr, std::owner_less&lt; rclcpp::CallbackGroup::WeakPtr &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a></td></tr>
<tr class="separator:a5de5071053a1993f126aaa3a907ae649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa587f11d0e53c713ccc0addf5132d46a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#aa587f11d0e53c713ccc0addf5132d46a">ParameterMap</a> = std::unordered_map&lt; std::string, std::vector&lt; <a class="el" href="classrclcpp_1_1Parameter.html">Parameter</a> &gt; &gt;</td></tr>
<tr class="memdesc:aa587f11d0e53c713ccc0addf5132d46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map of fully qualified node names to a list of parameters.  <a href="namespacerclcpp.html#aa587f11d0e53c713ccc0addf5132d46a">More...</a><br /></td></tr>
<tr class="separator:aa587f11d0e53c713ccc0addf5132d46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f38e986e5843aa39fc2b9fff9cf927f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a9f38e986e5843aa39fc2b9fff9cf927f">PublisherOptions</a> = <a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">PublisherOptionsWithAllocator</a>&lt; std::allocator&lt; void &gt; &gt;</td></tr>
<tr class="separator:a9f38e986e5843aa39fc2b9fff9cf927f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f406f0e8e4928bd5490d5b170c2c3b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a51f406f0e8e4928bd5490d5b170c2c3b">QOSDeadlineRequestedInfo</a> = rmw_requested_deadline_missed_status_t</td></tr>
<tr class="separator:a51f406f0e8e4928bd5490d5b170c2c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf85a88396716dfeff77447176ed05c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#aedf85a88396716dfeff77447176ed05c">QOSDeadlineOfferedInfo</a> = rmw_offered_deadline_missed_status_t</td></tr>
<tr class="separator:aedf85a88396716dfeff77447176ed05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144fad513d523f56d77a071740da8d11"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a144fad513d523f56d77a071740da8d11">QOSLivelinessChangedInfo</a> = rmw_liveliness_changed_status_t</td></tr>
<tr class="separator:a144fad513d523f56d77a071740da8d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a89114d63f459ecc69241fa4f0dfc1f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a0a89114d63f459ecc69241fa4f0dfc1f">QOSLivelinessLostInfo</a> = rmw_liveliness_lost_status_t</td></tr>
<tr class="separator:a0a89114d63f459ecc69241fa4f0dfc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3a2cfc089710ffbe4b46c5f5f6bf51"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a0d3a2cfc089710ffbe4b46c5f5f6bf51">QOSMessageLostInfo</a> = rmw_message_lost_status_t</td></tr>
<tr class="separator:a0d3a2cfc089710ffbe4b46c5f5f6bf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6174538b0f569e38ba3be09812ad54c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#af6174538b0f569e38ba3be09812ad54c">QOSOfferedIncompatibleQoSInfo</a> = rmw_offered_qos_incompatible_event_status_t</td></tr>
<tr class="separator:af6174538b0f569e38ba3be09812ad54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c69f1ce0937b36bc3915e989fb9faf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a26c69f1ce0937b36bc3915e989fb9faf">QOSRequestedIncompatibleQoSInfo</a> = rmw_requested_qos_incompatible_event_status_t</td></tr>
<tr class="separator:a26c69f1ce0937b36bc3915e989fb9faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742c7a1550bb04d91fc14f92adffd218"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a742c7a1550bb04d91fc14f92adffd218">QOSDeadlineRequestedCallbackType</a> = std::function&lt; void(<a class="el" href="namespacerclcpp.html#a51f406f0e8e4928bd5490d5b170c2c3b">QOSDeadlineRequestedInfo</a> &amp;)&gt;</td></tr>
<tr class="separator:a742c7a1550bb04d91fc14f92adffd218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6987cb949f1c2992beb9887311a5b6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#abb6987cb949f1c2992beb9887311a5b6">QOSDeadlineOfferedCallbackType</a> = std::function&lt; void(<a class="el" href="namespacerclcpp.html#aedf85a88396716dfeff77447176ed05c">QOSDeadlineOfferedInfo</a> &amp;)&gt;</td></tr>
<tr class="separator:abb6987cb949f1c2992beb9887311a5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51148cfeddce96db7ad911fa893a4d82"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a51148cfeddce96db7ad911fa893a4d82">QOSLivelinessChangedCallbackType</a> = std::function&lt; void(<a class="el" href="namespacerclcpp.html#a144fad513d523f56d77a071740da8d11">QOSLivelinessChangedInfo</a> &amp;)&gt;</td></tr>
<tr class="separator:a51148cfeddce96db7ad911fa893a4d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33673fe9ebe74818bc56d517eae84a03"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a33673fe9ebe74818bc56d517eae84a03">QOSLivelinessLostCallbackType</a> = std::function&lt; void(<a class="el" href="namespacerclcpp.html#a0a89114d63f459ecc69241fa4f0dfc1f">QOSLivelinessLostInfo</a> &amp;)&gt;</td></tr>
<tr class="separator:a33673fe9ebe74818bc56d517eae84a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5992e56be639d6edfa7d41ac2e8ebfbb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a5992e56be639d6edfa7d41ac2e8ebfbb">QOSMessageLostCallbackType</a> = std::function&lt; void(<a class="el" href="namespacerclcpp.html#a0d3a2cfc089710ffbe4b46c5f5f6bf51">QOSMessageLostInfo</a> &amp;)&gt;</td></tr>
<tr class="separator:a5992e56be639d6edfa7d41ac2e8ebfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859176cdce7e529ada6dfa9b0c41be24"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a859176cdce7e529ada6dfa9b0c41be24">QOSOfferedIncompatibleQoSCallbackType</a> = std::function&lt; void(<a class="el" href="namespacerclcpp.html#af6174538b0f569e38ba3be09812ad54c">QOSOfferedIncompatibleQoSInfo</a> &amp;)&gt;</td></tr>
<tr class="separator:a859176cdce7e529ada6dfa9b0c41be24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ae5f255085a1ee084a83b7b8ec4ddb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#ab7ae5f255085a1ee084a83b7b8ec4ddb">QOSRequestedIncompatibleQoSCallbackType</a> = std::function&lt; void(<a class="el" href="namespacerclcpp.html#a26c69f1ce0937b36bc3915e989fb9faf">QOSRequestedIncompatibleQoSInfo</a> &amp;)&gt;</td></tr>
<tr class="separator:ab7ae5f255085a1ee084a83b7b8ec4ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0998d12a1177c3019bbeb278a91f6698"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a0998d12a1177c3019bbeb278a91f6698">QosCallbackResult</a> = rcl_interfaces::msg::SetParametersResult</td></tr>
<tr class="separator:a0998d12a1177c3019bbeb278a91f6698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43bf8aa3d3ba663a8890b43f8db8c46"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#ad43bf8aa3d3ba663a8890b43f8db8c46">QosCallback</a> = std::function&lt; <a class="el" href="namespacerclcpp.html#a0998d12a1177c3019bbeb278a91f6698">QosCallbackResult</a>(const <a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> &amp;)&gt;</td></tr>
<tr class="separator:ad43bf8aa3d3ba663a8890b43f8db8c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6d4a275a0f75ba817c8486f641f4ea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#abe6d4a275a0f75ba817c8486f641f4ea">Rate</a> = <a class="el" href="classrclcpp_1_1GenericRate.html">GenericRate</a>&lt; std::chrono::system_clock &gt;</td></tr>
<tr class="separator:abe6d4a275a0f75ba817c8486f641f4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c57364eb16ca720485d170ee5b99cf7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a9c57364eb16ca720485d170ee5b99cf7">WallRate</a> = <a class="el" href="classrclcpp_1_1GenericRate.html">GenericRate</a>&lt; std::chrono::steady_clock &gt;</td></tr>
<tr class="separator:a9c57364eb16ca720485d170ee5b99cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ce420d67bb40b61156347455d3ad23"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#aa0ce420d67bb40b61156347455d3ad23">SubscriptionOptions</a> = <a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">SubscriptionOptionsWithAllocator</a>&lt; std::allocator&lt; void &gt; &gt;</td></tr>
<tr class="separator:aa0ce420d67bb40b61156347455d3ad23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba01c682b9c93b3ff844cc36ea80fda1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#aba01c682b9c93b3ff844cc36ea80fda1">VoidCallbackType</a> = std::function&lt; void()&gt;</td></tr>
<tr class="separator:aba01c682b9c93b3ff844cc36ea80fda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bb5a91fd8ef745ce261338f803fc9e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#aa6bb5a91fd8ef745ce261338f803fc9e">TimerCallbackType</a> = std::function&lt; void(<a class="el" href="classrclcpp_1_1TimerBase.html">TimerBase</a> &amp;)&gt;</td></tr>
<tr class="separator:aa6bb5a91fd8ef745ce261338f803fc9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fb19c154de27e92430309d2da25ac3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#ad6fb19c154de27e92430309d2da25ac3">WaitSet</a> = <a class="el" href="classrclcpp_1_1WaitSetTemplate.html">rclcpp::WaitSetTemplate</a>&lt; <a class="el" href="classrclcpp_1_1wait__set__policies_1_1SequentialSynchronization.html">rclcpp::wait_set_policies::SequentialSynchronization</a>, <a class="el" href="classrclcpp_1_1wait__set__policies_1_1DynamicStorage.html">rclcpp::wait_set_policies::DynamicStorage</a> &gt;</td></tr>
<tr class="memdesc:ad6fb19c154de27e92430309d2da25ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most common user configuration of a WaitSet, which is dynamic but not thread-safe.  <a href="namespacerclcpp.html#ad6fb19c154de27e92430309d2da25ac3">More...</a><br /></td></tr>
<tr class="separator:ad6fb19c154de27e92430309d2da25ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb06acf4a5723b1445fa6ed4e8f73374"><td class="memTemplParams" colspan="2">template&lt;std::size_t NumberOfSubscriptions, std::size_t NumberOfGuardCondtions, std::size_t NumberOfTimers, std::size_t NumberOfClients, std::size_t NumberOfServices, std::size_t NumberOfWaitables&gt; </td></tr>
<tr class="memitem:adb06acf4a5723b1445fa6ed4e8f73374"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#adb06acf4a5723b1445fa6ed4e8f73374">StaticWaitSet</a> = <a class="el" href="classrclcpp_1_1WaitSetTemplate.html">rclcpp::WaitSetTemplate</a>&lt; <a class="el" href="classrclcpp_1_1wait__set__policies_1_1SequentialSynchronization.html">rclcpp::wait_set_policies::SequentialSynchronization</a>, <a class="el" href="classrclcpp_1_1wait__set__policies_1_1StaticStorage.html">rclcpp::wait_set_policies::StaticStorage</a>&lt; NumberOfSubscriptions, NumberOfGuardCondtions, NumberOfTimers, NumberOfClients, NumberOfServices, NumberOfWaitables &gt; &gt;</td></tr>
<tr class="memdesc:adb06acf4a5723b1445fa6ed4e8f73374"><td class="mdescLeft">&#160;</td><td class="mdescRight">WaitSet configuration which does not allow changes after construction.  <a href="namespacerclcpp.html#adb06acf4a5723b1445fa6ed4e8f73374">More...</a><br /></td></tr>
<tr class="separator:adb06acf4a5723b1445fa6ed4e8f73374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaec573e71549fd3078644e18e7f7127"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#acaec573e71549fd3078644e18e7f7127">ThreadSafeWaitSet</a> = <a class="el" href="classrclcpp_1_1WaitSetTemplate.html">rclcpp::WaitSetTemplate</a>&lt; <a class="el" href="classrclcpp_1_1wait__set__policies_1_1ThreadSafeSynchronization.html">rclcpp::wait_set_policies::ThreadSafeSynchronization</a>, <a class="el" href="classrclcpp_1_1wait__set__policies_1_1DynamicStorage.html">rclcpp::wait_set_policies::DynamicStorage</a> &gt;</td></tr>
<tr class="memdesc:acaec573e71549fd3078644e18e7f7127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like WaitSet, this configuration is dynamic, but is also thread-safe.  <a href="namespacerclcpp.html#acaec573e71549fd3078644e18e7f7127">More...</a><br /></td></tr>
<tr class="separator:acaec573e71549fd3078644e18e7f7127"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a0027d5804ef28f0b6fea8eea4195c44a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a0027d5804ef28f0b6fea8eea4195c44a">CallbackGroupType</a> { <a class="el" href="namespacerclcpp.html#a0027d5804ef28f0b6fea8eea4195c44aa0a658d9024420a1c2f737e8881406f7d">MutuallyExclusive</a>
, <a class="el" href="namespacerclcpp.html#a0027d5804ef28f0b6fea8eea4195c44aa49816c033d9f3ad7e81fdb953fe3251f">Reentrant</a>
 }</td></tr>
<tr class="separator:a0027d5804ef28f0b6fea8eea4195c44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4ff5f1e516740d7e11ea97fe6f5532"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a7b4ff5f1e516740d7e11ea97fe6f5532">FutureReturnCode</a> { <a class="el" href="namespacerclcpp.html#a7b4ff5f1e516740d7e11ea97fe6f5532ad0749aaba8b833466dfcbb0428e4f89c">SUCCESS</a>
, <a class="el" href="namespacerclcpp.html#a7b4ff5f1e516740d7e11ea97fe6f5532a658f2cadfdf09b6046246e9314f7cd43">INTERRUPTED</a>
, <a class="el" href="namespacerclcpp.html#a7b4ff5f1e516740d7e11ea97fe6f5532a070a0fb40f6c308ab544b227660aadff">TIMEOUT</a>
 }</td></tr>
<tr class="memdesc:a7b4ff5f1e516740d7e11ea97fe6f5532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return codes to be used with spin_until_future_complete.  <a href="namespacerclcpp.html#a7b4ff5f1e516740d7e11ea97fe6f5532">More...</a><br /></td></tr>
<tr class="separator:a7b4ff5f1e516740d7e11ea97fe6f5532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c5da68d5964c6bd7894afe4a76a92b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a53c5da68d5964c6bd7894afe4a76a92b">IntraProcessBufferType</a> { <a class="el" href="namespacerclcpp.html#a53c5da68d5964c6bd7894afe4a76a92ba309589a0fa2f1ec5e6b286ac5e8b6ac8">SharedPtr</a>
, <a class="el" href="namespacerclcpp.html#a53c5da68d5964c6bd7894afe4a76a92ba8c4322b401772928915c5a3ada1304d5">UniquePtr</a>
, <a class="el" href="namespacerclcpp.html#a53c5da68d5964c6bd7894afe4a76a92ba50c8a640832cc7a38533a3d5d3da60df">CallbackDefault</a>
 }</td></tr>
<tr class="separator:a53c5da68d5964c6bd7894afe4a76a92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebc5fdfcb7e3f025f8ebc2fe1d10fe5"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a2ebc5fdfcb7e3f025f8ebc2fe1d10fe5">IntraProcessSetting</a> { <a class="el" href="namespacerclcpp.html#a2ebc5fdfcb7e3f025f8ebc2fe1d10fe5a2faec1f9f8cc7f8f40d521c4dd574f49">Enable</a>
, <a class="el" href="namespacerclcpp.html#a2ebc5fdfcb7e3f025f8ebc2fe1d10fe5abcfaccebf745acfd5e75351095a5394a">Disable</a>
, <a class="el" href="namespacerclcpp.html#a2ebc5fdfcb7e3f025f8ebc2fe1d10fe5a5e7bd84eadd196f52e8320680fa1c7cf">NodeDefault</a>
 }</td></tr>
<tr class="memdesc:a2ebc5fdfcb7e3f025f8ebc2fe1d10fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used as argument in create_publisher and create_subscriber.  <a href="namespacerclcpp.html#a2ebc5fdfcb7e3f025f8ebc2fe1d10fe5">More...</a><br /></td></tr>
<tr class="separator:a2ebc5fdfcb7e3f025f8ebc2fe1d10fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47a956a91d1787241c564827be18aa5"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#ad47a956a91d1787241c564827be18aa5">EndpointType</a> { <a class="el" href="namespacerclcpp.html#ad47a956a91d1787241c564827be18aa5a4bbb8f967da6d1a610596d7257179c2b">Invalid</a> = RMW_ENDPOINT_INVALID
, <a class="el" href="namespacerclcpp.html#ad47a956a91d1787241c564827be18aa5a32c73be0cb175da278c8e2af0811b0d1">Publisher</a> = RMW_ENDPOINT_PUBLISHER
, <a class="el" href="namespacerclcpp.html#ad47a956a91d1787241c564827be18aa5a787ad0b7a17de4ad6b1711bbf8d79fcb">Subscription</a> = RMW_ENDPOINT_SUBSCRIPTION
 }</td></tr>
<tr class="separator:ad47a956a91d1787241c564827be18aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b307a4b7368b68f325812cd2aeb8784"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a1b307a4b7368b68f325812cd2aeb8784">ParameterType</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacerclcpp.html#a1b307a4b7368b68f325812cd2aeb8784adefddb470d1054265245a0c5dbeccf4e">PARAMETER_NOT_SET</a> = rcl_interfaces::msg::ParameterType::PARAMETER_NOT_SET
, <a class="el" href="namespacerclcpp.html#a1b307a4b7368b68f325812cd2aeb8784a525d4dd60c307e7fb76d57cdeafce8b1">PARAMETER_BOOL</a> = rcl_interfaces::msg::ParameterType::PARAMETER_BOOL
, <a class="el" href="namespacerclcpp.html#a1b307a4b7368b68f325812cd2aeb8784a3a70ea9e9528656834106cf8a647e878">PARAMETER_INTEGER</a> = rcl_interfaces::msg::ParameterType::PARAMETER_INTEGER
, <a class="el" href="namespacerclcpp.html#a1b307a4b7368b68f325812cd2aeb8784a21dd7d8db14cc732692bea98eb073c20">PARAMETER_DOUBLE</a> = rcl_interfaces::msg::ParameterType::PARAMETER_DOUBLE
, <br />
&#160;&#160;<a class="el" href="namespacerclcpp.html#a1b307a4b7368b68f325812cd2aeb8784a1ed2b44e2043e3cf925a1891e19fd73a">PARAMETER_STRING</a> = rcl_interfaces::msg::ParameterType::PARAMETER_STRING
, <a class="el" href="namespacerclcpp.html#a1b307a4b7368b68f325812cd2aeb8784aac6f099e5c9b63fd51a75ae587a98271">PARAMETER_BYTE_ARRAY</a> = rcl_interfaces::msg::ParameterType::PARAMETER_BYTE_ARRAY
, <a class="el" href="namespacerclcpp.html#a1b307a4b7368b68f325812cd2aeb8784ab14cef41f8d8d14f9beef95eeb6dd91d">PARAMETER_BOOL_ARRAY</a> = rcl_interfaces::msg::ParameterType::PARAMETER_BOOL_ARRAY
, <a class="el" href="namespacerclcpp.html#a1b307a4b7368b68f325812cd2aeb8784a5b5c50ef3c04a90a59a31b3ad20a4495">PARAMETER_INTEGER_ARRAY</a> = rcl_interfaces::msg::ParameterType::PARAMETER_INTEGER_ARRAY
, <br />
&#160;&#160;<a class="el" href="namespacerclcpp.html#a1b307a4b7368b68f325812cd2aeb8784af685d20a1a39f3531732919ee99f44ab">PARAMETER_DOUBLE_ARRAY</a> = rcl_interfaces::msg::ParameterType::PARAMETER_DOUBLE_ARRAY
, <a class="el" href="namespacerclcpp.html#a1b307a4b7368b68f325812cd2aeb8784ab19e036eb99725754e11c35c6f8d9eb1">PARAMETER_STRING_ARRAY</a> = rcl_interfaces::msg::ParameterType::PARAMETER_STRING_ARRAY
<br />
 }</td></tr>
<tr class="separator:a1b307a4b7368b68f325812cd2aeb8784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48cefe5c31e4efce7e715a23f02fc6a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#aa48cefe5c31e4efce7e715a23f02fc6a">HistoryPolicy</a> { <a class="el" href="namespacerclcpp.html#aa48cefe5c31e4efce7e715a23f02fc6aadc899de472766d7f25128b9ef50be307">KeepLast</a> = RMW_QOS_POLICY_HISTORY_KEEP_LAST
, <a class="el" href="namespacerclcpp.html#aa48cefe5c31e4efce7e715a23f02fc6aa98e4e92f8ed10755a2fde1531cf6593f">KeepAll</a> = RMW_QOS_POLICY_HISTORY_KEEP_ALL
, <a class="el" href="namespacerclcpp.html#aa48cefe5c31e4efce7e715a23f02fc6aaa8408867e3b24998945a2bed87c68e99">SystemDefault</a> = RMW_QOS_POLICY_HISTORY_SYSTEM_DEFAULT
, <a class="el" href="namespacerclcpp.html#aa48cefe5c31e4efce7e715a23f02fc6aa88183b946cc5f0e8c96b2e66e1c74a7e">Unknown</a> = RMW_QOS_POLICY_HISTORY_UNKNOWN
 }</td></tr>
<tr class="separator:aa48cefe5c31e4efce7e715a23f02fc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f037ff6e64986ad3e4ee883e0b2ed2d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a4f037ff6e64986ad3e4ee883e0b2ed2d">ReliabilityPolicy</a> { <a class="el" href="namespacerclcpp.html#a4f037ff6e64986ad3e4ee883e0b2ed2dab4ee632ee2b420e4c4954189eafa9230">BestEffort</a> = RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT
, <a class="el" href="namespacerclcpp.html#a4f037ff6e64986ad3e4ee883e0b2ed2da84fcf5d37086f2a93953734ce8f385b6">Reliable</a> = RMW_QOS_POLICY_RELIABILITY_RELIABLE
, <a class="el" href="namespacerclcpp.html#a4f037ff6e64986ad3e4ee883e0b2ed2daa8408867e3b24998945a2bed87c68e99">SystemDefault</a> = RMW_QOS_POLICY_RELIABILITY_SYSTEM_DEFAULT
, <a class="el" href="namespacerclcpp.html#a4f037ff6e64986ad3e4ee883e0b2ed2da88183b946cc5f0e8c96b2e66e1c74a7e">Unknown</a> = RMW_QOS_POLICY_RELIABILITY_UNKNOWN
 }</td></tr>
<tr class="separator:a4f037ff6e64986ad3e4ee883e0b2ed2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13741e50907b01ddeea83a16188edf0a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a13741e50907b01ddeea83a16188edf0a">DurabilityPolicy</a> { <a class="el" href="namespacerclcpp.html#a13741e50907b01ddeea83a16188edf0aa3e3af98b6b48c7e593d8d18863e3333b">Volatile</a> = RMW_QOS_POLICY_DURABILITY_VOLATILE
, <a class="el" href="namespacerclcpp.html#a13741e50907b01ddeea83a16188edf0aa8fd20371a3df287397529e4ee976e789">TransientLocal</a> = RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL
, <a class="el" href="namespacerclcpp.html#a13741e50907b01ddeea83a16188edf0aaa8408867e3b24998945a2bed87c68e99">SystemDefault</a> = RMW_QOS_POLICY_DURABILITY_SYSTEM_DEFAULT
, <a class="el" href="namespacerclcpp.html#a13741e50907b01ddeea83a16188edf0aa88183b946cc5f0e8c96b2e66e1c74a7e">Unknown</a> = RMW_QOS_POLICY_DURABILITY_UNKNOWN
 }</td></tr>
<tr class="separator:a13741e50907b01ddeea83a16188edf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56271e3680feaec39139227875c22c13"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a56271e3680feaec39139227875c22c13">LivelinessPolicy</a> { <a class="el" href="namespacerclcpp.html#a56271e3680feaec39139227875c22c13a086247a9b57fde6eefee2a0c4752242d">Automatic</a> = RMW_QOS_POLICY_LIVELINESS_AUTOMATIC
, <a class="el" href="namespacerclcpp.html#a56271e3680feaec39139227875c22c13aae5b271e7f73d240d803d1e4f1ab1e04">ManualByTopic</a> = RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC
, <a class="el" href="namespacerclcpp.html#a56271e3680feaec39139227875c22c13aa8408867e3b24998945a2bed87c68e99">SystemDefault</a> = RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT
, <a class="el" href="namespacerclcpp.html#a56271e3680feaec39139227875c22c13a88183b946cc5f0e8c96b2e66e1c74a7e">Unknown</a> = RMW_QOS_POLICY_LIVELINESS_UNKNOWN
 }</td></tr>
<tr class="separator:a56271e3680feaec39139227875c22c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41ae37222bc420861a9ff6f6a28317b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#af41ae37222bc420861a9ff6f6a28317b">QoSCompatibility</a> { <a class="el" href="namespacerclcpp.html#af41ae37222bc420861a9ff6f6a28317baa60852f204ed8028c1c58808b746d115">Ok</a> = RMW_QOS_COMPATIBILITY_OK
, <a class="el" href="namespacerclcpp.html#af41ae37222bc420861a9ff6f6a28317ba0eaadb4fcb48a0a0ed7bc9868be9fbaa">Warning</a> = RMW_QOS_COMPATIBILITY_WARNING
, <a class="el" href="namespacerclcpp.html#af41ae37222bc420861a9ff6f6a28317ba902b0d55fddef6f8d651fe1035b7d4bd">Error</a> = RMW_QOS_COMPATIBILITY_ERROR
 }</td></tr>
<tr class="separator:af41ae37222bc420861a9ff6f6a28317b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c74c05a2168fd52b86ab9b444499f77"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a3c74c05a2168fd52b86ab9b444499f77">QosPolicyKind</a> { <br />
&#160;&#160;<a class="el" href="namespacerclcpp.html#a3c74c05a2168fd52b86ab9b444499f77a588630e52044c477c618108567c0c760">AvoidRosNamespaceConventions</a> = RMW_QOS_POLICY_AVOID_ROS_NAMESPACE_CONVENTIONS
, <a class="el" href="namespacerclcpp.html#a3c74c05a2168fd52b86ab9b444499f77a159f7d51b9a4ff702c9b5543b8f7980f">Deadline</a> = RMW_QOS_POLICY_DEADLINE
, <a class="el" href="namespacerclcpp.html#a3c74c05a2168fd52b86ab9b444499f77a675056ad1441b6375b2c5abd48c27ef1">Depth</a> = RMW_QOS_POLICY_DEPTH
, <a class="el" href="namespacerclcpp.html#a3c74c05a2168fd52b86ab9b444499f77a2166e76dc88d642260416a536b06a412">Durability</a> = RMW_QOS_POLICY_DURABILITY
, <br />
&#160;&#160;<a class="el" href="namespacerclcpp.html#a3c74c05a2168fd52b86ab9b444499f77a16d2b386b2034b9488996466aaae0b57">History</a> = RMW_QOS_POLICY_HISTORY
, <a class="el" href="namespacerclcpp.html#a3c74c05a2168fd52b86ab9b444499f77a3520ef938b9cf9042a48781b2b6bc0d8">Lifespan</a> = RMW_QOS_POLICY_LIFESPAN
, <a class="el" href="namespacerclcpp.html#a3c74c05a2168fd52b86ab9b444499f77a3d854aed48edf57a11246c60b263fc1b">Liveliness</a> = RMW_QOS_POLICY_LIVELINESS
, <a class="el" href="namespacerclcpp.html#a3c74c05a2168fd52b86ab9b444499f77abff62ed3f553ba4e0327fcc99ee20650">LivelinessLeaseDuration</a> = RMW_QOS_POLICY_LIVELINESS_LEASE_DURATION
, <br />
&#160;&#160;<a class="el" href="namespacerclcpp.html#a3c74c05a2168fd52b86ab9b444499f77a820b8f74ad843d1574106ec4cadfc07e">Reliability</a> = RMW_QOS_POLICY_RELIABILITY
, <a class="el" href="namespacerclcpp.html#a3c74c05a2168fd52b86ab9b444499f77a4bbb8f967da6d1a610596d7257179c2b">Invalid</a> = RMW_QOS_POLICY_INVALID
<br />
 }</td></tr>
<tr class="separator:a3c74c05a2168fd52b86ab9b444499f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1faa0b05040d3cf0f74c231b6800bffc"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a1faa0b05040d3cf0f74c231b6800bffc">TopicStatisticsState</a> { <a class="el" href="namespacerclcpp.html#a1faa0b05040d3cf0f74c231b6800bffca2faec1f9f8cc7f8f40d521c4dd574f49">Enable</a>
, <a class="el" href="namespacerclcpp.html#a1faa0b05040d3cf0f74c231b6800bffcabcfaccebf745acfd5e75351095a5394a">Disable</a>
, <a class="el" href="namespacerclcpp.html#a1faa0b05040d3cf0f74c231b6800bffca5e7bd84eadd196f52e8320680fa1c7cf">NodeDefault</a>
 }</td></tr>
<tr class="separator:a1faa0b05040d3cf0f74c231b6800bffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a5d1b5fa11030e4141fd79e36cf2fd"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a14a5d1b5fa11030e4141fd79e36cf2fd">SignalHandlerOptions</a> { <a class="el" href="namespacerclcpp.html#a14a5d1b5fa11030e4141fd79e36cf2fdab1c94ca2fbc3e78fc30069c8d0f01680">All</a>
, <a class="el" href="namespacerclcpp.html#a14a5d1b5fa11030e4141fd79e36cf2fdade31d36d3ef6ffbb33f10bedfd3770ed">SigInt</a>
, <a class="el" href="namespacerclcpp.html#a14a5d1b5fa11030e4141fd79e36cf2fda3aad7def98c3981ae3f34a64454a051f">SigTerm</a>
, <a class="el" href="namespacerclcpp.html#a14a5d1b5fa11030e4141fd79e36cf2fda6adf97f83acf6453d4a6a4b1070f3754">None</a>
 }</td></tr>
<tr class="memdesc:a14a5d1b5fa11030e4141fd79e36cf2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option to indicate which signal handlers rclcpp should install.  <a href="namespacerclcpp.html#a14a5d1b5fa11030e4141fd79e36cf2fd">More...</a><br /></td></tr>
<tr class="separator:a14a5d1b5fa11030e4141fd79e36cf2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac834535a6eab608968bbb44d9773bb1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#aac834535a6eab608968bbb44d9773bb1">WaitResultKind</a> { <a class="el" href="namespacerclcpp.html#aac834535a6eab608968bbb44d9773bb1ad46050bbb7cc1d8c1836bdb94bc428b4">Ready</a>
, <a class="el" href="namespacerclcpp.html#aac834535a6eab608968bbb44d9773bb1ab55663adb793759edd2082b5194f1cd3">Timeout</a>
, <a class="el" href="namespacerclcpp.html#aac834535a6eab608968bbb44d9773bb1aaaec822ce6caf3162cbe3cc2cfa1cdc0">Empty</a>
 }</td></tr>
<tr class="memdesc:aac834535a6eab608968bbb44d9773bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the various kinds of results from waiting on a wait set.  <a href="namespacerclcpp.html#aac834535a6eab608968bbb44d9773bb1">More...</a><br /></td></tr>
<tr class="separator:aac834535a6eab608968bbb44d9773bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af73bf64bfc1b01f030012cd6d2e6e43c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Context::SharedPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#af73bf64bfc1b01f030012cd6d2e6e43c">get_contexts</a> ()</td></tr>
<tr class="memdesc:af73bf64bfc1b01f030012cd6d2e6e43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the list of context shared pointers.  <a href="namespacerclcpp.html#af73bf64bfc1b01f030012cd6d2e6e43c">More...</a><br /></td></tr>
<tr class="separator:af73bf64bfc1b01f030012cd6d2e6e43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24538aeccf07c4966c3192623d06440a"><td class="memTemplParams" colspan="2">template&lt;typename ServiceT &gt; </td></tr>
<tr class="memitem:a24538aeccf07c4966c3192623d06440a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1Client.html">rclcpp::Client</a>&lt; ServiceT &gt;::SharedPtr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a24538aeccf07c4966c3192623d06440a">create_client</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeBaseInterface.html">node_interfaces::NodeBaseInterface</a> &gt; node_base, std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html">node_interfaces::NodeGraphInterface</a> &gt; node_graph, std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeServicesInterface.html">node_interfaces::NodeServicesInterface</a> &gt; node_services, const std::string &amp;service_name, const rmw_qos_profile_t &amp;qos_profile, rclcpp::CallbackGroup::SharedPtr group)</td></tr>
<tr class="separator:a24538aeccf07c4966c3192623d06440a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab896cb8ec7eeecfe50cdfa9dbc19e761"><td class="memTemplParams" colspan="2">template&lt;typename AllocatorT  = std::allocator&lt;void&gt;&gt; </td></tr>
<tr class="memitem:ab896cb8ec7eeecfe50cdfa9dbc19e761"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1GenericPublisher.html">GenericPublisher</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#ab896cb8ec7eeecfe50cdfa9dbc19e761">create_generic_publisher</a> (rclcpp::node_interfaces::NodeTopicsInterface::SharedPtr topics_interface, const std::string &amp;topic_name, const std::string &amp;topic_type, const <a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> &amp;qos, const <a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">rclcpp::PublisherOptionsWithAllocator</a>&lt; AllocatorT &gt; &amp;options=(<a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">rclcpp::PublisherOptionsWithAllocator</a>&lt; AllocatorT &gt;()))</td></tr>
<tr class="memdesc:ab896cb8ec7eeecfe50cdfa9dbc19e761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a <a class="el" href="classrclcpp_1_1GenericPublisher.html" title="Publisher for serialized messages whose type is not known at compile time.">GenericPublisher</a>.  <a href="namespacerclcpp.html#ab896cb8ec7eeecfe50cdfa9dbc19e761">More...</a><br /></td></tr>
<tr class="separator:ab896cb8ec7eeecfe50cdfa9dbc19e761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0472e08dbece2e13ad9da04eae5147f8"><td class="memTemplParams" colspan="2">template&lt;typename AllocatorT  = std::allocator&lt;void&gt;&gt; </td></tr>
<tr class="memitem:a0472e08dbece2e13ad9da04eae5147f8"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1GenericSubscription.html">GenericSubscription</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a0472e08dbece2e13ad9da04eae5147f8">create_generic_subscription</a> (rclcpp::node_interfaces::NodeTopicsInterface::SharedPtr topics_interface, const std::string &amp;topic_name, const std::string &amp;topic_type, const <a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> &amp;qos, std::function&lt; void(std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1SerializedMessage.html">rclcpp::SerializedMessage</a> &gt;)&gt; callback, const <a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">rclcpp::SubscriptionOptionsWithAllocator</a>&lt; AllocatorT &gt; &amp;options=(<a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">rclcpp::SubscriptionOptionsWithAllocator</a>&lt; AllocatorT &gt;()))</td></tr>
<tr class="memdesc:a0472e08dbece2e13ad9da04eae5147f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a <a class="el" href="classrclcpp_1_1GenericSubscription.html" title="Subscription for serialized messages whose type is not known at compile time.">GenericSubscription</a>.  <a href="namespacerclcpp.html#a0472e08dbece2e13ad9da04eae5147f8">More...</a><br /></td></tr>
<tr class="separator:a0472e08dbece2e13ad9da04eae5147f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db5d1c8332968a358e668c50012545b"><td class="memTemplParams" colspan="2">template&lt;typename MessageT , typename AllocatorT  = std::allocator&lt;void&gt;, typename PublisherT  = rclcpp::Publisher&lt;MessageT, AllocatorT&gt;, typename NodeT &gt; </td></tr>
<tr class="memitem:a8db5d1c8332968a358e668c50012545b"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; PublisherT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a8db5d1c8332968a358e668c50012545b">create_publisher</a> (NodeT &amp;&amp;node, const std::string &amp;topic_name, const <a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> &amp;qos, const <a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">rclcpp::PublisherOptionsWithAllocator</a>&lt; AllocatorT &gt; &amp;options=(<a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">rclcpp::PublisherOptionsWithAllocator</a>&lt; AllocatorT &gt;()))</td></tr>
<tr class="memdesc:a8db5d1c8332968a358e668c50012545b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a publisher of the given MessageT type.  <a href="namespacerclcpp.html#a8db5d1c8332968a358e668c50012545b">More...</a><br /></td></tr>
<tr class="separator:a8db5d1c8332968a358e668c50012545b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84269833709d75060a46bcc8fb70e7b8"><td class="memTemplParams" colspan="2">template&lt;typename MessageT , typename AllocatorT  = std::allocator&lt;void&gt;, typename PublisherT  = rclcpp::Publisher&lt;MessageT, AllocatorT&gt;&gt; </td></tr>
<tr class="memitem:a84269833709d75060a46bcc8fb70e7b8"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; PublisherT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a84269833709d75060a46bcc8fb70e7b8">create_publisher</a> (rclcpp::node_interfaces::NodeParametersInterface::SharedPtr &amp;node_parameters, rclcpp::node_interfaces::NodeTopicsInterface::SharedPtr &amp;node_topics, const std::string &amp;topic_name, const <a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> &amp;qos, const <a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">rclcpp::PublisherOptionsWithAllocator</a>&lt; AllocatorT &gt; &amp;options=(<a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">rclcpp::PublisherOptionsWithAllocator</a>&lt; AllocatorT &gt;()))</td></tr>
<tr class="memdesc:a84269833709d75060a46bcc8fb70e7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a publisher of the given MessageT type.  <a href="namespacerclcpp.html#a84269833709d75060a46bcc8fb70e7b8">More...</a><br /></td></tr>
<tr class="separator:a84269833709d75060a46bcc8fb70e7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f170aa649d228312e5eab2497042fb"><td class="memTemplParams" colspan="2">template&lt;typename ServiceT , typename CallbackT &gt; </td></tr>
<tr class="memitem:a08f170aa649d228312e5eab2497042fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1Service.html">rclcpp::Service</a>&lt; ServiceT &gt;::SharedPtr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a08f170aa649d228312e5eab2497042fb">create_service</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeBaseInterface.html">node_interfaces::NodeBaseInterface</a> &gt; node_base, std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeServicesInterface.html">node_interfaces::NodeServicesInterface</a> &gt; node_services, const std::string &amp;service_name, CallbackT &amp;&amp;callback, const rmw_qos_profile_t &amp;qos_profile, rclcpp::CallbackGroup::SharedPtr group)</td></tr>
<tr class="separator:a08f170aa649d228312e5eab2497042fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab715b48e5db24c2b95d1d9e0a060ab64"><td class="memTemplParams" colspan="2">template&lt;typename MessageT , typename CallbackT , typename AllocatorT  = std::allocator&lt;void&gt;, typename SubscriptionT  = rclcpp::Subscription&lt;MessageT, AllocatorT&gt;, typename MessageMemoryStrategyT  = typename SubscriptionT::MessageMemoryStrategyType, typename NodeT &gt; </td></tr>
<tr class="memitem:ab715b48e5db24c2b95d1d9e0a060ab64"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; SubscriptionT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#ab715b48e5db24c2b95d1d9e0a060ab64">create_subscription</a> (NodeT &amp;node, const std::string &amp;topic_name, const <a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> &amp;qos, CallbackT &amp;&amp;callback, const <a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">rclcpp::SubscriptionOptionsWithAllocator</a>&lt; AllocatorT &gt; &amp;options=(<a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">rclcpp::SubscriptionOptionsWithAllocator</a>&lt; AllocatorT &gt;()), typename MessageMemoryStrategyT::SharedPtr msg_mem_strat=(MessageMemoryStrategyT::create_default()))</td></tr>
<tr class="memdesc:ab715b48e5db24c2b95d1d9e0a060ab64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a subscription of the given MessageT type.  <a href="namespacerclcpp.html#ab715b48e5db24c2b95d1d9e0a060ab64">More...</a><br /></td></tr>
<tr class="separator:ab715b48e5db24c2b95d1d9e0a060ab64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c35ecfee66ee62914501b3ac991631"><td class="memTemplParams" colspan="2">template&lt;typename MessageT , typename CallbackT , typename AllocatorT  = std::allocator&lt;void&gt;, typename SubscriptionT  = rclcpp::Subscription&lt;MessageT, AllocatorT&gt;, typename MessageMemoryStrategyT  = typename SubscriptionT::MessageMemoryStrategyType&gt; </td></tr>
<tr class="memitem:a35c35ecfee66ee62914501b3ac991631"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; SubscriptionT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a35c35ecfee66ee62914501b3ac991631">create_subscription</a> (rclcpp::node_interfaces::NodeParametersInterface::SharedPtr &amp;node_parameters, rclcpp::node_interfaces::NodeTopicsInterface::SharedPtr &amp;node_topics, const std::string &amp;topic_name, const <a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> &amp;qos, CallbackT &amp;&amp;callback, const <a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">rclcpp::SubscriptionOptionsWithAllocator</a>&lt; AllocatorT &gt; &amp;options=(<a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">rclcpp::SubscriptionOptionsWithAllocator</a>&lt; AllocatorT &gt;()), typename MessageMemoryStrategyT::SharedPtr msg_mem_strat=(MessageMemoryStrategyT::create_default()))</td></tr>
<tr class="memdesc:a35c35ecfee66ee62914501b3ac991631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a subscription of the given MessageT type.  <a href="namespacerclcpp.html#a35c35ecfee66ee62914501b3ac991631">More...</a><br /></td></tr>
<tr class="separator:a35c35ecfee66ee62914501b3ac991631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c53f2add6632d67becd1885d26362c5"><td class="memTemplParams" colspan="2">template&lt;typename CallbackT &gt; </td></tr>
<tr class="memitem:a0c53f2add6632d67becd1885d26362c5"><td class="memTemplItemLeft" align="right" valign="top">rclcpp::TimerBase::SharedPtr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a0c53f2add6632d67becd1885d26362c5">create_timer</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeBaseInterface.html">node_interfaces::NodeBaseInterface</a> &gt; node_base, std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeTimersInterface.html">node_interfaces::NodeTimersInterface</a> &gt; node_timers, rclcpp::Clock::SharedPtr clock, <a class="el" href="classrclcpp_1_1Duration.html">rclcpp::Duration</a> period, CallbackT &amp;&amp;callback, rclcpp::CallbackGroup::SharedPtr group=nullptr)</td></tr>
<tr class="separator:a0c53f2add6632d67becd1885d26362c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb29d356bf00583b0d705b264b3b0ae"><td class="memTemplParams" colspan="2">template&lt;typename NodeT , typename CallbackT &gt; </td></tr>
<tr class="memitem:affb29d356bf00583b0d705b264b3b0ae"><td class="memTemplItemLeft" align="right" valign="top">rclcpp::TimerBase::SharedPtr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#affb29d356bf00583b0d705b264b3b0ae">create_timer</a> (NodeT node, rclcpp::Clock::SharedPtr clock, <a class="el" href="classrclcpp_1_1Duration.html">rclcpp::Duration</a> period, CallbackT &amp;&amp;callback, rclcpp::CallbackGroup::SharedPtr group=nullptr)</td></tr>
<tr class="memdesc:affb29d356bf00583b0d705b264b3b0ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a timer with a given clock.  <a href="namespacerclcpp.html#affb29d356bf00583b0d705b264b3b0ae">More...</a><br /></td></tr>
<tr class="separator:affb29d356bf00583b0d705b264b3b0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad987fd245e31c6fd16d70d6ed1186189"><td class="memTemplParams" colspan="2">template&lt;typename DurationRepT , typename DurationT , typename CallbackT &gt; </td></tr>
<tr class="memitem:ad987fd245e31c6fd16d70d6ed1186189"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1WallTimer.html">rclcpp::WallTimer</a>&lt; CallbackT &gt;::SharedPtr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#ad987fd245e31c6fd16d70d6ed1186189">create_wall_timer</a> (std::chrono::duration&lt; DurationRepT, DurationT &gt; period, CallbackT callback, rclcpp::CallbackGroup::SharedPtr group, <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeBaseInterface.html">node_interfaces::NodeBaseInterface</a> *node_base, <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeTimersInterface.html">node_interfaces::NodeTimersInterface</a> *node_timers)</td></tr>
<tr class="memdesc:ad987fd245e31c6fd16d70d6ed1186189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to create a timer with node resources.  <a href="namespacerclcpp.html#ad987fd245e31c6fd16d70d6ed1186189">More...</a><br /></td></tr>
<tr class="separator:ad987fd245e31c6fd16d70d6ed1186189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48c7a9cc4fa34989a0849d708d8f7de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#ad48c7a9cc4fa34989a0849d708d8f7de">spin_some</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr)</td></tr>
<tr class="memdesc:ad48c7a9cc4fa34989a0849d708d8f7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a default single-threaded executor and execute any immediately available work.  <a href="namespacerclcpp.html#ad48c7a9cc4fa34989a0849d708d8f7de">More...</a><br /></td></tr>
<tr class="separator:ad48c7a9cc4fa34989a0849d708d8f7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e16488d62cc48e5520101f9f4f4102a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a5e16488d62cc48e5520101f9f4f4102a">spin_some</a> (rclcpp::Node::SharedPtr node_ptr)</td></tr>
<tr class="separator:a5e16488d62cc48e5520101f9f4f4102a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e13577f5bcc5992de1d7dd08d8652b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a21e13577f5bcc5992de1d7dd08d8652b">spin</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr)</td></tr>
<tr class="memdesc:a21e13577f5bcc5992de1d7dd08d8652b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a default single-threaded executor and spin the specified node.  <a href="namespacerclcpp.html#a21e13577f5bcc5992de1d7dd08d8652b">More...</a><br /></td></tr>
<tr class="separator:a21e13577f5bcc5992de1d7dd08d8652b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb335bc95a6fa8546a6bfcfd087eb57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a4bb335bc95a6fa8546a6bfcfd087eb57">spin</a> (rclcpp::Node::SharedPtr node_ptr)</td></tr>
<tr class="separator:a4bb335bc95a6fa8546a6bfcfd087eb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83b41b70748bbd4631b498596148360"><td class="memTemplParams" colspan="2">template&lt;typename FutureT , typename TimeRepT  = int64_t, typename TimeT  = std::milli&gt; </td></tr>
<tr class="memitem:ab83b41b70748bbd4631b498596148360"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacerclcpp.html#a7b4ff5f1e516740d7e11ea97fe6f5532">rclcpp::FutureReturnCode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#ab83b41b70748bbd4631b498596148360">spin_until_future_complete</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr, const FutureT &amp;future, std::chrono::duration&lt; TimeRepT, TimeT &gt; timeout=std::chrono::duration&lt; TimeRepT, TimeT &gt;(-1))</td></tr>
<tr class="separator:ab83b41b70748bbd4631b498596148360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d07cddc30219a944b5a7bcba4b84bc"><td class="memTemplParams" colspan="2">template&lt;typename NodeT  = rclcpp::Node, typename FutureT , typename TimeRepT  = int64_t, typename TimeT  = std::milli&gt; </td></tr>
<tr class="memitem:a99d07cddc30219a944b5a7bcba4b84bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacerclcpp.html#a7b4ff5f1e516740d7e11ea97fe6f5532">rclcpp::FutureReturnCode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a99d07cddc30219a944b5a7bcba4b84bc">spin_until_future_complete</a> (std::shared_ptr&lt; NodeT &gt; node_ptr, const FutureT &amp;future, std::chrono::duration&lt; TimeRepT, TimeT &gt; timeout=std::chrono::duration&lt; TimeRepT, TimeT &gt;(-1))</td></tr>
<tr class="separator:a99d07cddc30219a944b5a7bcba4b84bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1855b992b1b77f1ed75bab5192aaf2bd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a1855b992b1b77f1ed75bab5192aaf2bd">expand_topic_or_service_name</a> (const std::string &amp;name, const std::string &amp;node_name, const std::string &amp;namespace_, bool is_service=false)</td></tr>
<tr class="memdesc:a1855b992b1b77f1ed75bab5192aaf2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a topic or service name and throw if it is not valid.  <a href="namespacerclcpp.html#a1855b992b1b77f1ed75bab5192aaf2bd">More...</a><br /></td></tr>
<tr class="separator:a1855b992b1b77f1ed75bab5192aaf2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a474b200d67e8a5988daaeb8980fb8b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a9a474b200d67e8a5988daaeb8980fb8b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="namespacerclcpp.html#a7b4ff5f1e516740d7e11ea97fe6f5532">FutureReturnCode</a> &amp;future_return_code)</td></tr>
<tr class="memdesc:a9a474b200d67e8a5988daaeb8980fb8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for FutureReturnCode.  <a href="namespacerclcpp.html#a9a474b200d67e8a5988daaeb8980fb8b">More...</a><br /></td></tr>
<tr class="separator:a9a474b200d67e8a5988daaeb8980fb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a11b0ee43bb55e4eca3a79866406e5e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a0a11b0ee43bb55e4eca3a79866406e5e">to_string</a> (const <a class="el" href="namespacerclcpp.html#a7b4ff5f1e516740d7e11ea97fe6f5532">FutureReturnCode</a> &amp;future_return_code)</td></tr>
<tr class="memdesc:a0a11b0ee43bb55e4eca3a79866406e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">String conversion function for FutureReturnCode.  <a href="namespacerclcpp.html#a0a11b0ee43bb55e4eca3a79866406e5e">More...</a><br /></td></tr>
<tr class="separator:a0a11b0ee43bb55e4eca3a79866406e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07373238f06f8a884da53850bdc9072e"><td class="memTemplParams" colspan="2">template&lt;typename MessageT &gt; </td></tr>
<tr class="memitem:a07373238f06f8a884da53850bdc9072e"><td class="memTemplItemLeft" align="right" valign="top">constexpr const rosidl_message_type_support_t &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a07373238f06f8a884da53850bdc9072e">get_message_type_support_handle</a> ()</td></tr>
<tr class="memdesc:a07373238f06f8a884da53850bdc9072e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the message type support for the given <code>MessageT</code> type.  <a href="namespacerclcpp.html#a07373238f06f8a884da53850bdc9072e">More...</a><br /></td></tr>
<tr class="separator:a07373238f06f8a884da53850bdc9072e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7295751947c08312aa69f45fd673171"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1Logger.html">Logger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#ae7295751947c08312aa69f45fd673171">get_logger</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ae7295751947c08312aa69f45fd673171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a named logger.  <a href="namespacerclcpp.html#ae7295751947c08312aa69f45fd673171">More...</a><br /></td></tr>
<tr class="separator:ae7295751947c08312aa69f45fd673171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cf150e9157d8ae52206bbb7f1a9310"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1Logger.html">Logger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a32cf150e9157d8ae52206bbb7f1a9310">get_node_logger</a> (const rcl_node_t *node)</td></tr>
<tr class="memdesc:a32cf150e9157d8ae52206bbb7f1a9310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a named logger using an rcl_node_t.  <a href="namespacerclcpp.html#a32cf150e9157d8ae52206bbb7f1a9310">More...</a><br /></td></tr>
<tr class="separator:a32cf150e9157d8ae52206bbb7f1a9310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af1b5c6b911fe1715a20c9d8f0c1f61"><td class="memItemLeft" align="right" valign="top">rcpputils::fs::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a9af1b5c6b911fe1715a20c9d8f0c1f61">get_logging_directory</a> ()</td></tr>
<tr class="memdesc:a9af1b5c6b911fe1715a20c9d8f0c1f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current logging directory.  <a href="namespacerclcpp.html#a9af1b5c6b911fe1715a20c9d8f0c1f61">More...</a><br /></td></tr>
<tr class="separator:a9af1b5c6b911fe1715a20c9d8f0c1f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17def20ce6fc1e5be8c1e2496998034b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a17def20ce6fc1e5be8c1e2496998034b">operator==</a> (const <a class="el" href="classrclcpp_1_1NetworkFlowEndpoint.html">NetworkFlowEndpoint</a> &amp;left, const <a class="el" href="classrclcpp_1_1NetworkFlowEndpoint.html">NetworkFlowEndpoint</a> &amp;right)</td></tr>
<tr class="memdesc:a17def20ce6fc1e5be8c1e2496998034b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two <a class="el" href="classrclcpp_1_1NetworkFlowEndpoint.html">NetworkFlowEndpoint</a> instances are equal.  <a href="namespacerclcpp.html#a17def20ce6fc1e5be8c1e2496998034b">More...</a><br /></td></tr>
<tr class="separator:a17def20ce6fc1e5be8c1e2496998034b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7df6710c1fe3f51a3cac31cda94c75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a7f7df6710c1fe3f51a3cac31cda94c75">operator!=</a> (const <a class="el" href="classrclcpp_1_1NetworkFlowEndpoint.html">NetworkFlowEndpoint</a> &amp;left, const <a class="el" href="classrclcpp_1_1NetworkFlowEndpoint.html">NetworkFlowEndpoint</a> &amp;right)</td></tr>
<tr class="memdesc:a7f7df6710c1fe3f51a3cac31cda94c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two <a class="el" href="classrclcpp_1_1NetworkFlowEndpoint.html">NetworkFlowEndpoint</a> instances are not equal.  <a href="namespacerclcpp.html#a7f7df6710c1fe3f51a3cac31cda94c75">More...</a><br /></td></tr>
<tr class="separator:a7f7df6710c1fe3f51a3cac31cda94c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf768479c9fb964f9f84c4f866cd79d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#acaf768479c9fb964f9f84c4f866cd79d">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classrclcpp_1_1NetworkFlowEndpoint.html">NetworkFlowEndpoint</a> &amp;network_flow_endpoint)</td></tr>
<tr class="memdesc:acaf768479c9fb964f9f84c4f866cd79d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming helper for <a class="el" href="classrclcpp_1_1NetworkFlowEndpoint.html">NetworkFlowEndpoint</a>.  <a href="namespacerclcpp.html#acaf768479c9fb964f9f84c4f866cd79d">More...</a><br /></td></tr>
<tr class="separator:acaf768479c9fb964f9f84c4f866cd79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1760a6f74638be846e5d5c3b0478232"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#ac1760a6f74638be846e5d5c3b0478232">extend_name_with_sub_namespace</a> (const std::string &amp;name, const std::string &amp;sub_namespace)</td></tr>
<tr class="separator:ac1760a6f74638be846e5d5c3b0478232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8f47054b6c550888eca755f3203f05"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a4d8f47054b6c550888eca755f3203f05">_to_json_dict_entry</a> (const <a class="el" href="classrclcpp_1_1Parameter.html">Parameter</a> &amp;param)</td></tr>
<tr class="memdesc:a4d8f47054b6c550888eca755f3203f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a json encoded version of the parameter intended for a dict.  <a href="namespacerclcpp.html#a4d8f47054b6c550888eca755f3203f05">More...</a><br /></td></tr>
<tr class="separator:a4d8f47054b6c550888eca755f3203f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6980e39627cfc70b542040ada42ca607"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a6980e39627cfc70b542040ada42ca607">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classrclcpp_1_1Parameter.html">rclcpp::Parameter</a> &amp;pv)</td></tr>
<tr class="separator:a6980e39627cfc70b542040ada42ca607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9c5f2bb49142b5f5ad11a8cf1c9328"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a0e9c5f2bb49142b5f5ad11a8cf1c9328">operator&lt;&lt;</a> (std::ostream &amp;os, const std::vector&lt; <a class="el" href="classrclcpp_1_1Parameter.html">Parameter</a> &gt; &amp;parameters)</td></tr>
<tr class="separator:a0e9c5f2bb49142b5f5ad11a8cf1c9328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa974dc62646d9123ab206ca602c5e089"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerclcpp.html#aa587f11d0e53c713ccc0addf5132d46a">ParameterMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#aa974dc62646d9123ab206ca602c5e089">parameter_map_from</a> (const rcl_params_t *const c_params)</td></tr>
<tr class="separator:aa974dc62646d9123ab206ca602c5e089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2133ca88053d99904e9c1fa4fc7dff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerclcpp.html#aa587f11d0e53c713ccc0addf5132d46a">ParameterMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a7e2133ca88053d99904e9c1fa4fc7dff">parameter_map_from</a> (const rcl_params_t *const c_params, const char *node_fqn)</td></tr>
<tr class="separator:a7e2133ca88053d99904e9c1fa4fc7dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a3f3243d1e335570334169979080cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1ParameterValue.html">ParameterValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#aa1a3f3243d1e335570334169979080cd">parameter_value_from</a> (const rcl_variant_t *const c_value)</td></tr>
<tr class="separator:aa1a3f3243d1e335570334169979080cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561b8286e2c64005500b9328522415f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerclcpp.html#aa587f11d0e53c713ccc0addf5132d46a">ParameterMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a561b8286e2c64005500b9328522415f2">parameter_map_from_yaml_file</a> (const std::string &amp;yaml_filename)</td></tr>
<tr class="separator:a561b8286e2c64005500b9328522415f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b93cd43e33e496e2a43f3eb9504b12"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a36b93cd43e33e496e2a43f3eb9504b12">to_string</a> (<a class="el" href="namespacerclcpp.html#a1b307a4b7368b68f325812cd2aeb8784">ParameterType</a> type)</td></tr>
<tr class="memdesc:a36b93cd43e33e496e2a43f3eb9504b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of a parameter type.  <a href="namespacerclcpp.html#a36b93cd43e33e496e2a43f3eb9504b12">More...</a><br /></td></tr>
<tr class="separator:a36b93cd43e33e496e2a43f3eb9504b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5caea480fefe503c1a7a02b4024dca"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#aed5caea480fefe503c1a7a02b4024dca">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="namespacerclcpp.html#a1b307a4b7368b68f325812cd2aeb8784">ParameterType</a> type)</td></tr>
<tr class="separator:aed5caea480fefe503c1a7a02b4024dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7cfb4c8905865fb02f3c8018657057"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#acc7cfb4c8905865fb02f3c8018657057">to_string</a> (const <a class="el" href="classrclcpp_1_1ParameterValue.html">ParameterValue</a> &amp;type)</td></tr>
<tr class="memdesc:acc7cfb4c8905865fb02f3c8018657057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a parameter as a string.  <a href="namespacerclcpp.html#acc7cfb4c8905865fb02f3c8018657057">More...</a><br /></td></tr>
<tr class="separator:acc7cfb4c8905865fb02f3c8018657057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16897dedbda576cf6035188bdc7365d7"><td class="memTemplParams" colspan="2">template&lt;typename MessageT , typename AllocatorT , typename PublisherT &gt; </td></tr>
<tr class="memitem:a16897dedbda576cf6035188bdc7365d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structrclcpp_1_1PublisherFactory.html">PublisherFactory</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a16897dedbda576cf6035188bdc7365d7">create_publisher_factory</a> (const <a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">rclcpp::PublisherOptionsWithAllocator</a>&lt; AllocatorT &gt; &amp;options)</td></tr>
<tr class="memdesc:a16897dedbda576cf6035188bdc7365d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="structrclcpp_1_1PublisherFactory.html" title="Factory with functions used to create a MessageT specific PublisherT.">PublisherFactory</a> with functions setup for creating a PublisherT&lt;MessageT, AllocatorT&gt;.  <a href="namespacerclcpp.html#a16897dedbda576cf6035188bdc7365d7">More...</a><br /></td></tr>
<tr class="separator:a16897dedbda576cf6035188bdc7365d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf3573ad178cad6dcdad0e8cdbdfe6f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a7bf3573ad178cad6dcdad0e8cdbdfe6f">qos_policy_name_from_kind</a> (rmw_qos_policy_kind_t policy_kind)</td></tr>
<tr class="separator:a7bf3573ad178cad6dcdad0e8cdbdfe6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c7e823d8b8cbde96e0e295065c3836"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#aa9c7e823d8b8cbde96e0e295065c3836">operator==</a> (const <a class="el" href="classrclcpp_1_1QoS.html">QoS</a> &amp;left, const <a class="el" href="classrclcpp_1_1QoS.html">QoS</a> &amp;right)</td></tr>
<tr class="memdesc:aa9c7e823d8b8cbde96e0e295065c3836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two <a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">QoS</a> profiles are exactly equal in all policy values.  <a href="namespacerclcpp.html#aa9c7e823d8b8cbde96e0e295065c3836">More...</a><br /></td></tr>
<tr class="separator:aa9c7e823d8b8cbde96e0e295065c3836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af233f254408ae99037eaef31e6655e0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#af233f254408ae99037eaef31e6655e0d">operator!=</a> (const <a class="el" href="classrclcpp_1_1QoS.html">QoS</a> &amp;left, const <a class="el" href="classrclcpp_1_1QoS.html">QoS</a> &amp;right)</td></tr>
<tr class="separator:af233f254408ae99037eaef31e6655e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c5407c58578bfc64f5489476b433ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrclcpp_1_1QoSCheckCompatibleResult.html">QoSCheckCompatibleResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a12c5407c58578bfc64f5489476b433ae">qos_check_compatible</a> (const <a class="el" href="classrclcpp_1_1QoS.html">QoS</a> &amp;publisher_qos, const <a class="el" href="classrclcpp_1_1QoS.html">QoS</a> &amp;subscription_qos)</td></tr>
<tr class="memdesc:a12c5407c58578bfc64f5489476b433ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two <a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">QoS</a> profiles are compatible.  <a href="namespacerclcpp.html#a12c5407c58578bfc64f5489476b433ae">More...</a><br /></td></tr>
<tr class="separator:a12c5407c58578bfc64f5489476b433ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae553419da8035418ba3cc797c1f0a549"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#ae553419da8035418ba3cc797c1f0a549">qos_policy_kind_to_cstr</a> (const <a class="el" href="namespacerclcpp.html#a3c74c05a2168fd52b86ab9b444499f77">QosPolicyKind</a> &amp;qpk)</td></tr>
<tr class="separator:ae553419da8035418ba3cc797c1f0a549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6308b091df681f6bb7964b44520dfb55"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a6308b091df681f6bb7964b44520dfb55">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="namespacerclcpp.html#a3c74c05a2168fd52b86ab9b444499f77">QosPolicyKind</a> &amp;qpk)</td></tr>
<tr class="separator:a6308b091df681f6bb7964b44520dfb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7846ba2bee783fa9352c7073f30eec"><td class="memTemplParams" colspan="2">template&lt;typename Callable &gt; </td></tr>
<tr class="memitem:afc7846ba2bee783fa9352c7073f30eec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structrclcpp_1_1ScopeExit.html">ScopeExit</a>&lt; Callable &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#afc7846ba2bee783fa9352c7073f30eec">make_scope_exit</a> (Callable callable)</td></tr>
<tr class="separator:afc7846ba2bee783fa9352c7073f30eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67447383503d7920af81bf6334b21a8"><td class="memTemplParams" colspan="2">template&lt;typename MessageT , typename CallbackT , typename AllocatorT , typename SubscriptionT  = rclcpp::Subscription&lt;MessageT, AllocatorT&gt;, typename MessageMemoryStrategyT  = typename SubscriptionT::MessageMemoryStrategyType, typename ROSMessageType  = typename SubscriptionT::ROSMessageType&gt; </td></tr>
<tr class="memitem:ac67447383503d7920af81bf6334b21a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structrclcpp_1_1SubscriptionFactory.html">SubscriptionFactory</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#ac67447383503d7920af81bf6334b21a8">create_subscription_factory</a> (CallbackT &amp;&amp;callback, const <a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">rclcpp::SubscriptionOptionsWithAllocator</a>&lt; AllocatorT &gt; &amp;options, typename MessageMemoryStrategyT::SharedPtr msg_mem_strat, std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1topic__statistics_1_1SubscriptionTopicStatistics.html">rclcpp::topic_statistics::SubscriptionTopicStatistics</a>&lt; ROSMessageType &gt;&gt; subscription_topic_stats=nullptr)</td></tr>
<tr class="memdesc:ac67447383503d7920af81bf6334b21a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="structrclcpp_1_1SubscriptionFactory.html" title="Factory containing a function used to create a Subscription&lt;MessageT&gt;.">SubscriptionFactory</a> setup to create a SubscriptionT&lt;MessageT, AllocatorT&gt;.  <a href="namespacerclcpp.html#ac67447383503d7920af81bf6334b21a8">More...</a><br /></td></tr>
<tr class="separator:ac67447383503d7920af81bf6334b21a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b2ba48a94966a93b36de2e52cae2bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1Time.html">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a31b2ba48a94966a93b36de2e52cae2bb">operator+</a> (const <a class="el" href="classrclcpp_1_1Duration.html">rclcpp::Duration</a> &amp;lhs, const <a class="el" href="classrclcpp_1_1Time.html">rclcpp::Time</a> &amp;rhs)</td></tr>
<tr class="separator:a31b2ba48a94966a93b36de2e52cae2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629c76e9f974bbaed3b82b030f7f1b01"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; rcpputils::SharedLibrary &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a629c76e9f974bbaed3b82b030f7f1b01">get_typesupport_library</a> (const std::string &amp;type, const std::string &amp;typesupport_identifier)</td></tr>
<tr class="memdesc:a629c76e9f974bbaed3b82b030f7f1b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the type support library for the given type.  <a href="namespacerclcpp.html#a629c76e9f974bbaed3b82b030f7f1b01">More...</a><br /></td></tr>
<tr class="separator:a629c76e9f974bbaed3b82b030f7f1b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fec6c87f54a15eb20ab963f2516373f"><td class="memItemLeft" align="right" valign="top">const rosidl_message_type_support_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a5fec6c87f54a15eb20ab963f2516373f">get_typesupport_handle</a> (const std::string &amp;type, const std::string &amp;typesupport_identifier, rcpputils::SharedLibrary &amp;library)</td></tr>
<tr class="memdesc:a5fec6c87f54a15eb20ab963f2516373f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the type support handle from the library.  <a href="namespacerclcpp.html#a5fec6c87f54a15eb20ab963f2516373f">More...</a><br /></td></tr>
<tr class="separator:a5fec6c87f54a15eb20ab963f2516373f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026b2ac505c383735117de5d1679ed80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a026b2ac505c383735117de5d1679ed80">init</a> (int argc, char const *const *argv, const <a class="el" href="classrclcpp_1_1InitOptions.html">InitOptions</a> &amp;init_options=<a class="el" href="classrclcpp_1_1InitOptions.html">InitOptions</a>(), <a class="el" href="namespacerclcpp.html#a14a5d1b5fa11030e4141fd79e36cf2fd">SignalHandlerOptions</a> signal_handler_options=<a class="el" href="namespacerclcpp.html#a14a5d1b5fa11030e4141fd79e36cf2fdab1c94ca2fbc3e78fc30069c8d0f01680">SignalHandlerOptions::All</a>)</td></tr>
<tr class="memdesc:a026b2ac505c383735117de5d1679ed80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize communications via the rmw implementation and set up a global signal handler.  <a href="namespacerclcpp.html#a026b2ac505c383735117de5d1679ed80">More...</a><br /></td></tr>
<tr class="separator:a026b2ac505c383735117de5d1679ed80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90fb3d8fb164d5955bfbf1b8174d4048"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a90fb3d8fb164d5955bfbf1b8174d4048">install_signal_handlers</a> (<a class="el" href="namespacerclcpp.html#a14a5d1b5fa11030e4141fd79e36cf2fd">SignalHandlerOptions</a> signal_handler_options=<a class="el" href="namespacerclcpp.html#a14a5d1b5fa11030e4141fd79e36cf2fdab1c94ca2fbc3e78fc30069c8d0f01680">SignalHandlerOptions::All</a>)</td></tr>
<tr class="memdesc:a90fb3d8fb164d5955bfbf1b8174d4048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install the global signal handler for rclcpp.  <a href="namespacerclcpp.html#a90fb3d8fb164d5955bfbf1b8174d4048">More...</a><br /></td></tr>
<tr class="separator:a90fb3d8fb164d5955bfbf1b8174d4048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3944023ee7719c1b3eab2a1cd4e0f3f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a3944023ee7719c1b3eab2a1cd4e0f3f3">signal_handlers_installed</a> ()</td></tr>
<tr class="memdesc:a3944023ee7719c1b3eab2a1cd4e0f3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the signal handlers are installed, otherwise false.  <a href="namespacerclcpp.html#a3944023ee7719c1b3eab2a1cd4e0f3f3">More...</a><br /></td></tr>
<tr class="separator:a3944023ee7719c1b3eab2a1cd4e0f3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbcabc619a77b7ca42e06c50a45b9cba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerclcpp.html#a14a5d1b5fa11030e4141fd79e36cf2fd">SignalHandlerOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#acbcabc619a77b7ca42e06c50a45b9cba">get_current_signal_handler_options</a> ()</td></tr>
<tr class="memdesc:acbcabc619a77b7ca42e06c50a45b9cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current signal handler options.  <a href="namespacerclcpp.html#acbcabc619a77b7ca42e06c50a45b9cba">More...</a><br /></td></tr>
<tr class="separator:acbcabc619a77b7ca42e06c50a45b9cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74690adaed20915f98b36c0e93d3231"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#ad74690adaed20915f98b36c0e93d3231">uninstall_signal_handlers</a> ()</td></tr>
<tr class="memdesc:ad74690adaed20915f98b36c0e93d3231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uninstall the global signal handler for rclcpp.  <a href="namespacerclcpp.html#ad74690adaed20915f98b36c0e93d3231">More...</a><br /></td></tr>
<tr class="separator:ad74690adaed20915f98b36c0e93d3231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c8d8abf67984be09c65440187a6576"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a54c8d8abf67984be09c65440187a6576">init_and_remove_ros_arguments</a> (int argc, char const *const *argv, const <a class="el" href="classrclcpp_1_1InitOptions.html">InitOptions</a> &amp;init_options=<a class="el" href="classrclcpp_1_1InitOptions.html">InitOptions</a>())</td></tr>
<tr class="memdesc:a54c8d8abf67984be09c65440187a6576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize communications via the rmw implementation and set up a global signal handler.  <a href="namespacerclcpp.html#a54c8d8abf67984be09c65440187a6576">More...</a><br /></td></tr>
<tr class="separator:a54c8d8abf67984be09c65440187a6576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab947f4199c93ecdf89c5eca4f7bda77c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#ab947f4199c93ecdf89c5eca4f7bda77c">remove_ros_arguments</a> (int argc, char const *const *argv)</td></tr>
<tr class="memdesc:ab947f4199c93ecdf89c5eca4f7bda77c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove ROS-specific arguments from argument vector.  <a href="namespacerclcpp.html#ab947f4199c93ecdf89c5eca4f7bda77c">More...</a><br /></td></tr>
<tr class="separator:ab947f4199c93ecdf89c5eca4f7bda77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe8ffd2b1769e897f2c50d560812b43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#adbe8ffd2b1769e897f2c50d560812b43">ok</a> (rclcpp::Context::SharedPtr context=nullptr)</td></tr>
<tr class="memdesc:adbe8ffd2b1769e897f2c50d560812b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check rclcpp's status.  <a href="namespacerclcpp.html#adbe8ffd2b1769e897f2c50d560812b43">More...</a><br /></td></tr>
<tr class="separator:adbe8ffd2b1769e897f2c50d560812b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493714a679d1591142800416a286689f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a493714a679d1591142800416a286689f">shutdown</a> (rclcpp::Context::SharedPtr context=nullptr, const std::string &amp;reason=&quot;user called rclcpp::shutdown()&quot;)</td></tr>
<tr class="memdesc:a493714a679d1591142800416a286689f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown rclcpp context, invalidating it for derived entities.  <a href="namespacerclcpp.html#a493714a679d1591142800416a286689f">More...</a><br /></td></tr>
<tr class="separator:a493714a679d1591142800416a286689f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e2c223964ccca7ede393af47fac025"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a01e2c223964ccca7ede393af47fac025">on_shutdown</a> (std::function&lt; void()&gt; callback, rclcpp::Context::SharedPtr context=nullptr)</td></tr>
<tr class="memdesc:a01e2c223964ccca7ede393af47fac025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a function to be called when shutdown is called on the context.  <a href="namespacerclcpp.html#a01e2c223964ccca7ede393af47fac025">More...</a><br /></td></tr>
<tr class="separator:a01e2c223964ccca7ede393af47fac025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac305329e4e97948d4bb216e894caa4ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#ac305329e4e97948d4bb216e894caa4ae">sleep_for</a> (const std::chrono::nanoseconds &amp;nanoseconds, rclcpp::Context::SharedPtr context=nullptr)</td></tr>
<tr class="memdesc:ac305329e4e97948d4bb216e894caa4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the global condition variable to block for the specified amount of time.  <a href="namespacerclcpp.html#ac305329e4e97948d4bb216e894caa4ae">More...</a><br /></td></tr>
<tr class="separator:ac305329e4e97948d4bb216e894caa4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af238f376176cf3da48adc46b94d29a6a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af238f376176cf3da48adc46b94d29a6a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#af238f376176cf3da48adc46b94d29a6a">add_will_overflow</a> (const T x, const T y)</td></tr>
<tr class="memdesc:af238f376176cf3da48adc46b94d29a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely check if addition will overflow.  <a href="namespacerclcpp.html#af238f376176cf3da48adc46b94d29a6a">More...</a><br /></td></tr>
<tr class="separator:af238f376176cf3da48adc46b94d29a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f62ce86fabd324005231d8d89a8294"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a26f62ce86fabd324005231d8d89a8294"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a26f62ce86fabd324005231d8d89a8294">add_will_underflow</a> (const T x, const T y)</td></tr>
<tr class="memdesc:a26f62ce86fabd324005231d8d89a8294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely check if addition will underflow.  <a href="namespacerclcpp.html#a26f62ce86fabd324005231d8d89a8294">More...</a><br /></td></tr>
<tr class="separator:a26f62ce86fabd324005231d8d89a8294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c63f4d5146a9054f3b2d8b9ac2070f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa7c63f4d5146a9054f3b2d8b9ac2070f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#aa7c63f4d5146a9054f3b2d8b9ac2070f">sub_will_overflow</a> (const T x, const T y)</td></tr>
<tr class="memdesc:aa7c63f4d5146a9054f3b2d8b9ac2070f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely check if subtraction will overflow.  <a href="namespacerclcpp.html#aa7c63f4d5146a9054f3b2d8b9ac2070f">More...</a><br /></td></tr>
<tr class="separator:aa7c63f4d5146a9054f3b2d8b9ac2070f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af340ddf3a7b82a7a5a4808740a039e69"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af340ddf3a7b82a7a5a4808740a039e69"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#af340ddf3a7b82a7a5a4808740a039e69">sub_will_underflow</a> (const T x, const T y)</td></tr>
<tr class="memdesc:af340ddf3a7b82a7a5a4808740a039e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely check if subtraction will underflow.  <a href="namespacerclcpp.html#af340ddf3a7b82a7a5a4808740a039e69">More...</a><br /></td></tr>
<tr class="separator:af340ddf3a7b82a7a5a4808740a039e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdf023cdc167cb3d4d353353cd4cced"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a1fdf023cdc167cb3d4d353353cd4cced">get_c_string</a> (const char *string_in)</td></tr>
<tr class="memdesc:a1fdf023cdc167cb3d4d353353cd4cced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the given string.  <a href="namespacerclcpp.html#a1fdf023cdc167cb3d4d353353cd4cced">More...</a><br /></td></tr>
<tr class="separator:a1fdf023cdc167cb3d4d353353cd4cced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7743e6192ef035115abdeeb90227c45c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a7743e6192ef035115abdeeb90227c45c">get_c_string</a> (const std::string &amp;string_in)</td></tr>
<tr class="memdesc:a7743e6192ef035115abdeeb90227c45c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the C string from the given std::string.  <a href="namespacerclcpp.html#a7743e6192ef035115abdeeb90227c45c">More...</a><br /></td></tr>
<tr class="separator:a7743e6192ef035115abdeeb90227c45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb4fa6ca00ef75ef9e5647990915fcd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const char * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a6eb4fa6ca00ef75ef9e5647990915fcd">get_c_vector_string</a> (const std::vector&lt; std::string &gt; &amp;strings_in)</td></tr>
<tr class="memdesc:a6eb4fa6ca00ef75ef9e5647990915fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the std::vector of C string from the given std::vector&lt;std::string&gt;.  <a href="namespacerclcpp.html#a6eb4fa6ca00ef75ef9e5647990915fcd">More...</a><br /></td></tr>
<tr class="separator:a6eb4fa6ca00ef75ef9e5647990915fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257a1c91269fde91781c115dd2503ce5"><td class="memTemplParams" colspan="2">template&lt;class MsgT , class Rep  = int64_t, class Period  = std::milli&gt; </td></tr>
<tr class="memitem:a257a1c91269fde91781c115dd2503ce5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#a257a1c91269fde91781c115dd2503ce5">wait_for_message</a> (MsgT &amp;out, std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1Subscription.html">rclcpp::Subscription</a>&lt; MsgT &gt;&gt; subscription, std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1Context.html">rclcpp::Context</a> &gt; context, std::chrono::duration&lt; Rep, Period &gt; time_to_wait=std::chrono::duration&lt; Rep, Period &gt;(-1))</td></tr>
<tr class="memdesc:a257a1c91269fde91781c115dd2503ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the next incoming message.  <a href="namespacerclcpp.html#a257a1c91269fde91781c115dd2503ce5">More...</a><br /></td></tr>
<tr class="separator:a257a1c91269fde91781c115dd2503ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3333ef9ec680d55315afc21ef754f7b"><td class="memTemplParams" colspan="2">template&lt;class MsgT , class Rep  = int64_t, class Period  = std::milli&gt; </td></tr>
<tr class="memitem:af3333ef9ec680d55315afc21ef754f7b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerclcpp.html#af3333ef9ec680d55315afc21ef754f7b">wait_for_message</a> (MsgT &amp;out, rclcpp::Node::SharedPtr node, const std::string &amp;topic, std::chrono::duration&lt; Rep, Period &gt; time_to_wait=std::chrono::duration&lt; Rep, Period &gt;(-1))</td></tr>
<tr class="memdesc:af3333ef9ec680d55315afc21ef754f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the next incoming message.  <a href="namespacerclcpp.html#af3333ef9ec680d55315afc21ef754f7b">More...</a><br /></td></tr>
<tr class="separator:af3333ef9ec680d55315afc21ef754f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Versions of rosidl_typesupport_cpp::get_message_type_support_handle that handle adapted types. </p>
<p>This header provides the <a class="el" href="namespacerclcpp_1_1node__interfaces.html#adf2b5917698e4101a968d5923f5d2ca6" title="Keep the NodeWaitablesInterface a shared pointer.">get_node_waitables_interface()</a> template function.</p>
<p>This header provides the <a class="el" href="namespacerclcpp_1_1node__interfaces.html#a8d074b92216b7d65e128633546e88132" title="Get the NodeTopicsInterface as a shared pointer from a pointer to a &quot;Node like&quot; object.">get_node_topics_interface()</a> template function.</p>
<p>This header provides the <a class="el" href="namespacerclcpp_1_1node__interfaces.html#a42ad166b1b772cdcc67c0276c3f95d72" title="Get the NodeTimersInterface as a shared pointer from a pointer to a &quot;Node like&quot; object.">get_node_timers_interface()</a> template function.</p>
<p>This header provides the <a class="el" href="namespacerclcpp_1_1node__interfaces.html#a9b61f8ce296493a974eac70bfdba5b36" title="Get the NodeTimeSourceInterface as a shared pointer from a pointer to a &quot;Node like&quot; object.">get_node_time_source_interface()</a> template function.</p>
<p>This header provides the <a class="el" href="namespacerclcpp_1_1node__interfaces.html#a9af98825a4a47a7dde30ead2697aef33" title="Get the NodeServicesInterface as a shared pointer from a pointer to a &quot;Node like&quot; object.">get_node_services_interface()</a> template function.</p>
<p>This header provides the <a class="el" href="namespacerclcpp_1_1node__interfaces.html#a478495f1925d3ffeccfedbdbed947ca5" title="Get the NodeParametersInterface as a shared pointer from a pointer to a &quot;Node like&quot; object.">get_node_parameters_interface()</a> template function.</p>
<p>This header provides the <a class="el" href="namespacerclcpp_1_1node__interfaces.html#af36ae2308d0a744bb6e1286a06f86600" title="Get the NodeLoggingInterface as a shared pointer from a pointer to a &quot;Node like&quot; object.">get_node_logging_interface()</a> template function.</p>
<p>This header provides the <a class="el" href="namespacerclcpp_1_1node__interfaces.html#a0379e5bdb52a0c8fe3bdccbc91c7e077" title="Get the NodeGraphInterface as a shared pointer from a pointer to a &quot;Node like&quot; object.">get_node_graph_interface()</a> template function.</p>
<p>This header provides the <a class="el" href="namespacerclcpp_1_1node__interfaces.html#af6a4decc6f9d3a1bb9fa5fb3f8dee079" title="Get the NodeClockInterface as a shared pointer from a pointer to a &quot;Node like&quot; object.">get_node_clock_interface()</a> template function.</p>
<p>This header provides the <a class="el" href="namespacerclcpp_1_1node__interfaces.html#a083ce6e14973774ec701d8e5a4e48d82" title="Get the NodeBaseInterface as a shared pointer from a pointer to a &quot;Node like&quot; object.">get_node_base_interface()</a> template function.</p>
<p>This function is useful for getting the NodeBaseInterface pointer from various kinds of Node-like classes.</p>
<p>It's able to get a std::shared_ptr to a NodeBaseInterface so long as the class has a method called <code><a class="el" href="namespacerclcpp_1_1node__interfaces.html#a083ce6e14973774ec701d8e5a4e48d82" title="Get the NodeBaseInterface as a shared pointer from a pointer to a &quot;Node like&quot; object.">get_node_base_interface()</a></code> which returns one.</p>
<p>This function is useful for getting the NodeClockInterface pointer from various kinds of Node-like classes.</p>
<p>It's able to get a std::shared_ptr to a NodeClockInterface so long as the class has a method called <code><a class="el" href="namespacerclcpp_1_1node__interfaces.html#af6a4decc6f9d3a1bb9fa5fb3f8dee079" title="Get the NodeClockInterface as a shared pointer from a pointer to a &quot;Node like&quot; object.">get_node_clock_interface()</a></code> which returns one.</p>
<p>This function is useful for getting the NodeGraphInterface pointer from various kinds of Node-like classes.</p>
<p>It's able to get a std::shared_ptr to a NodeGraphInterface so long as the class has a method called <code><a class="el" href="namespacerclcpp_1_1node__interfaces.html#a0379e5bdb52a0c8fe3bdccbc91c7e077" title="Get the NodeGraphInterface as a shared pointer from a pointer to a &quot;Node like&quot; object.">get_node_graph_interface()</a></code> which returns one.</p>
<p>This function is useful for getting the NodeLoggingInterface pointer from various kinds of Node-like classes.</p>
<p>It's able to get a std::shared_ptr to a NodeLoggingInterface so long as the class has a method called <code><a class="el" href="namespacerclcpp_1_1node__interfaces.html#af36ae2308d0a744bb6e1286a06f86600" title="Get the NodeLoggingInterface as a shared pointer from a pointer to a &quot;Node like&quot; object.">get_node_logging_interface()</a></code> which returns one.</p>
<p>This function is useful for getting the NodeParametersInterface pointer from various kinds of Node-like classes.</p>
<p>It's able to get a std::shared_ptr to a NodeParametersInterface so long as the class has a method called <code><a class="el" href="namespacerclcpp_1_1node__interfaces.html#a478495f1925d3ffeccfedbdbed947ca5" title="Get the NodeParametersInterface as a shared pointer from a pointer to a &quot;Node like&quot; object.">get_node_parameters_interface()</a></code> which returns one.</p>
<p>This function is useful for getting the NodeServicesInterface pointer from various kinds of Node-like classes.</p>
<p>It's able to get a std::shared_ptr to a NodeServicesInterface so long as the class has a method called <code><a class="el" href="namespacerclcpp_1_1node__interfaces.html#a9af98825a4a47a7dde30ead2697aef33" title="Get the NodeServicesInterface as a shared pointer from a pointer to a &quot;Node like&quot; object.">get_node_services_interface()</a></code> which returns one.</p>
<p>This function is useful for getting the NodeTimeSourceInterface pointer from various kinds of Node-like classes.</p>
<p>It's able to get a std::shared_ptr to a NodeTimeSourceInterface so long as the class has a method called <code><a class="el" href="namespacerclcpp_1_1node__interfaces.html#a9b61f8ce296493a974eac70bfdba5b36" title="Get the NodeTimeSourceInterface as a shared pointer from a pointer to a &quot;Node like&quot; object.">get_node_time_source_interface()</a></code> which returns one.</p>
<p>This function is useful for getting the NodeTimersInterface pointer from various kinds of Node-like classes.</p>
<p>It's able to get a std::shared_ptr to a NodeTimersInterface so long as the class has a method called <code><a class="el" href="namespacerclcpp_1_1node__interfaces.html#a42ad166b1b772cdcc67c0276c3f95d72" title="Get the NodeTimersInterface as a shared pointer from a pointer to a &quot;Node like&quot; object.">get_node_timers_interface()</a></code> which returns one.</p>
<p>This function is useful for getting the NodeTopicsInterface pointer from various kinds of Node-like classes.</p>
<p>It's able to get a std::shared_ptr to a NodeTopicsInterface so long as the class has a method called <code><a class="el" href="namespacerclcpp_1_1node__interfaces.html#a8d074b92216b7d65e128633546e88132" title="Get the NodeTopicsInterface as a shared pointer from a pointer to a &quot;Node like&quot; object.">get_node_topics_interface()</a></code> which returns one.</p>
<p>This function is useful for getting the NodeWaitablesInterface pointer from various kinds of Node-like classes.</p>
<p>It's able to get a std::shared_ptr to a NodeWaitablesInterface so long as the class has a method called <code><a class="el" href="namespacerclcpp_1_1node__interfaces.html#adf2b5917698e4101a968d5923f5d2ca6" title="Keep the NodeWaitablesInterface a shared pointer.">get_node_waitables_interface()</a></code> which returns one. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a5da79bfb6561c87736d5b49f30a4d0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da79bfb6561c87736d5b49f30a4d0f2">&#9670;&nbsp;</a></span>OnShutdownCallbackHandle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#a5da79bfb6561c87736d5b49f30a4d0f2">rclcpp::OnShutdownCallbackHandle</a> = typedef <a class="el" href="classrclcpp_1_1ShutdownCallbackHandle.html">ShutdownCallbackHandle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a11c8d247dce6ecea5941201ba33ae2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c8d247dce6ecea5941201ba33ae2b4">&#9670;&nbsp;</a></span>PreShutdownCallbackHandle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#a11c8d247dce6ecea5941201ba33ae2b4">rclcpp::PreShutdownCallbackHandle</a> = typedef <a class="el" href="classrclcpp_1_1ShutdownCallbackHandle.html">ShutdownCallbackHandle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5de5071053a1993f126aaa3a907ae649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5de5071053a1993f126aaa3a907ae649">&#9670;&nbsp;</a></span>WeakCallbackGroupsToNodesMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;rclcpp::CallbackGroup::WeakPtr, rclcpp::node_interfaces::NodeBaseInterface::WeakPtr, std::owner_less&lt;rclcpp::CallbackGroup::WeakPtr&gt; &gt; <a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">rclcpp::WeakCallbackGroupsToNodesMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa587f11d0e53c713ccc0addf5132d46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa587f11d0e53c713ccc0addf5132d46a">&#9670;&nbsp;</a></span>ParameterMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#aa587f11d0e53c713ccc0addf5132d46a">rclcpp::ParameterMap</a> = typedef std::unordered_map&lt;std::string, std::vector&lt;<a class="el" href="classrclcpp_1_1Parameter.html">Parameter</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A map of fully qualified node names to a list of parameters. </p>

</div>
</div>
<a id="a9f38e986e5843aa39fc2b9fff9cf927f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f38e986e5843aa39fc2b9fff9cf927f">&#9670;&nbsp;</a></span>PublisherOptions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#a9f38e986e5843aa39fc2b9fff9cf927f">rclcpp::PublisherOptions</a> = typedef <a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">PublisherOptionsWithAllocator</a>&lt;std::allocator&lt;void&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a51f406f0e8e4928bd5490d5b170c2c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f406f0e8e4928bd5490d5b170c2c3b">&#9670;&nbsp;</a></span>QOSDeadlineRequestedInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#a51f406f0e8e4928bd5490d5b170c2c3b">rclcpp::QOSDeadlineRequestedInfo</a> = typedef rmw_requested_deadline_missed_status_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aedf85a88396716dfeff77447176ed05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf85a88396716dfeff77447176ed05c">&#9670;&nbsp;</a></span>QOSDeadlineOfferedInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#aedf85a88396716dfeff77447176ed05c">rclcpp::QOSDeadlineOfferedInfo</a> = typedef rmw_offered_deadline_missed_status_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a144fad513d523f56d77a071740da8d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144fad513d523f56d77a071740da8d11">&#9670;&nbsp;</a></span>QOSLivelinessChangedInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#a144fad513d523f56d77a071740da8d11">rclcpp::QOSLivelinessChangedInfo</a> = typedef rmw_liveliness_changed_status_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a89114d63f459ecc69241fa4f0dfc1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a89114d63f459ecc69241fa4f0dfc1f">&#9670;&nbsp;</a></span>QOSLivelinessLostInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#a0a89114d63f459ecc69241fa4f0dfc1f">rclcpp::QOSLivelinessLostInfo</a> = typedef rmw_liveliness_lost_status_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d3a2cfc089710ffbe4b46c5f5f6bf51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d3a2cfc089710ffbe4b46c5f5f6bf51">&#9670;&nbsp;</a></span>QOSMessageLostInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#a0d3a2cfc089710ffbe4b46c5f5f6bf51">rclcpp::QOSMessageLostInfo</a> = typedef rmw_message_lost_status_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af6174538b0f569e38ba3be09812ad54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6174538b0f569e38ba3be09812ad54c">&#9670;&nbsp;</a></span>QOSOfferedIncompatibleQoSInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#af6174538b0f569e38ba3be09812ad54c">rclcpp::QOSOfferedIncompatibleQoSInfo</a> = typedef rmw_offered_qos_incompatible_event_status_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a26c69f1ce0937b36bc3915e989fb9faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c69f1ce0937b36bc3915e989fb9faf">&#9670;&nbsp;</a></span>QOSRequestedIncompatibleQoSInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#a26c69f1ce0937b36bc3915e989fb9faf">rclcpp::QOSRequestedIncompatibleQoSInfo</a> = typedef rmw_requested_qos_incompatible_event_status_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a742c7a1550bb04d91fc14f92adffd218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742c7a1550bb04d91fc14f92adffd218">&#9670;&nbsp;</a></span>QOSDeadlineRequestedCallbackType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#a742c7a1550bb04d91fc14f92adffd218">rclcpp::QOSDeadlineRequestedCallbackType</a> = typedef std::function&lt;void (<a class="el" href="namespacerclcpp.html#a51f406f0e8e4928bd5490d5b170c2c3b">QOSDeadlineRequestedInfo</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb6987cb949f1c2992beb9887311a5b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6987cb949f1c2992beb9887311a5b6">&#9670;&nbsp;</a></span>QOSDeadlineOfferedCallbackType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#abb6987cb949f1c2992beb9887311a5b6">rclcpp::QOSDeadlineOfferedCallbackType</a> = typedef std::function&lt;void (<a class="el" href="namespacerclcpp.html#aedf85a88396716dfeff77447176ed05c">QOSDeadlineOfferedInfo</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a51148cfeddce96db7ad911fa893a4d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51148cfeddce96db7ad911fa893a4d82">&#9670;&nbsp;</a></span>QOSLivelinessChangedCallbackType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#a51148cfeddce96db7ad911fa893a4d82">rclcpp::QOSLivelinessChangedCallbackType</a> = typedef std::function&lt;void (<a class="el" href="namespacerclcpp.html#a144fad513d523f56d77a071740da8d11">QOSLivelinessChangedInfo</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a33673fe9ebe74818bc56d517eae84a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33673fe9ebe74818bc56d517eae84a03">&#9670;&nbsp;</a></span>QOSLivelinessLostCallbackType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#a33673fe9ebe74818bc56d517eae84a03">rclcpp::QOSLivelinessLostCallbackType</a> = typedef std::function&lt;void (<a class="el" href="namespacerclcpp.html#a0a89114d63f459ecc69241fa4f0dfc1f">QOSLivelinessLostInfo</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5992e56be639d6edfa7d41ac2e8ebfbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5992e56be639d6edfa7d41ac2e8ebfbb">&#9670;&nbsp;</a></span>QOSMessageLostCallbackType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#a5992e56be639d6edfa7d41ac2e8ebfbb">rclcpp::QOSMessageLostCallbackType</a> = typedef std::function&lt;void (<a class="el" href="namespacerclcpp.html#a0d3a2cfc089710ffbe4b46c5f5f6bf51">QOSMessageLostInfo</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a859176cdce7e529ada6dfa9b0c41be24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859176cdce7e529ada6dfa9b0c41be24">&#9670;&nbsp;</a></span>QOSOfferedIncompatibleQoSCallbackType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#a859176cdce7e529ada6dfa9b0c41be24">rclcpp::QOSOfferedIncompatibleQoSCallbackType</a> = typedef std::function&lt;void (<a class="el" href="namespacerclcpp.html#af6174538b0f569e38ba3be09812ad54c">QOSOfferedIncompatibleQoSInfo</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7ae5f255085a1ee084a83b7b8ec4ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ae5f255085a1ee084a83b7b8ec4ddb">&#9670;&nbsp;</a></span>QOSRequestedIncompatibleQoSCallbackType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#ab7ae5f255085a1ee084a83b7b8ec4ddb">rclcpp::QOSRequestedIncompatibleQoSCallbackType</a> = typedef std::function&lt;void (<a class="el" href="namespacerclcpp.html#a26c69f1ce0937b36bc3915e989fb9faf">QOSRequestedIncompatibleQoSInfo</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0998d12a1177c3019bbeb278a91f6698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0998d12a1177c3019bbeb278a91f6698">&#9670;&nbsp;</a></span>QosCallbackResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#a0998d12a1177c3019bbeb278a91f6698">rclcpp::QosCallbackResult</a> = typedef rcl_interfaces::msg::SetParametersResult</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad43bf8aa3d3ba663a8890b43f8db8c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43bf8aa3d3ba663a8890b43f8db8c46">&#9670;&nbsp;</a></span>QosCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#ad43bf8aa3d3ba663a8890b43f8db8c46">rclcpp::QosCallback</a> = typedef std::function&lt;<a class="el" href="namespacerclcpp.html#a0998d12a1177c3019bbeb278a91f6698">QosCallbackResult</a>(const <a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe6d4a275a0f75ba817c8486f641f4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6d4a275a0f75ba817c8486f641f4ea">&#9670;&nbsp;</a></span>Rate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#abe6d4a275a0f75ba817c8486f641f4ea">rclcpp::Rate</a> = typedef <a class="el" href="classrclcpp_1_1GenericRate.html">GenericRate</a>&lt;std::chrono::system_clock&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c57364eb16ca720485d170ee5b99cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c57364eb16ca720485d170ee5b99cf7">&#9670;&nbsp;</a></span>WallRate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#a9c57364eb16ca720485d170ee5b99cf7">rclcpp::WallRate</a> = typedef <a class="el" href="classrclcpp_1_1GenericRate.html">GenericRate</a>&lt;std::chrono::steady_clock&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0ce420d67bb40b61156347455d3ad23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ce420d67bb40b61156347455d3ad23">&#9670;&nbsp;</a></span>SubscriptionOptions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#aa0ce420d67bb40b61156347455d3ad23">rclcpp::SubscriptionOptions</a> = typedef <a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">SubscriptionOptionsWithAllocator</a>&lt;std::allocator&lt;void&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aba01c682b9c93b3ff844cc36ea80fda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba01c682b9c93b3ff844cc36ea80fda1">&#9670;&nbsp;</a></span>VoidCallbackType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#aba01c682b9c93b3ff844cc36ea80fda1">rclcpp::VoidCallbackType</a> = typedef std::function&lt;void ()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6bb5a91fd8ef745ce261338f803fc9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6bb5a91fd8ef745ce261338f803fc9e">&#9670;&nbsp;</a></span>TimerCallbackType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#aa6bb5a91fd8ef745ce261338f803fc9e">rclcpp::TimerCallbackType</a> = typedef std::function&lt;void (<a class="el" href="classrclcpp_1_1TimerBase.html">TimerBase</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6fb19c154de27e92430309d2da25ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6fb19c154de27e92430309d2da25ac3">&#9670;&nbsp;</a></span>WaitSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#ad6fb19c154de27e92430309d2da25ac3">rclcpp::WaitSet</a> = typedef <a class="el" href="classrclcpp_1_1WaitSetTemplate.html">rclcpp::WaitSetTemplate</a>&lt; <a class="el" href="classrclcpp_1_1wait__set__policies_1_1SequentialSynchronization.html">rclcpp::wait_set_policies::SequentialSynchronization</a>, <a class="el" href="classrclcpp_1_1wait__set__policies_1_1DynamicStorage.html">rclcpp::wait_set_policies::DynamicStorage</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Most common user configuration of a WaitSet, which is dynamic but not thread-safe. </p>
<p>This wait set allows you to add and remove items dynamically, and it will automatically remove items that are let out of scope each time wait() or prune_destroyed_entities() is called.</p>
<p>It will not, however, provide thread-safety for adding and removing entities while waiting.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1WaitSetTemplate.html" title="Encapsulates sets of waitable items which can be waited on as a group.">rclcpp::WaitSetTemplate</a> for API documentation </dd></dl>

</div>
</div>
<a id="adb06acf4a5723b1445fa6ed4e8f73374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb06acf4a5723b1445fa6ed4e8f73374">&#9670;&nbsp;</a></span>StaticWaitSet</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NumberOfSubscriptions, std::size_t NumberOfGuardCondtions, std::size_t NumberOfTimers, std::size_t NumberOfClients, std::size_t NumberOfServices, std::size_t NumberOfWaitables&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#adb06acf4a5723b1445fa6ed4e8f73374">rclcpp::StaticWaitSet</a> = typedef <a class="el" href="classrclcpp_1_1WaitSetTemplate.html">rclcpp::WaitSetTemplate</a>&lt; <a class="el" href="classrclcpp_1_1wait__set__policies_1_1SequentialSynchronization.html">rclcpp::wait_set_policies::SequentialSynchronization</a>, <a class="el" href="classrclcpp_1_1wait__set__policies_1_1StaticStorage.html">rclcpp::wait_set_policies::StaticStorage</a>&lt; NumberOfSubscriptions, NumberOfGuardCondtions, NumberOfTimers, NumberOfClients, NumberOfServices, NumberOfWaitables &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>WaitSet configuration which does not allow changes after construction. </p>
<p>This wait set requires that you specify all entities at construction, and prevents you from calling the typical add and remove functions. It also requires that you specify how many of each item there will be as a template argument.</p>
<p>It will share ownership of the entities until destroyed, therefore it will prevent the destruction of entities so long as the wait set exists, even if the user lets their copy of the shared pointer to the entity go out of scope.</p>
<p>Since the wait set cannot be mutated, it does not need to be thread-safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1WaitSetTemplate.html" title="Encapsulates sets of waitable items which can be waited on as a group.">rclcpp::WaitSetTemplate</a> for API documentation </dd></dl>

</div>
</div>
<a id="acaec573e71549fd3078644e18e7f7127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaec573e71549fd3078644e18e7f7127">&#9670;&nbsp;</a></span>ThreadSafeWaitSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerclcpp.html#acaec573e71549fd3078644e18e7f7127">rclcpp::ThreadSafeWaitSet</a> = typedef <a class="el" href="classrclcpp_1_1WaitSetTemplate.html">rclcpp::WaitSetTemplate</a>&lt; <a class="el" href="classrclcpp_1_1wait__set__policies_1_1ThreadSafeSynchronization.html">rclcpp::wait_set_policies::ThreadSafeSynchronization</a>, <a class="el" href="classrclcpp_1_1wait__set__policies_1_1DynamicStorage.html">rclcpp::wait_set_policies::DynamicStorage</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like WaitSet, this configuration is dynamic, but is also thread-safe. </p>
<p>This wait set allows you to add and remove items dynamically, and it will automatically remove items that are let out of scope each time wait() or prune_destroyed_entities() is called.</p>
<p>It will also ensure that adding and removing items explicitly from the wait set is done in a thread-safe way, protecting against concurrent add and deletes, as well as add and deletes during a wait(). This thread-safety comes at some overhead and the use of thread synchronization primitives.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1WaitSetTemplate.html" title="Encapsulates sets of waitable items which can be waited on as a group.">rclcpp::WaitSetTemplate</a> for API documentation </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a0027d5804ef28f0b6fea8eea4195c44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0027d5804ef28f0b6fea8eea4195c44a">&#9670;&nbsp;</a></span>CallbackGroupType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacerclcpp.html#a0027d5804ef28f0b6fea8eea4195c44a">rclcpp::CallbackGroupType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0027d5804ef28f0b6fea8eea4195c44aa0a658d9024420a1c2f737e8881406f7d"></a>MutuallyExclusive&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0027d5804ef28f0b6fea8eea4195c44aa49816c033d9f3ad7e81fdb953fe3251f"></a>Reentrant&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a7b4ff5f1e516740d7e11ea97fe6f5532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4ff5f1e516740d7e11ea97fe6f5532">&#9670;&nbsp;</a></span>FutureReturnCode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacerclcpp.html#a7b4ff5f1e516740d7e11ea97fe6f5532">rclcpp::FutureReturnCode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return codes to be used with spin_until_future_complete. </p>
<p>SUCCESS: The future is complete and can be accessed with "get" without blocking. This does not indicate that the operation succeeded; "get" may still throw an exception. INTERRUPTED: The future is not complete, spinning was interrupted by Ctrl-C or another error. TIMEOUT: Spinning timed out. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7b4ff5f1e516740d7e11ea97fe6f5532ad0749aaba8b833466dfcbb0428e4f89c"></a>SUCCESS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b4ff5f1e516740d7e11ea97fe6f5532a658f2cadfdf09b6046246e9314f7cd43"></a>INTERRUPTED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b4ff5f1e516740d7e11ea97fe6f5532a070a0fb40f6c308ab544b227660aadff"></a>TIMEOUT&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a53c5da68d5964c6bd7894afe4a76a92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c5da68d5964c6bd7894afe4a76a92b">&#9670;&nbsp;</a></span>IntraProcessBufferType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacerclcpp.html#a53c5da68d5964c6bd7894afe4a76a92b">rclcpp::IntraProcessBufferType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used as argument in create_publisher and create_subscriber when intra-process communication is enabled </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a53c5da68d5964c6bd7894afe4a76a92ba309589a0fa2f1ec5e6b286ac5e8b6ac8"></a>SharedPtr&#160;</td><td class="fielddoc"><p>Set the data type used in the intra-process buffer as std::shared_ptr&lt;MessageT&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="a53c5da68d5964c6bd7894afe4a76a92ba8c4322b401772928915c5a3ada1304d5"></a>UniquePtr&#160;</td><td class="fielddoc"><p>Set the data type used in the intra-process buffer as std::unique_ptr&lt;MessageT&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="a53c5da68d5964c6bd7894afe4a76a92ba50c8a640832cc7a38533a3d5d3da60df"></a>CallbackDefault&#160;</td><td class="fielddoc"><p>Set the data type used in the intra-process buffer as the same used in the callback. </p>
</td></tr>
</table>

</div>
</div>
<a id="a2ebc5fdfcb7e3f025f8ebc2fe1d10fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebc5fdfcb7e3f025f8ebc2fe1d10fe5">&#9670;&nbsp;</a></span>IntraProcessSetting</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacerclcpp.html#a2ebc5fdfcb7e3f025f8ebc2fe1d10fe5">rclcpp::IntraProcessSetting</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used as argument in create_publisher and create_subscriber. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2ebc5fdfcb7e3f025f8ebc2fe1d10fe5a2faec1f9f8cc7f8f40d521c4dd574f49"></a>Enable&#160;</td><td class="fielddoc"><p>Explicitly enable intraprocess comm at publisher/subscription level. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ebc5fdfcb7e3f025f8ebc2fe1d10fe5abcfaccebf745acfd5e75351095a5394a"></a>Disable&#160;</td><td class="fielddoc"><p>Explicitly disable intraprocess comm at publisher/subscription level. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ebc5fdfcb7e3f025f8ebc2fe1d10fe5a5e7bd84eadd196f52e8320680fa1c7cf"></a>NodeDefault&#160;</td><td class="fielddoc"><p>Take intraprocess configuration from the node. </p>
</td></tr>
</table>

</div>
</div>
<a id="ad47a956a91d1787241c564827be18aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47a956a91d1787241c564827be18aa5">&#9670;&nbsp;</a></span>EndpointType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacerclcpp.html#ad47a956a91d1787241c564827be18aa5">rclcpp::EndpointType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad47a956a91d1787241c564827be18aa5a4bbb8f967da6d1a610596d7257179c2b"></a>Invalid&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad47a956a91d1787241c564827be18aa5a32c73be0cb175da278c8e2af0811b0d1"></a>Publisher&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad47a956a91d1787241c564827be18aa5a787ad0b7a17de4ad6b1711bbf8d79fcb"></a>Subscription&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a1b307a4b7368b68f325812cd2aeb8784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b307a4b7368b68f325812cd2aeb8784">&#9670;&nbsp;</a></span>ParameterType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacerclcpp.html#a1b307a4b7368b68f325812cd2aeb8784">rclcpp::ParameterType</a> : uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1b307a4b7368b68f325812cd2aeb8784adefddb470d1054265245a0c5dbeccf4e"></a>PARAMETER_NOT_SET&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1b307a4b7368b68f325812cd2aeb8784a525d4dd60c307e7fb76d57cdeafce8b1"></a>PARAMETER_BOOL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1b307a4b7368b68f325812cd2aeb8784a3a70ea9e9528656834106cf8a647e878"></a>PARAMETER_INTEGER&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1b307a4b7368b68f325812cd2aeb8784a21dd7d8db14cc732692bea98eb073c20"></a>PARAMETER_DOUBLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1b307a4b7368b68f325812cd2aeb8784a1ed2b44e2043e3cf925a1891e19fd73a"></a>PARAMETER_STRING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1b307a4b7368b68f325812cd2aeb8784aac6f099e5c9b63fd51a75ae587a98271"></a>PARAMETER_BYTE_ARRAY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1b307a4b7368b68f325812cd2aeb8784ab14cef41f8d8d14f9beef95eeb6dd91d"></a>PARAMETER_BOOL_ARRAY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1b307a4b7368b68f325812cd2aeb8784a5b5c50ef3c04a90a59a31b3ad20a4495"></a>PARAMETER_INTEGER_ARRAY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1b307a4b7368b68f325812cd2aeb8784af685d20a1a39f3531732919ee99f44ab"></a>PARAMETER_DOUBLE_ARRAY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1b307a4b7368b68f325812cd2aeb8784ab19e036eb99725754e11c35c6f8d9eb1"></a>PARAMETER_STRING_ARRAY&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="aa48cefe5c31e4efce7e715a23f02fc6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48cefe5c31e4efce7e715a23f02fc6a">&#9670;&nbsp;</a></span>HistoryPolicy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacerclcpp.html#aa48cefe5c31e4efce7e715a23f02fc6a">rclcpp::HistoryPolicy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa48cefe5c31e4efce7e715a23f02fc6aadc899de472766d7f25128b9ef50be307"></a>KeepLast&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa48cefe5c31e4efce7e715a23f02fc6aa98e4e92f8ed10755a2fde1531cf6593f"></a>KeepAll&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa48cefe5c31e4efce7e715a23f02fc6aaa8408867e3b24998945a2bed87c68e99"></a>SystemDefault&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa48cefe5c31e4efce7e715a23f02fc6aa88183b946cc5f0e8c96b2e66e1c74a7e"></a>Unknown&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a4f037ff6e64986ad3e4ee883e0b2ed2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f037ff6e64986ad3e4ee883e0b2ed2d">&#9670;&nbsp;</a></span>ReliabilityPolicy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacerclcpp.html#a4f037ff6e64986ad3e4ee883e0b2ed2d">rclcpp::ReliabilityPolicy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4f037ff6e64986ad3e4ee883e0b2ed2dab4ee632ee2b420e4c4954189eafa9230"></a>BestEffort&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4f037ff6e64986ad3e4ee883e0b2ed2da84fcf5d37086f2a93953734ce8f385b6"></a>Reliable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4f037ff6e64986ad3e4ee883e0b2ed2daa8408867e3b24998945a2bed87c68e99"></a>SystemDefault&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4f037ff6e64986ad3e4ee883e0b2ed2da88183b946cc5f0e8c96b2e66e1c74a7e"></a>Unknown&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a13741e50907b01ddeea83a16188edf0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13741e50907b01ddeea83a16188edf0a">&#9670;&nbsp;</a></span>DurabilityPolicy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacerclcpp.html#a13741e50907b01ddeea83a16188edf0a">rclcpp::DurabilityPolicy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a13741e50907b01ddeea83a16188edf0aa3e3af98b6b48c7e593d8d18863e3333b"></a>Volatile&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a13741e50907b01ddeea83a16188edf0aa8fd20371a3df287397529e4ee976e789"></a>TransientLocal&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a13741e50907b01ddeea83a16188edf0aaa8408867e3b24998945a2bed87c68e99"></a>SystemDefault&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a13741e50907b01ddeea83a16188edf0aa88183b946cc5f0e8c96b2e66e1c74a7e"></a>Unknown&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a56271e3680feaec39139227875c22c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56271e3680feaec39139227875c22c13">&#9670;&nbsp;</a></span>LivelinessPolicy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacerclcpp.html#a56271e3680feaec39139227875c22c13">rclcpp::LivelinessPolicy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a56271e3680feaec39139227875c22c13a086247a9b57fde6eefee2a0c4752242d"></a>Automatic&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a56271e3680feaec39139227875c22c13aae5b271e7f73d240d803d1e4f1ab1e04"></a>ManualByTopic&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a56271e3680feaec39139227875c22c13aa8408867e3b24998945a2bed87c68e99"></a>SystemDefault&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a56271e3680feaec39139227875c22c13a88183b946cc5f0e8c96b2e66e1c74a7e"></a>Unknown&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="af41ae37222bc420861a9ff6f6a28317b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41ae37222bc420861a9ff6f6a28317b">&#9670;&nbsp;</a></span>QoSCompatibility</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacerclcpp.html#af41ae37222bc420861a9ff6f6a28317b">rclcpp::QoSCompatibility</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af41ae37222bc420861a9ff6f6a28317baa60852f204ed8028c1c58808b746d115"></a>Ok&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af41ae37222bc420861a9ff6f6a28317ba0eaadb4fcb48a0a0ed7bc9868be9fbaa"></a>Warning&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af41ae37222bc420861a9ff6f6a28317ba902b0d55fddef6f8d651fe1035b7d4bd"></a>Error&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a3c74c05a2168fd52b86ab9b444499f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c74c05a2168fd52b86ab9b444499f77">&#9670;&nbsp;</a></span>QosPolicyKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacerclcpp.html#a3c74c05a2168fd52b86ab9b444499f77">rclcpp::QosPolicyKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3c74c05a2168fd52b86ab9b444499f77a588630e52044c477c618108567c0c760"></a>AvoidRosNamespaceConventions&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3c74c05a2168fd52b86ab9b444499f77a159f7d51b9a4ff702c9b5543b8f7980f"></a>Deadline&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3c74c05a2168fd52b86ab9b444499f77a675056ad1441b6375b2c5abd48c27ef1"></a>Depth&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3c74c05a2168fd52b86ab9b444499f77a2166e76dc88d642260416a536b06a412"></a>Durability&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3c74c05a2168fd52b86ab9b444499f77a16d2b386b2034b9488996466aaae0b57"></a>History&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3c74c05a2168fd52b86ab9b444499f77a3520ef938b9cf9042a48781b2b6bc0d8"></a>Lifespan&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3c74c05a2168fd52b86ab9b444499f77a3d854aed48edf57a11246c60b263fc1b"></a>Liveliness&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3c74c05a2168fd52b86ab9b444499f77abff62ed3f553ba4e0327fcc99ee20650"></a>LivelinessLeaseDuration&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3c74c05a2168fd52b86ab9b444499f77a820b8f74ad843d1574106ec4cadfc07e"></a>Reliability&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3c74c05a2168fd52b86ab9b444499f77a4bbb8f967da6d1a610596d7257179c2b"></a>Invalid&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a1faa0b05040d3cf0f74c231b6800bffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1faa0b05040d3cf0f74c231b6800bffc">&#9670;&nbsp;</a></span>TopicStatisticsState</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacerclcpp.html#a1faa0b05040d3cf0f74c231b6800bffc">rclcpp::TopicStatisticsState</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Represent the state of topic statistics collector. Used as argument in create_subscriber. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1faa0b05040d3cf0f74c231b6800bffca2faec1f9f8cc7f8f40d521c4dd574f49"></a>Enable&#160;</td><td class="fielddoc"><p>Explicitly enable topic statistics at subscription level. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1faa0b05040d3cf0f74c231b6800bffcabcfaccebf745acfd5e75351095a5394a"></a>Disable&#160;</td><td class="fielddoc"><p>Explicitly disable topic statistics at subscription level. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1faa0b05040d3cf0f74c231b6800bffca5e7bd84eadd196f52e8320680fa1c7cf"></a>NodeDefault&#160;</td><td class="fielddoc"><p>Take topic statistics state from the node. </p>
</td></tr>
</table>

</div>
</div>
<a id="a14a5d1b5fa11030e4141fd79e36cf2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a5d1b5fa11030e4141fd79e36cf2fd">&#9670;&nbsp;</a></span>SignalHandlerOptions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacerclcpp.html#a14a5d1b5fa11030e4141fd79e36cf2fd">rclcpp::SignalHandlerOptions</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Option to indicate which signal handlers rclcpp should install. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a14a5d1b5fa11030e4141fd79e36cf2fdab1c94ca2fbc3e78fc30069c8d0f01680"></a>All&#160;</td><td class="fielddoc"><p>Install both sigint and sigterm, this is the default behavior. </p>
</td></tr>
<tr><td class="fieldname"><a id="a14a5d1b5fa11030e4141fd79e36cf2fdade31d36d3ef6ffbb33f10bedfd3770ed"></a>SigInt&#160;</td><td class="fielddoc"><p>Install only a sigint handler. </p>
</td></tr>
<tr><td class="fieldname"><a id="a14a5d1b5fa11030e4141fd79e36cf2fda3aad7def98c3981ae3f34a64454a051f"></a>SigTerm&#160;</td><td class="fielddoc"><p>Install only a sigterm handler. </p>
</td></tr>
<tr><td class="fieldname"><a id="a14a5d1b5fa11030e4141fd79e36cf2fda6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>Do not install any signal handler. </p>
</td></tr>
</table>

</div>
</div>
<a id="aac834535a6eab608968bbb44d9773bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac834535a6eab608968bbb44d9773bb1">&#9670;&nbsp;</a></span>WaitResultKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacerclcpp.html#aac834535a6eab608968bbb44d9773bb1">rclcpp::WaitResultKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the various kinds of results from waiting on a wait set. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aac834535a6eab608968bbb44d9773bb1ad46050bbb7cc1d8c1836bdb94bc428b4"></a>Ready&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aac834535a6eab608968bbb44d9773bb1ab55663adb793759edd2082b5194f1cd3"></a>Timeout&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aac834535a6eab608968bbb44d9773bb1aaaec822ce6caf3162cbe3cc2cfa1cdc0"></a>Empty&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af73bf64bfc1b01f030012cd6d2e6e43c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73bf64bfc1b01f030012cd6d2e6e43c">&#9670;&nbsp;</a></span>get_contexts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Context::SharedPtr&gt; rclcpp::get_contexts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a copy of the list of context shared pointers. </p>
<p>This function is thread-safe. </p>

</div>
</div>
<a id="a24538aeccf07c4966c3192623d06440a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24538aeccf07c4966c3192623d06440a">&#9670;&nbsp;</a></span>create_client()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ServiceT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1Client.html">rclcpp::Client</a>&lt;ServiceT&gt;::SharedPtr rclcpp::create_client </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeBaseInterface.html">node_interfaces::NodeBaseInterface</a> &gt;&#160;</td>
          <td class="paramname"><em>node_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeGraphInterface.html">node_interfaces::NodeGraphInterface</a> &gt;&#160;</td>
          <td class="paramname"><em>node_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeServicesInterface.html">node_interfaces::NodeServicesInterface</a> &gt;&#160;</td>
          <td class="paramname"><em>node_services</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rmw_qos_profile_t &amp;&#160;</td>
          <td class="paramname"><em>qos_profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rclcpp::CallbackGroup::SharedPtr&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a service client with a given type. </p>

</div>
</div>
<a id="ab896cb8ec7eeecfe50cdfa9dbc19e761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab896cb8ec7eeecfe50cdfa9dbc19e761">&#9670;&nbsp;</a></span>create_generic_publisher()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorT  = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classrclcpp_1_1GenericPublisher.html">GenericPublisher</a>&gt; rclcpp::create_generic_publisher </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeTopicsInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>topics_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> &amp;&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">rclcpp::PublisherOptionsWithAllocator</a>&lt; AllocatorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>(&#160;&#160;&#160;&#160;<a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">rclcpp::PublisherOptionsWithAllocator</a>&lt;AllocatorT&gt;()&#160;&#160;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and return a <a class="el" href="classrclcpp_1_1GenericPublisher.html" title="Publisher for serialized messages whose type is not known at compile time.">GenericPublisher</a>. </p>
<p>The returned pointer will never be empty, but this function can throw various exceptions, for instance when the message's package can not be found on the AMENT_PREFIX_PATH.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topics_interface</td><td>NodeTopicsInterface pointer used in parts of the setup </td></tr>
    <tr><td class="paramname">topic_name</td><td>Topic name </td></tr>
    <tr><td class="paramname">topic_type</td><td>Topic type </td></tr>
    <tr><td class="paramname">qos</td><td>QoS settings </td></tr>
    <tr><td class="paramname">options</td><td>Publisher options. Not all publisher options are currently respected, the only relevant options for this publisher are <code>event_callbacks</code>, <code>use_default_callbacks</code>, and <code>callback_group</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0472e08dbece2e13ad9da04eae5147f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0472e08dbece2e13ad9da04eae5147f8">&#9670;&nbsp;</a></span>create_generic_subscription()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorT  = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classrclcpp_1_1GenericSubscription.html">GenericSubscription</a>&gt; rclcpp::create_generic_subscription </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeTopicsInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>topics_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> &amp;&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1SerializedMessage.html">rclcpp::SerializedMessage</a> &gt;)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">rclcpp::SubscriptionOptionsWithAllocator</a>&lt; AllocatorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>(&#160;&#160;&#160;&#160;<a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">rclcpp::SubscriptionOptionsWithAllocator</a>&lt;AllocatorT&gt;()&#160;&#160;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and return a <a class="el" href="classrclcpp_1_1GenericSubscription.html" title="Subscription for serialized messages whose type is not known at compile time.">GenericSubscription</a>. </p>
<p>The returned pointer will never be empty, but this function can throw various exceptions, for instance when the message's package can not be found on the AMENT_PREFIX_PATH.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topics_interface</td><td>NodeTopicsInterface pointer used in parts of the setup. </td></tr>
    <tr><td class="paramname">topic_name</td><td>Topic name </td></tr>
    <tr><td class="paramname">topic_type</td><td>Topic type </td></tr>
    <tr><td class="paramname">qos</td><td>QoS settings </td></tr>
    <tr><td class="paramname">callback</td><td>Callback for new messages of serialized form </td></tr>
    <tr><td class="paramname">options</td><td>Publisher options. Not all publisher options are currently respected, the only relevant options for this publisher are <code>event_callbacks</code>, <code>use_default_callbacks</code>, and <code>callback_group</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8db5d1c8332968a358e668c50012545b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db5d1c8332968a358e668c50012545b">&#9670;&nbsp;</a></span>create_publisher() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageT , typename AllocatorT  = std::allocator&lt;void&gt;, typename PublisherT  = rclcpp::Publisher&lt;MessageT, AllocatorT&gt;, typename NodeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;PublisherT&gt; rclcpp::create_publisher </td>
          <td>(</td>
          <td class="paramtype">NodeT &amp;&amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> &amp;&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">rclcpp::PublisherOptionsWithAllocator</a>&lt; AllocatorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>(&#160;&#160;&#160;&#160;<a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">rclcpp::PublisherOptionsWithAllocator</a>&lt;AllocatorT&gt;()&#160;&#160;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and return a publisher of the given MessageT type. </p>
<p>The NodeT type only needs to have a method called <a class="el" href="namespacerclcpp_1_1node__interfaces.html#a8d074b92216b7d65e128633546e88132" title="Get the NodeTopicsInterface as a shared pointer from a pointer to a &quot;Node like&quot; object.">get_node_topics_interface()</a> which returns a shared_ptr to a NodeTopicsInterface.</p>
<p>In case <code>options.qos_overriding_options</code> is enabling qos parameter overrides, NodeT must also have a method called <a class="el" href="namespacerclcpp_1_1node__interfaces.html#a478495f1925d3ffeccfedbdbed947ca5" title="Get the NodeParametersInterface as a shared pointer from a pointer to a &quot;Node like&quot; object.">get_node_parameters_interface()</a> which returns a shared_ptr to a NodeParametersInterface. </p>

</div>
</div>
<a id="a84269833709d75060a46bcc8fb70e7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84269833709d75060a46bcc8fb70e7b8">&#9670;&nbsp;</a></span>create_publisher() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageT , typename AllocatorT  = std::allocator&lt;void&gt;, typename PublisherT  = rclcpp::Publisher&lt;MessageT, AllocatorT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;PublisherT&gt; rclcpp::create_publisher </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeParametersInterface::SharedPtr &amp;&#160;</td>
          <td class="paramname"><em>node_parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rclcpp::node_interfaces::NodeTopicsInterface::SharedPtr &amp;&#160;</td>
          <td class="paramname"><em>node_topics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> &amp;&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">rclcpp::PublisherOptionsWithAllocator</a>&lt; AllocatorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>(&#160;&#160;&#160;&#160;<a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">rclcpp::PublisherOptionsWithAllocator</a>&lt;AllocatorT&gt;()&#160;&#160;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and return a publisher of the given MessageT type. </p>

</div>
</div>
<a id="a08f170aa649d228312e5eab2497042fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f170aa649d228312e5eab2497042fb">&#9670;&nbsp;</a></span>create_service()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ServiceT , typename CallbackT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1Service.html">rclcpp::Service</a>&lt;ServiceT&gt;::SharedPtr rclcpp::create_service </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeBaseInterface.html">node_interfaces::NodeBaseInterface</a> &gt;&#160;</td>
          <td class="paramname"><em>node_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeServicesInterface.html">node_interfaces::NodeServicesInterface</a> &gt;&#160;</td>
          <td class="paramname"><em>node_services</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rmw_qos_profile_t &amp;&#160;</td>
          <td class="paramname"><em>qos_profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rclcpp::CallbackGroup::SharedPtr&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a service with a given type. </p>

</div>
</div>
<a id="ab715b48e5db24c2b95d1d9e0a060ab64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab715b48e5db24c2b95d1d9e0a060ab64">&#9670;&nbsp;</a></span>create_subscription() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageT , typename CallbackT , typename AllocatorT  = std::allocator&lt;void&gt;, typename SubscriptionT  = rclcpp::Subscription&lt;MessageT, AllocatorT&gt;, typename MessageMemoryStrategyT  = typename SubscriptionT::MessageMemoryStrategyType, typename NodeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;SubscriptionT&gt; rclcpp::create_subscription </td>
          <td>(</td>
          <td class="paramtype">NodeT &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> &amp;&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">rclcpp::SubscriptionOptionsWithAllocator</a>&lt; AllocatorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>(&#160;&#160;&#160;&#160;<a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">rclcpp::SubscriptionOptionsWithAllocator</a>&lt;AllocatorT&gt;()&#160;&#160;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MessageMemoryStrategyT::SharedPtr&#160;</td>
          <td class="paramname"><em>msg_mem_strat</em> = <code>(&#160;&#160;&#160;&#160;MessageMemoryStrategyT::create_default()&#160;&#160;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and return a subscription of the given MessageT type. </p>
<p>The NodeT type only needs to have a method called <a class="el" href="namespacerclcpp_1_1node__interfaces.html#a8d074b92216b7d65e128633546e88132" title="Get the NodeTopicsInterface as a shared pointer from a pointer to a &quot;Node like&quot; object.">get_node_topics_interface()</a> which returns a shared_ptr to a NodeTopicsInterface, or be a NodeTopicsInterface pointer itself.</p>
<p>In case <code>options.qos_overriding_options</code> is enabling qos parameter overrides, NodeT must also have a method called <a class="el" href="namespacerclcpp_1_1node__interfaces.html#a478495f1925d3ffeccfedbdbed947ca5" title="Get the NodeParametersInterface as a shared pointer from a pointer to a &quot;Node like&quot; object.">get_node_parameters_interface()</a> which returns a shared_ptr to a NodeParametersInterface.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MessageT</td><td></td></tr>
    <tr><td class="paramname">CallbackT</td><td></td></tr>
    <tr><td class="paramname">AllocatorT</td><td></td></tr>
    <tr><td class="paramname">SubscriptionT</td><td></td></tr>
    <tr><td class="paramname">MessageMemoryStrategyT</td><td></td></tr>
    <tr><td class="paramname">NodeT</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
    <tr><td class="paramname">topic_name</td><td></td></tr>
    <tr><td class="paramname">qos</td><td></td></tr>
    <tr><td class="paramname">callback</td><td></td></tr>
    <tr><td class="paramname">options</td><td></td></tr>
    <tr><td class="paramname">msg_mem_strat</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created subscription </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if topic statistics is enabled and the publish period is less than or equal to zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35c35ecfee66ee62914501b3ac991631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c35ecfee66ee62914501b3ac991631">&#9670;&nbsp;</a></span>create_subscription() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageT , typename CallbackT , typename AllocatorT  = std::allocator&lt;void&gt;, typename SubscriptionT  = rclcpp::Subscription&lt;MessageT, AllocatorT&gt;, typename MessageMemoryStrategyT  = typename SubscriptionT::MessageMemoryStrategyType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;SubscriptionT&gt; rclcpp::create_subscription </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeParametersInterface::SharedPtr &amp;&#160;</td>
          <td class="paramname"><em>node_parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rclcpp::node_interfaces::NodeTopicsInterface::SharedPtr &amp;&#160;</td>
          <td class="paramname"><em>node_topics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1QoS.html">rclcpp::QoS</a> &amp;&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">rclcpp::SubscriptionOptionsWithAllocator</a>&lt; AllocatorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>(&#160;&#160;&#160;&#160;<a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">rclcpp::SubscriptionOptionsWithAllocator</a>&lt;AllocatorT&gt;()&#160;&#160;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MessageMemoryStrategyT::SharedPtr&#160;</td>
          <td class="paramname"><em>msg_mem_strat</em> = <code>(&#160;&#160;&#160;&#160;MessageMemoryStrategyT::create_default()&#160;&#160;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and return a subscription of the given MessageT type. </p>
<p>See <a class="el" href="namespacerclcpp.html#ab715b48e5db24c2b95d1d9e0a060ab64">create_subscription()</a>. </p>

</div>
</div>
<a id="a0c53f2add6632d67becd1885d26362c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c53f2add6632d67becd1885d26362c5">&#9670;&nbsp;</a></span>create_timer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CallbackT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::TimerBase::SharedPtr rclcpp::create_timer </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeBaseInterface.html">node_interfaces::NodeBaseInterface</a> &gt;&#160;</td>
          <td class="paramname"><em>node_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeTimersInterface.html">node_interfaces::NodeTimersInterface</a> &gt;&#160;</td>
          <td class="paramname"><em>node_timers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rclcpp::Clock::SharedPtr&#160;</td>
          <td class="paramname"><em>clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1Duration.html">rclcpp::Duration</a>&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rclcpp::CallbackGroup::SharedPtr&#160;</td>
          <td class="paramname"><em>group</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a timer with a given clock </p>

</div>
</div>
<a id="affb29d356bf00583b0d705b264b3b0ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb29d356bf00583b0d705b264b3b0ae">&#9670;&nbsp;</a></span>create_timer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeT , typename CallbackT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::TimerBase::SharedPtr rclcpp::create_timer </td>
          <td>(</td>
          <td class="paramtype">NodeT&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rclcpp::Clock::SharedPtr&#160;</td>
          <td class="paramname"><em>clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1Duration.html">rclcpp::Duration</a>&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rclcpp::CallbackGroup::SharedPtr&#160;</td>
          <td class="paramname"><em>group</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a timer with a given clock. </p>

</div>
</div>
<a id="ad987fd245e31c6fd16d70d6ed1186189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad987fd245e31c6fd16d70d6ed1186189">&#9670;&nbsp;</a></span>create_wall_timer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DurationRepT , typename DurationT , typename CallbackT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1WallTimer.html">rclcpp::WallTimer</a>&lt;CallbackT&gt;::SharedPtr rclcpp::create_wall_timer </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; DurationRepT, DurationT &gt;&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackT&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rclcpp::CallbackGroup::SharedPtr&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeBaseInterface.html">node_interfaces::NodeBaseInterface</a> *&#160;</td>
          <td class="paramname"><em>node_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1node__interfaces_1_1NodeTimersInterface.html">node_interfaces::NodeTimersInterface</a> *&#160;</td>
          <td class="paramname"><em>node_timers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to create a timer with node resources. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DurationRepT</td><td></td></tr>
    <tr><td class="paramname">DurationT</td><td></td></tr>
    <tr><td class="paramname">CallbackT</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>period to execute callback. This duration must be 0 &lt;= period &lt; nanoseconds::max() </td></tr>
    <tr><td class="paramname">callback</td><td>callback to execute via the timer period </td></tr>
    <tr><td class="paramname">group</td><td></td></tr>
    <tr><td class="paramname">node_base</td><td></td></tr>
    <tr><td class="paramname">node_timers</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid</td><td>argument if either node_base or node_timers are null, or period is negative or too large </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad48c7a9cc4fa34989a0849d708d8f7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48c7a9cc4fa34989a0849d708d8f7de">&#9670;&nbsp;</a></span>spin_some() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::spin_some </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a default single-threaded executor and execute any immediately available work. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_ptr</td><td>Shared pointer to the node to spin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e16488d62cc48e5520101f9f4f4102a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e16488d62cc48e5520101f9f4f4102a">&#9670;&nbsp;</a></span>spin_some() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::spin_some </td>
          <td>(</td>
          <td class="paramtype">rclcpp::Node::SharedPtr&#160;</td>
          <td class="paramname"><em>node_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21e13577f5bcc5992de1d7dd08d8652b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e13577f5bcc5992de1d7dd08d8652b">&#9670;&nbsp;</a></span>spin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::spin </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a default single-threaded executor and spin the specified node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_ptr</td><td>Shared pointer to the node to spin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4bb335bc95a6fa8546a6bfcfd087eb57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb335bc95a6fa8546a6bfcfd087eb57">&#9670;&nbsp;</a></span>spin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::spin </td>
          <td>(</td>
          <td class="paramtype">rclcpp::Node::SharedPtr&#160;</td>
          <td class="paramname"><em>node_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab83b41b70748bbd4631b498596148360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83b41b70748bbd4631b498596148360">&#9670;&nbsp;</a></span>spin_until_future_complete() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FutureT , typename TimeRepT  = int64_t, typename TimeT  = std::milli&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerclcpp.html#a7b4ff5f1e516740d7e11ea97fe6f5532">rclcpp::FutureReturnCode</a> rclcpp::spin_until_future_complete </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FutureT &amp;&#160;</td>
          <td class="paramname"><em>future</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; TimeRepT, TimeT &gt;&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::duration&lt;TimeRepT,&#160;TimeT&gt;(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a99d07cddc30219a944b5a7bcba4b84bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d07cddc30219a944b5a7bcba4b84bc">&#9670;&nbsp;</a></span>spin_until_future_complete() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeT  = rclcpp::Node, typename FutureT , typename TimeRepT  = int64_t, typename TimeT  = std::milli&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerclcpp.html#a7b4ff5f1e516740d7e11ea97fe6f5532">rclcpp::FutureReturnCode</a> rclcpp::spin_until_future_complete </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; NodeT &gt;&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FutureT &amp;&#160;</td>
          <td class="paramname"><em>future</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; TimeRepT, TimeT &gt;&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::duration&lt;TimeRepT,&#160;TimeT&gt;(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1855b992b1b77f1ed75bab5192aaf2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1855b992b1b77f1ed75bab5192aaf2bd">&#9670;&nbsp;</a></span>expand_topic_or_service_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string rclcpp::expand_topic_or_service_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>node_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>namespace_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_service</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand a topic or service name and throw if it is not valid. </p>
<p>This function can be used to "just" validate a topic or service name too, since expanding the topic name is required to fully validate a name.</p>
<p>If the name is invalid, then InvalidTopicNameError is thrown or InvalidServiceNameError if is_service is true.</p>
<p>This function can take any form of a topic or service name, i.e. it does not have to be a fully qualified name. The node name and namespace are used to expand it if necessary while validating it.</p>
<p>Expansion is done with rcl_expand_topic_name. The validation is doen with rcl_validate_topic_name and rmw_validate_full_topic_name, so details about failures can be found in the documentation for those functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the topic or service name to be validated </td></tr>
    <tr><td class="paramname">node_name</td><td>the name of the node associated with the name </td></tr>
    <tr><td class="paramname">namespace_</td><td>the namespace of the node associated with the name </td></tr>
    <tr><td class="paramname">is_service</td><td>if true InvalidServiceNameError is thrown instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expanded (and validated) topic name </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidTopicNameError</td><td>if name is invalid and is_service is false </td></tr>
    <tr><td class="paramname">InvalidServiceNameError</td><td>if name is invalid and is_service is true </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if memory cannot be allocated </td></tr>
    <tr><td class="paramname">RCLError</td><td>if an unexpect error occurs </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the topic name is unexpectedly valid or, if the rcl name is invalid or if the rcl namespace is invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a474b200d67e8a5988daaeb8980fb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a474b200d67e8a5988daaeb8980fb8b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; rclcpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacerclcpp.html#a7b4ff5f1e516740d7e11ea97fe6f5532">FutureReturnCode</a> &amp;&#160;</td>
          <td class="paramname"><em>future_return_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream operator for FutureReturnCode. </p>

</div>
</div>
<a id="a0a11b0ee43bb55e4eca3a79866406e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a11b0ee43bb55e4eca3a79866406e5e">&#9670;&nbsp;</a></span>to_string() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string rclcpp::to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacerclcpp.html#a7b4ff5f1e516740d7e11ea97fe6f5532">FutureReturnCode</a> &amp;&#160;</td>
          <td class="paramname"><em>future_return_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>String conversion function for FutureReturnCode. </p>

</div>
</div>
<a id="a07373238f06f8a884da53850bdc9072e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07373238f06f8a884da53850bdc9072e">&#9670;&nbsp;</a></span>get_message_type_support_handle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const rosidl_message_type_support_t&amp; rclcpp::get_message_type_support_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the message type support for the given <code>MessageT</code> type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MessageT</td><td>an actual ROS message type or an adapted type using <code><a class="el" href="structrclcpp_1_1TypeAdapter.html" title="Template structure used to adapt custom, user-defined types to ROS types.">rclcpp::TypeAdapter</a></code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7295751947c08312aa69f45fd673171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7295751947c08312aa69f45fd673171">&#9670;&nbsp;</a></span>get_logger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1Logger.html">Logger</a> rclcpp::get_logger </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a named logger. </p>
<p>The returned logger's name will include any naming conventions, such as a name prefix. Currently there are no such naming conventions but they may be introduced in the future.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the name of the logger </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a logger with the fully-qualified name including naming conventions, or </dd>
<dd>
a dummy logger if logging is disabled. </dd></dl>

</div>
</div>
<a id="a32cf150e9157d8ae52206bbb7f1a9310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32cf150e9157d8ae52206bbb7f1a9310">&#9670;&nbsp;</a></span>get_node_logger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1Logger.html">Logger</a> rclcpp::get_node_logger </td>
          <td>(</td>
          <td class="paramtype">const rcl_node_t *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a named logger using an rcl_node_t. </p>
<p>This is a convenience function that does error checking and returns the node logger name, or "rclcpp" if it is unable to get the node name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>the rcl node from which to get the logger name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a logger based on the node name, or "rclcpp" if there's an error </dd></dl>

</div>
</div>
<a id="a9af1b5c6b911fe1715a20c9d8f0c1f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af1b5c6b911fe1715a20c9d8f0c1f61">&#9670;&nbsp;</a></span>get_logging_directory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rcpputils::fs::path rclcpp::get_logging_directory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current logging directory. </p>
<p>For more details of how the logging directory is determined, see rcl_logging_get_logging_directory().</p>
<dl class="section return"><dt>Returns</dt><dd>the logging directory being used. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1exceptions_1_1RCLError.html" title="Created when the return code does not match one of the other specialized exceptions.">rclcpp::exceptions::RCLError</a></td><td>if an unexpected error occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17def20ce6fc1e5be8c1e2496998034b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17def20ce6fc1e5be8c1e2496998034b">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1NetworkFlowEndpoint.html">NetworkFlowEndpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1NetworkFlowEndpoint.html">NetworkFlowEndpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two <a class="el" href="classrclcpp_1_1NetworkFlowEndpoint.html">NetworkFlowEndpoint</a> instances are equal. </p>

</div>
</div>
<a id="a7f7df6710c1fe3f51a3cac31cda94c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7df6710c1fe3f51a3cac31cda94c75">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1NetworkFlowEndpoint.html">NetworkFlowEndpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1NetworkFlowEndpoint.html">NetworkFlowEndpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two <a class="el" href="classrclcpp_1_1NetworkFlowEndpoint.html">NetworkFlowEndpoint</a> instances are not equal. </p>

</div>
</div>
<a id="acaf768479c9fb964f9f84c4f866cd79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf768479c9fb964f9f84c4f866cd79d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; rclcpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1NetworkFlowEndpoint.html">NetworkFlowEndpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>network_flow_endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming helper for <a class="el" href="classrclcpp_1_1NetworkFlowEndpoint.html">NetworkFlowEndpoint</a>. </p>

</div>
</div>
<a id="ac1760a6f74638be846e5d5c3b0478232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1760a6f74638be846e5d5c3b0478232">&#9670;&nbsp;</a></span>extend_name_with_sub_namespace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string rclcpp::extend_name_with_sub_namespace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sub_namespace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d8f47054b6c550888eca755f3203f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8f47054b6c550888eca755f3203f05">&#9670;&nbsp;</a></span>_to_json_dict_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string rclcpp::_to_json_dict_entry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1Parameter.html">Parameter</a> &amp;&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a json encoded version of the parameter intended for a dict. </p>

</div>
</div>
<a id="a6980e39627cfc70b542040ada42ca607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6980e39627cfc70b542040ada42ca607">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; rclcpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1Parameter.html">rclcpp::Parameter</a> &amp;&#160;</td>
          <td class="paramname"><em>pv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e9c5f2bb49142b5f5ad11a8cf1c9328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9c5f2bb49142b5f5ad11a8cf1c9328">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; rclcpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classrclcpp_1_1Parameter.html">Parameter</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa974dc62646d9123ab206ca602c5e089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa974dc62646d9123ab206ca602c5e089">&#9670;&nbsp;</a></span>parameter_map_from() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerclcpp.html#aa587f11d0e53c713ccc0addf5132d46a">ParameterMap</a> rclcpp::parameter_map_from </td>
          <td>(</td>
          <td class="paramtype">const rcl_params_t *const&#160;</td>
          <td class="paramname"><em>c_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert parameters from rcl_yaml_param_parser into C++ class instances. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c_params</td><td>C structures containing parameters for multiple nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a map where the keys are fully qualified node names and values a list of parameters. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidParametersException</td><td>if the <code>rcl_params_t</code> is inconsistent or invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e2133ca88053d99904e9c1fa4fc7dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2133ca88053d99904e9c1fa4fc7dff">&#9670;&nbsp;</a></span>parameter_map_from() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerclcpp.html#aa587f11d0e53c713ccc0addf5132d46a">ParameterMap</a> rclcpp::parameter_map_from </td>
          <td>(</td>
          <td class="paramtype">const rcl_params_t *const&#160;</td>
          <td class="paramname"><em>c_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>node_fqn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert parameters from rcl_yaml_param_parser into C++ class instances. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c_params</td><td>C structures containing parameters for multiple nodes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node_fqn</td><td>a Fully Qualified Name of node, default value is nullptr. If it's not nullptr, return the relative node parameters belonging to this node_fqn. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a map where the keys are fully qualified node names and values a list of parameters. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidParametersException</td><td>if the <code>rcl_params_t</code> is inconsistent or invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1a3f3243d1e335570334169979080cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a3f3243d1e335570334169979080cd">&#9670;&nbsp;</a></span>parameter_value_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1ParameterValue.html">ParameterValue</a> rclcpp::parameter_value_from </td>
          <td>(</td>
          <td class="paramtype">const rcl_variant_t *const&#160;</td>
          <td class="paramname"><em>c_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert parameter value from rcl_yaml_param_parser into a C++ class instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c_value</td><td>C structure containing a value of a parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of a parameter value </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidParameterValueException</td><td>if the <code>rcl_variant_t</code> is inconsistent or invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a561b8286e2c64005500b9328522415f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561b8286e2c64005500b9328522415f2">&#9670;&nbsp;</a></span>parameter_map_from_yaml_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerclcpp.html#aa587f11d0e53c713ccc0addf5132d46a">ParameterMap</a> rclcpp::parameter_map_from_yaml_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>yaml_filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the ParameterMap from a yaml file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">yaml_filename</td><td>full name of the yaml file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of a parameter map </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">from</td><td>rcl error of rcl_parse_yaml_file() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36b93cd43e33e496e2a43f3eb9504b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b93cd43e33e496e2a43f3eb9504b12">&#9670;&nbsp;</a></span>to_string() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string rclcpp::to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerclcpp.html#a1b307a4b7368b68f325812cd2aeb8784">ParameterType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of a parameter type. </p>

</div>
</div>
<a id="aed5caea480fefe503c1a7a02b4024dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5caea480fefe503c1a7a02b4024dca">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; rclcpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerclcpp.html#a1b307a4b7368b68f325812cd2aeb8784">ParameterType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc7cfb4c8905865fb02f3c8018657057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7cfb4c8905865fb02f3c8018657057">&#9670;&nbsp;</a></span>to_string() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string rclcpp::to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1ParameterValue.html">ParameterValue</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value of a parameter as a string. </p>

</div>
</div>
<a id="a16897dedbda576cf6035188bdc7365d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16897dedbda576cf6035188bdc7365d7">&#9670;&nbsp;</a></span>create_publisher_factory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageT , typename AllocatorT , typename PublisherT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrclcpp_1_1PublisherFactory.html">PublisherFactory</a> rclcpp::create_publisher_factory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrclcpp_1_1PublisherOptionsWithAllocator.html">rclcpp::PublisherOptionsWithAllocator</a>&lt; AllocatorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="structrclcpp_1_1PublisherFactory.html" title="Factory with functions used to create a MessageT specific PublisherT.">PublisherFactory</a> with functions setup for creating a PublisherT&lt;MessageT, AllocatorT&gt;. </p>

</div>
</div>
<a id="a7bf3573ad178cad6dcdad0e8cdbdfe6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf3573ad178cad6dcdad0e8cdbdfe6f">&#9670;&nbsp;</a></span>qos_policy_name_from_kind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string rclcpp::qos_policy_name_from_kind </td>
          <td>(</td>
          <td class="paramtype">rmw_qos_policy_kind_t&#160;</td>
          <td class="paramname"><em>policy_kind</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9c7e823d8b8cbde96e0e295065c3836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c7e823d8b8cbde96e0e295065c3836">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1QoS.html">QoS</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1QoS.html">QoS</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two <a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">QoS</a> profiles are exactly equal in all policy values. </p>

</div>
</div>
<a id="af233f254408ae99037eaef31e6655e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af233f254408ae99037eaef31e6655e0d">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1QoS.html">QoS</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1QoS.html">QoS</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12c5407c58578bfc64f5489476b433ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c5407c58578bfc64f5489476b433ae">&#9670;&nbsp;</a></span>qos_check_compatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrclcpp_1_1QoSCheckCompatibleResult.html">QoSCheckCompatibleResult</a> rclcpp::qos_check_compatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1QoS.html">QoS</a> &amp;&#160;</td>
          <td class="paramname"><em>publisher_qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1QoS.html">QoS</a> &amp;&#160;</td>
          <td class="paramname"><em>subscription_qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two <a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">QoS</a> profiles are compatible. </p>
<p>Two <a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">QoS</a> profiles are compatible if a publisher and subcription using the <a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">QoS</a> policies can communicate with each other.</p>
<p>If any policies have value "system default" or "unknown" then it is possible that compatiblity cannot be determined. In this case, the value QoSCompatility::Warning is set as part of the returned structure.</p>
<p>Example usage:</p>
<div class="fragment"><div class="line"><a class="code" href="structrclcpp_1_1QoSCheckCompatibleResult.html">rclcpp::QoSCheckCompatibleResult</a> result = <a class="code" href="namespacerclcpp.html#a12c5407c58578bfc64f5489476b433ae">rclcpp::qos_check_compatible</a>(</div>
<div class="line">  publisher_qos, subscription_qos);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="namespacerclcpp.html#af41ae37222bc420861a9ff6f6a28317ba902b0d55fddef6f8d651fe1035b7d4bd">rclcpp::QoSCompatibility::Error</a> != result.<a class="code" href="structrclcpp_1_1QoSCheckCompatibleResult.html#a1962570cbb3f054719c2c0659f1a4522">compatibility</a>) {</div>
<div class="line">  <span class="comment">// QoS not compatible ...</span></div>
<div class="line">  <span class="comment">// result.reason contains info about the incompatibility</span></div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespacerclcpp.html#af41ae37222bc420861a9ff6f6a28317ba0eaadb4fcb48a0a0ed7bc9868be9fbaa">rclcpp::QoSCompatibility::Warning</a> != result.<a class="code" href="structrclcpp_1_1QoSCheckCompatibleResult.html#a1962570cbb3f054719c2c0659f1a4522">compatibility</a>) {</div>
<div class="line">  <span class="comment">// QoS may not be compatible ...</span></div>
<div class="line">  <span class="comment">// result.reason contains info about the possible incompatibility</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespacerclcpp_html_a12c5407c58578bfc64f5489476b433ae"><div class="ttname"><a href="namespacerclcpp.html#a12c5407c58578bfc64f5489476b433ae">rclcpp::qos_check_compatible</a></div><div class="ttdeci">QoSCheckCompatibleResult qos_check_compatible(const QoS &amp;publisher_qos, const QoS &amp;subscription_qos)</div><div class="ttdoc">Check if two QoS profiles are compatible.</div></div>
<div class="ttc" id="anamespacerclcpp_html_af41ae37222bc420861a9ff6f6a28317ba0eaadb4fcb48a0a0ed7bc9868be9fbaa"><div class="ttname"><a href="namespacerclcpp.html#af41ae37222bc420861a9ff6f6a28317ba0eaadb4fcb48a0a0ed7bc9868be9fbaa">rclcpp::QoSCompatibility::Warning</a></div><div class="ttdeci">@ Warning</div></div>
<div class="ttc" id="anamespacerclcpp_html_af41ae37222bc420861a9ff6f6a28317ba902b0d55fddef6f8d651fe1035b7d4bd"><div class="ttname"><a href="namespacerclcpp.html#af41ae37222bc420861a9ff6f6a28317ba902b0d55fddef6f8d651fe1035b7d4bd">rclcpp::QoSCompatibility::Error</a></div><div class="ttdeci">@ Error</div></div>
<div class="ttc" id="astructrclcpp_1_1QoSCheckCompatibleResult_html"><div class="ttname"><a href="structrclcpp_1_1QoSCheckCompatibleResult.html">rclcpp::QoSCheckCompatibleResult</a></div><div class="ttdoc">Result type for checking QoS compatibility.</div><div class="ttdef"><b>Definition:</b> qos.hpp:289</div></div>
<div class="ttc" id="astructrclcpp_1_1QoSCheckCompatibleResult_html_a1962570cbb3f054719c2c0659f1a4522"><div class="ttname"><a href="structrclcpp_1_1QoSCheckCompatibleResult.html#a1962570cbb3f054719c2c0659f1a4522">rclcpp::QoSCheckCompatibleResult::compatibility</a></div><div class="ttdeci">QoSCompatibility compatibility</div><div class="ttdoc">Compatibility result.</div><div class="ttdef"><b>Definition:</b> qos.hpp:291</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher_qos</td><td>The <a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">QoS</a> profile for a publisher. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription_qos</td><td>The <a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">QoS</a> profile for a subscription. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Struct with compatiblity set to <a class="el" href="namespacerclcpp.html#af41ae37222bc420861a9ff6f6a28317baa60852f204ed8028c1c58808b746d115">QoSCompatibility::Ok</a> if the <a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">QoS</a> profiles are compatible, or </dd>
<dd>
Struct with compatibility set to <a class="el" href="namespacerclcpp.html#af41ae37222bc420861a9ff6f6a28317ba0eaadb4fcb48a0a0ed7bc9868be9fbaa">QoSCompatibility::Warning</a> if there is a chance the <a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">QoS</a> profiles are not compatible, or </dd>
<dd>
Struct with compatibility set to <a class="el" href="namespacerclcpp.html#af41ae37222bc420861a9ff6f6a28317ba902b0d55fddef6f8d651fe1035b7d4bd">QoSCompatibility::Error</a> if the <a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">QoS</a> profiles are not compatible. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rclcpp::exceptions::QoSCheckCompatibilityException</td><td>if an unexpected error occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae553419da8035418ba3cc797c1f0a549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae553419da8035418ba3cc797c1f0a549">&#9670;&nbsp;</a></span>qos_policy_kind_to_cstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rclcpp::qos_policy_kind_to_cstr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacerclcpp.html#a3c74c05a2168fd52b86ab9b444499f77">QosPolicyKind</a> &amp;&#160;</td>
          <td class="paramname"><em>qpk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6308b091df681f6bb7964b44520dfb55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6308b091df681f6bb7964b44520dfb55">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; rclcpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacerclcpp.html#a3c74c05a2168fd52b86ab9b444499f77">QosPolicyKind</a> &amp;&#160;</td>
          <td class="paramname"><em>qpk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc7846ba2bee783fa9352c7073f30eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7846ba2bee783fa9352c7073f30eec">&#9670;&nbsp;</a></span>make_scope_exit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Callable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrclcpp_1_1ScopeExit.html">ScopeExit</a>&lt;Callable&gt; rclcpp::make_scope_exit </td>
          <td>(</td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac67447383503d7920af81bf6334b21a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67447383503d7920af81bf6334b21a8">&#9670;&nbsp;</a></span>create_subscription_factory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageT , typename CallbackT , typename AllocatorT , typename SubscriptionT  = rclcpp::Subscription&lt;MessageT, AllocatorT&gt;, typename MessageMemoryStrategyT  = typename SubscriptionT::MessageMemoryStrategyType, typename ROSMessageType  = typename SubscriptionT::ROSMessageType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrclcpp_1_1SubscriptionFactory.html">SubscriptionFactory</a> rclcpp::create_subscription_factory </td>
          <td>(</td>
          <td class="paramtype">CallbackT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrclcpp_1_1SubscriptionOptionsWithAllocator.html">rclcpp::SubscriptionOptionsWithAllocator</a>&lt; AllocatorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MessageMemoryStrategyT::SharedPtr&#160;</td>
          <td class="paramname"><em>msg_mem_strat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1topic__statistics_1_1SubscriptionTopicStatistics.html">rclcpp::topic_statistics::SubscriptionTopicStatistics</a>&lt; ROSMessageType &gt;&gt;&#160;</td>
          <td class="paramname"><em>subscription_topic_stats</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="structrclcpp_1_1SubscriptionFactory.html" title="Factory containing a function used to create a Subscription&lt;MessageT&gt;.">SubscriptionFactory</a> setup to create a SubscriptionT&lt;MessageT, AllocatorT&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The user-defined callback function to receive a message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Additional options for the creation of the <a class="el" href="classrclcpp_1_1Subscription.html" title="Subscription implementation, templated on the type of message this subscription receives.">Subscription</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg_mem_strat</td><td>The message memory strategy to use for allocating messages. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription_topic_stats</td><td>Optional stats callback for <a class="el" href="namespacerclcpp_1_1topic__statistics.html">topic_statistics</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31b2ba48a94966a93b36de2e52cae2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b2ba48a94966a93b36de2e52cae2bb">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1Time.html">Time</a> rclcpp::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1Duration.html">rclcpp::Duration</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1Time.html">rclcpp::Time</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>if addition leads to overflow </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a629c76e9f974bbaed3b82b030f7f1b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629c76e9f974bbaed3b82b030f7f1b01">&#9670;&nbsp;</a></span>get_typesupport_library()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;rcpputils::SharedLibrary&gt; rclcpp::get_typesupport_library </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>typesupport_identifier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the type support library for the given type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The topic type, e.g. "std_msgs/msg/String" </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">typesupport_identifier</td><td>Type support identifier, typically "rosidl_typesupport_cpp" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared library </dd></dl>

</div>
</div>
<a id="a5fec6c87f54a15eb20ab963f2516373f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fec6c87f54a15eb20ab963f2516373f">&#9670;&nbsp;</a></span>get_typesupport_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const rosidl_message_type_support_t* rclcpp::get_typesupport_handle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>typesupport_identifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rcpputils::SharedLibrary &amp;&#160;</td>
          <td class="paramname"><em>library</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the type support handle from the library. </p>
<p>The library needs to match the topic type. The shared library must stay loaded for the lifetime of the result. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The topic type, e.g. "std_msgs/msg/String" </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">typesupport_identifier</td><td>Type support identifier, typically "rosidl_typesupport_cpp" </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">library</td><td>The shared type support library </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A type support handle </dd></dl>

</div>
</div>
<a id="a026b2ac505c383735117de5d1679ed80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026b2ac505c383735117de5d1679ed80">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const *&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1InitOptions.html">InitOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>init_options</em> = <code><a class="el" href="classrclcpp_1_1InitOptions.html">InitOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerclcpp.html#a14a5d1b5fa11030e4141fd79e36cf2fd">SignalHandlerOptions</a>&#160;</td>
          <td class="paramname"><em>signal_handler_options</em> = <code><a class="el" href="namespacerclcpp.html#a14a5d1b5fa11030e4141fd79e36cf2fdab1c94ca2fbc3e78fc30069c8d0f01680">SignalHandlerOptions::All</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize communications via the rmw implementation and set up a global signal handler. </p>
<p>Initializes the global context which is accessible via the function <a class="el" href="namespacerclcpp_1_1contexts.html#a18a2108b667f7e582db2c9ef216870a6">rclcpp::contexts::get_global_default_context()</a>. Also, installs the global signal handlers with the function <a class="el" href="namespacerclcpp.html#a90fb3d8fb164d5955bfbf1b8174d4048" title="Install the global signal handler for rclcpp.">rclcpp::install_signal_handlers()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Context.html#a2eab7e7c71335654a6a1381030617966" title="Initialize the context, and the underlying elements like the rcl context.">rclcpp::Context::init()</a> for more details on arguments and possible <a class="el" href="namespacerclcpp_1_1exceptions.html">exceptions</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>number of command-line arguments to parse. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>array of command-line arguments to parse. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_options</td><td>initialization options to apply. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signal_handler_options</td><td>option to indicate which signal handlers should be installed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90fb3d8fb164d5955bfbf1b8174d4048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90fb3d8fb164d5955bfbf1b8174d4048">&#9670;&nbsp;</a></span>install_signal_handlers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::install_signal_handlers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerclcpp.html#a14a5d1b5fa11030e4141fd79e36cf2fd">SignalHandlerOptions</a>&#160;</td>
          <td class="paramname"><em>signal_handler_options</em> = <code><a class="el" href="namespacerclcpp.html#a14a5d1b5fa11030e4141fd79e36cf2fdab1c94ca2fbc3e78fc30069c8d0f01680">SignalHandlerOptions::All</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install the global signal handler for rclcpp. </p>
<p>This function should only need to be run one time per process. It is implicitly run by <a class="el" href="namespacerclcpp.html#a026b2ac505c383735117de5d1679ed80" title="Initialize communications via the rmw implementation and set up a global signal handler.">rclcpp::init()</a>, and therefore this function does not need to be run manually if <a class="el" href="namespacerclcpp.html#a026b2ac505c383735117de5d1679ed80" title="Initialize communications via the rmw implementation and set up a global signal handler.">rclcpp::init()</a> has already been run.</p>
<p>The signal handler will shutdown all initialized context. It will also interrupt any blocking functions in ROS allowing them react to any changes in the state of the system (like shutdown).</p>
<p>This function is thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">signal_handler_options</td><td>option to indicate which signal handlers should be installed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if signal handler was installed by this function, false if already installed. </dd></dl>

</div>
</div>
<a id="a3944023ee7719c1b3eab2a1cd4e0f3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3944023ee7719c1b3eab2a1cd4e0f3f3">&#9670;&nbsp;</a></span>signal_handlers_installed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::signal_handlers_installed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the signal handlers are installed, otherwise false. </p>

</div>
</div>
<a id="acbcabc619a77b7ca42e06c50a45b9cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbcabc619a77b7ca42e06c50a45b9cba">&#9670;&nbsp;</a></span>get_current_signal_handler_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerclcpp.html#a14a5d1b5fa11030e4141fd79e36cf2fd">SignalHandlerOptions</a> rclcpp::get_current_signal_handler_options </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current signal handler options. </p>
<p>If no signal handler is installed, <a class="el" href="namespacerclcpp.html#a14a5d1b5fa11030e4141fd79e36cf2fda6adf97f83acf6453d4a6a4b1070f3754" title="Do not install any signal handler.">SignalHandlerOptions::None</a> is returned. </p>

</div>
</div>
<a id="ad74690adaed20915f98b36c0e93d3231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74690adaed20915f98b36c0e93d3231">&#9670;&nbsp;</a></span>uninstall_signal_handlers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::uninstall_signal_handlers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uninstall the global signal handler for rclcpp. </p>
<p>This function does not necessarily need to be called, but can be used to undo what <a class="el" href="namespacerclcpp.html#a90fb3d8fb164d5955bfbf1b8174d4048" title="Install the global signal handler for rclcpp.">rclcpp::install_signal_handlers()</a> or <a class="el" href="namespacerclcpp.html#a026b2ac505c383735117de5d1679ed80" title="Initialize communications via the rmw implementation and set up a global signal handler.">rclcpp::init()</a> do with respect to signal handling. If you choose to use it, this function only needs to be run one time. It is implicitly run by <a class="el" href="namespacerclcpp.html#a493714a679d1591142800416a286689f" title="Shutdown rclcpp context, invalidating it for derived entities.">rclcpp::shutdown()</a>, and therefore this function does not need to be run manually if <a class="el" href="namespacerclcpp.html#a493714a679d1591142800416a286689f" title="Shutdown rclcpp context, invalidating it for derived entities.">rclcpp::shutdown()</a> has already been run.</p>
<p>This function is thread-safe.</p>
<dl class="section return"><dt>Returns</dt><dd>true if signal handler was uninstalled by this function, false if was not installed. </dd></dl>

</div>
</div>
<a id="a54c8d8abf67984be09c65440187a6576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c8d8abf67984be09c65440187a6576">&#9670;&nbsp;</a></span>init_and_remove_ros_arguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; rclcpp::init_and_remove_ros_arguments </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const *&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1InitOptions.html">InitOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>init_options</em> = <code><a class="el" href="classrclcpp_1_1InitOptions.html">InitOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize communications via the rmw implementation and set up a global signal handler. </p>
<p>Additionally removes ROS-specific arguments from the argument vector.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Context.html#a2eab7e7c71335654a6a1381030617966" title="Initialize the context, and the underlying elements like the rcl context.">rclcpp::Context::init()</a> for more details on arguments and possible <a class="el" href="namespacerclcpp_1_1exceptions.html">exceptions</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Members of the argument vector that are not ROS arguments. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">anything</td><td>remove_ros_arguments can throw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab947f4199c93ecdf89c5eca4f7bda77c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab947f4199c93ecdf89c5eca4f7bda77c">&#9670;&nbsp;</a></span>remove_ros_arguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; rclcpp::remove_ros_arguments </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const *&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove ROS-specific arguments from argument vector. </p>
<p>Some arguments may not have been intended as ROS arguments. This function populates the arguments in a vector. Since the first argument is always assumed to be a process name, the vector will always contain the process name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>Number of arguments. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>Argument vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Members of the argument vector that are not ROS arguments. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">anything</td><td>throw_from_rcl_error can throw </td></tr>
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1exceptions_1_1RCLError.html" title="Created when the return code does not match one of the other specialized exceptions.">rclcpp::exceptions::RCLError</a></td><td>if the parsing fails </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbe8ffd2b1769e897f2c50d560812b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe8ffd2b1769e897f2c50d560812b43">&#9670;&nbsp;</a></span>ok()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::ok </td>
          <td>(</td>
          <td class="paramtype">rclcpp::Context::SharedPtr&#160;</td>
          <td class="paramname"><em>context</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check rclcpp's status. </p>
<p>This may return false for a context which has been shutdown, or for a context that was shutdown due to SIGINT being received by the rclcpp signal handler.</p>
<p>If nullptr is given for the context, then the global context is used, i.e. the context initialized by <a class="el" href="namespacerclcpp.html#a026b2ac505c383735117de5d1679ed80" title="Initialize communications via the rmw implementation and set up a global signal handler.">rclcpp::init()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Optional check for shutdown of this <a class="el" href="classrclcpp_1_1Context.html" title="Context which encapsulates shared state between nodes and other similar entities.">Context</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if shutdown has been called, false otherwise </dd></dl>

</div>
</div>
<a id="a493714a679d1591142800416a286689f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493714a679d1591142800416a286689f">&#9670;&nbsp;</a></span>shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::shutdown </td>
          <td>(</td>
          <td class="paramtype">rclcpp::Context::SharedPtr&#160;</td>
          <td class="paramname"><em>context</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reason</em> = <code>&quot;user&#160;called&#160;rclcpp::shutdown()&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shutdown rclcpp context, invalidating it for derived entities. </p>
<p>If nullptr is given for the context, then the global context is used, i.e. the context initialized by <a class="el" href="namespacerclcpp.html#a026b2ac505c383735117de5d1679ed80" title="Initialize communications via the rmw implementation and set up a global signal handler.">rclcpp::init()</a>.</p>
<p>If the global context is used, then the signal handlers are also uninstalled.</p>
<p>This will also cause the "on_shutdown" callbacks to be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Context.html#ac51bf15d106aa246001a4fdc15be7b2a" title="Shutdown the context, making it uninitialized and therefore invalid for derived entities.">rclcpp::Context::shutdown()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Optional to be shutdown </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reason</td><td>Optional string passed to the context shutdown method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if shutdown was successful, false if context was already shutdown </dd></dl>

</div>
</div>
<a id="a01e2c223964ccca7ede393af47fac025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e2c223964ccca7ede393af47fac025">&#9670;&nbsp;</a></span>on_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::on_shutdown </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rclcpp::Context::SharedPtr&#160;</td>
          <td class="paramname"><em>context</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a function to be called when shutdown is called on the context. </p>
<p>If nullptr is given for the context, then the global context is used, i.e. the context initialized by <a class="el" href="namespacerclcpp.html#a026b2ac505c383735117de5d1679ed80" title="Initialize communications via the rmw implementation and set up a global signal handler.">rclcpp::init()</a>.</p>
<p>These callbacks are called when the associated <a class="el" href="classrclcpp_1_1Context.html" title="Context which encapsulates shared state between nodes and other similar entities.">Context</a> is shutdown with the <a class="el" href="classrclcpp_1_1Context.html#ac51bf15d106aa246001a4fdc15be7b2a" title="Shutdown the context, making it uninitialized and therefore invalid for derived entities.">Context::shutdown()</a> method. When shutdown by the SIGINT handler, shutdown, and therefore these callbacks, is called asynchronously from the dedicated signal handling thread, at some point after the SIGINT signal is received.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Context.html#a0d731d83e73a5b368c9f5bee1d2d4cb2" title="Add a on_shutdown callback to be called when shutdown is called for this context.">rclcpp::Context::on_shutdown()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>to be called when the given context is shutdown </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>with which to associate the context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac305329e4e97948d4bb216e894caa4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac305329e4e97948d4bb216e894caa4ae">&#9670;&nbsp;</a></span>sleep_for()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::sleep_for </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::nanoseconds &amp;&#160;</td>
          <td class="paramname"><em>nanoseconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rclcpp::Context::SharedPtr&#160;</td>
          <td class="paramname"><em>context</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the global condition variable to block for the specified amount of time. </p>
<p>This function can be interrupted early if the associated context becomes invalid due to <a class="el" href="namespacerclcpp.html#a493714a679d1591142800416a286689f" title="Shutdown rclcpp context, invalidating it for derived entities.">shutdown()</a> or the signal handler. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Context.html#adf25fc22a74daf5ce85f6bdde3b92aa2" title="Sleep for a given period of time or until shutdown() is called.">rclcpp::Context::sleep_for</a></dd></dl>
<p>If nullptr is given for the context, then the global context is used, i.e. the context initialized by <a class="el" href="namespacerclcpp.html#a026b2ac505c383735117de5d1679ed80" title="Initialize communications via the rmw implementation and set up a global signal handler.">rclcpp::init()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nanoseconds</td><td>A std::chrono::duration representing how long to sleep for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Optional which may interrupt this sleep </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the condition variable did not timeout. </dd></dl>

</div>
</div>
<a id="af238f376176cf3da48adc46b94d29a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af238f376176cf3da48adc46b94d29a6a">&#9670;&nbsp;</a></span>add_will_overflow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::add_will_overflow </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safely check if addition will overflow. </p>
<p>The type of the operands, T, should have defined std::numeric_limits&lt;T&gt;::max(), <code>&gt;</code>, <code>&lt;</code> and <code>-</code> operators.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>is the first addend. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>is the second addend. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is type of the operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the x + y sum is greater than T::max value. </dd></dl>

</div>
</div>
<a id="a26f62ce86fabd324005231d8d89a8294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f62ce86fabd324005231d8d89a8294">&#9670;&nbsp;</a></span>add_will_underflow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::add_will_underflow </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safely check if addition will underflow. </p>
<p>The type of the operands, T, should have defined std::numeric_limits&lt;T&gt;::min(), <code>&gt;</code>, <code>&lt;</code> and <code>-</code> operators.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>is the first addend. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>is the second addend. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is type of the operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the x + y sum is less than T::min value. </dd></dl>

</div>
</div>
<a id="aa7c63f4d5146a9054f3b2d8b9ac2070f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c63f4d5146a9054f3b2d8b9ac2070f">&#9670;&nbsp;</a></span>sub_will_overflow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::sub_will_overflow </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safely check if subtraction will overflow. </p>
<p>The type of the operands, T, should have defined std::numeric_limits&lt;T&gt;::max(), <code>&gt;</code>, <code>&lt;</code> and <code>+</code> operators.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>is the minuend. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>is the subtrahend. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is type of the operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the difference <code>x - y</code> sum is grater than T::max value. </dd></dl>

</div>
</div>
<a id="af340ddf3a7b82a7a5a4808740a039e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af340ddf3a7b82a7a5a4808740a039e69">&#9670;&nbsp;</a></span>sub_will_underflow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::sub_will_underflow </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safely check if subtraction will underflow. </p>
<p>The type of the operands, T, should have defined std::numeric_limits&lt;T&gt;::min(), <code>&gt;</code>, <code>&lt;</code> and <code>+</code> operators.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>is the minuend. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>is the subtrahend. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is type of the operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the difference <code>x - y</code> sum is less than T::min value. </dd></dl>

</div>
</div>
<a id="a1fdf023cdc167cb3d4d353353cd4cced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fdf023cdc167cb3d4d353353cd4cced">&#9670;&nbsp;</a></span>get_c_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rclcpp::get_c_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the given string. </p>
<p>This function is overloaded to transform any string to C-style string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string_in</td><td>is the string to be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given string </dd></dl>

</div>
</div>
<a id="a7743e6192ef035115abdeeb90227c45c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7743e6192ef035115abdeeb90227c45c">&#9670;&nbsp;</a></span>get_c_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rclcpp::get_c_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>string_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the C string from the given std::string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string_in</td><td>is a std::string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the C string from the std::string </dd></dl>

</div>
</div>
<a id="a6eb4fa6ca00ef75ef9e5647990915fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb4fa6ca00ef75ef9e5647990915fcd">&#9670;&nbsp;</a></span>get_c_vector_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;const char *&gt; rclcpp::get_c_vector_string </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>strings_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the std::vector of C string from the given std::vector&lt;std::string&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">strings_in</td><td>is a std::vector of std::string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the std::vector of C string from the std::vector&lt;std::string&gt; </dd></dl>

</div>
</div>
<a id="a257a1c91269fde91781c115dd2503ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257a1c91269fde91781c115dd2503ce5">&#9670;&nbsp;</a></span>wait_for_message() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MsgT , class Rep  = int64_t, class Period  = std::milli&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::wait_for_message </td>
          <td>(</td>
          <td class="paramtype">MsgT &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1Subscription.html">rclcpp::Subscription</a>&lt; MsgT &gt;&gt;&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1Context.html">rclcpp::Context</a> &gt;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt;&#160;</td>
          <td class="paramname"><em>time_to_wait</em> = <code>std::chrono::duration&lt;Rep,&#160;Period&gt;(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the next incoming message. </p>
<p>Given an already initialized subscription, wait for the next incoming message to arrive before the specified timeout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>is the message to be filled when a new message is arriving. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>shared pointer to a previously initialized subscription. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>shared pointer to a context to watch for SIGINT requests. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_to_wait</td><td>parameter specifying the timeout before returning. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a message was successfully received, false if message could not be obtained or shutdown was triggered asynchronously on the context. </dd></dl>

</div>
</div>
<a id="af3333ef9ec680d55315afc21ef754f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3333ef9ec680d55315afc21ef754f7b">&#9670;&nbsp;</a></span>wait_for_message() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MsgT , class Rep  = int64_t, class Period  = std::milli&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::wait_for_message </td>
          <td>(</td>
          <td class="paramtype">MsgT &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rclcpp::Node::SharedPtr&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt;&#160;</td>
          <td class="paramname"><em>time_to_wait</em> = <code>std::chrono::duration&lt;Rep,&#160;Period&gt;(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the next incoming message. </p>
<p>Wait for the next incoming message to arrive on a specified topic before the specified timeout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>is the message to be filled when a new message is arriving. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>the node pointer to initialize the subscription on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topic</td><td>the topic to wait for messages. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_to_wait</td><td>parameter specifying the timeout before returning. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a message was successfully received, false if message could not be obtained or shutdown was triggered asynchronously on the context. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
