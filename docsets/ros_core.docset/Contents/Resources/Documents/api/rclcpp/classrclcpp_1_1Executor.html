<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rclcpp: rclcpp::Executor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rclcpp
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C++ ROS Client Library API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerclcpp.html">rclcpp</a></li><li class="navelem"><a class="el" href="classrclcpp_1_1Executor.html">Executor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classrclcpp_1_1Executor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rclcpp::Executor Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Coordinate the order and timing of available communication tasks.  
 <a href="classrclcpp_1_1Executor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="executor_8hpp_source.html">executor.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rclcpp::Executor:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1Executor__inherit__graph.png" border="0" usemap="#arclcpp_1_1Executor_inherit__map" alt="Inheritance graph"/></div>
<map name="arclcpp_1_1Executor_inherit__map" id="arclcpp_1_1Executor_inherit__map">
<area shape="rect" title="Coordinate the order and timing of available communication tasks." alt="" coords="5,78,131,105"/>
<area shape="rect" href="classrclcpp_1_1executors_1_1MultiThreadedExecutor.html" title=" " alt="" coords="201,5,373,47"/>
<area shape="rect" href="classrclcpp_1_1executors_1_1SingleThreadedExecutor.html" title="Single&#45;threaded executor implementation." alt="" coords="197,71,376,112"/>
<area shape="rect" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html" title="Static executor implementation." alt="" coords="179,136,395,177"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for rclcpp::Executor:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1Executor__coll__graph.png" border="0" usemap="#arclcpp_1_1Executor_coll__map" alt="Collaboration graph"/></div>
<map name="arclcpp_1_1Executor_coll__map" id="arclcpp_1_1Executor_coll__map">
<area shape="rect" title="Coordinate the order and timing of available communication tasks." alt="" coords="132,109,257,136"/>
<area shape="rect" href="classrclcpp_1_1GuardCondition.html" title="A condition that can be waited on in a single wait set and asynchronously triggered." alt="" coords="5,13,176,39"/>
<area shape="rect" href="classrclcpp_1_1ShutdownCallbackHandle.html" title=" " alt="" coords="205,5,395,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3d28d13a7233751c9b7b023528f10228"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a3d28d13a7233751c9b7b023528f10228">Executor</a> (const <a class="el" href="structrclcpp_1_1ExecutorOptions.html">rclcpp::ExecutorOptions</a> &amp;options=<a class="el" href="structrclcpp_1_1ExecutorOptions.html">rclcpp::ExecutorOptions</a>())</td></tr>
<tr class="memdesc:a3d28d13a7233751c9b7b023528f10228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classrclcpp_1_1Executor.html#a3d28d13a7233751c9b7b023528f10228">More...</a><br /></td></tr>
<tr class="separator:a3d28d13a7233751c9b7b023528f10228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946f5bfe58cb0ee5f52a98455248ed66"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a946f5bfe58cb0ee5f52a98455248ed66">~Executor</a> ()</td></tr>
<tr class="memdesc:a946f5bfe58cb0ee5f52a98455248ed66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="classrclcpp_1_1Executor.html#a946f5bfe58cb0ee5f52a98455248ed66">More...</a><br /></td></tr>
<tr class="separator:a946f5bfe58cb0ee5f52a98455248ed66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad096fec6846af2169ee97cd2d23e96ca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ad096fec6846af2169ee97cd2d23e96ca">spin</a> ()=0</td></tr>
<tr class="memdesc:ad096fec6846af2169ee97cd2d23e96ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do work periodically as it becomes available to us. Blocking call, may block indefinitely.  <a href="classrclcpp_1_1Executor.html#ad096fec6846af2169ee97cd2d23e96ca">More...</a><br /></td></tr>
<tr class="separator:ad096fec6846af2169ee97cd2d23e96ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb97eed174e54946d42ea83cf72a5a9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a6bb97eed174e54946d42ea83cf72a5a9">add_callback_group</a> (rclcpp::CallbackGroup::SharedPtr group_ptr, rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr, bool notify=true)</td></tr>
<tr class="memdesc:a6bb97eed174e54946d42ea83cf72a5a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a callback group to an executor.  <a href="classrclcpp_1_1Executor.html#a6bb97eed174e54946d42ea83cf72a5a9">More...</a><br /></td></tr>
<tr class="separator:a6bb97eed174e54946d42ea83cf72a5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37926d32654ae54f95bd6676005901c"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; rclcpp::CallbackGroup::WeakPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#aa37926d32654ae54f95bd6676005901c">get_all_callback_groups</a> ()</td></tr>
<tr class="memdesc:aa37926d32654ae54f95bd6676005901c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get callback groups that belong to executor.  <a href="classrclcpp_1_1Executor.html#aa37926d32654ae54f95bd6676005901c">More...</a><br /></td></tr>
<tr class="separator:aa37926d32654ae54f95bd6676005901c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6718d2978792d55091e0e97f136e21ba"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; rclcpp::CallbackGroup::WeakPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a6718d2978792d55091e0e97f136e21ba">get_manually_added_callback_groups</a> ()</td></tr>
<tr class="memdesc:a6718d2978792d55091e0e97f136e21ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get callback groups that belong to executor.  <a href="classrclcpp_1_1Executor.html#a6718d2978792d55091e0e97f136e21ba">More...</a><br /></td></tr>
<tr class="separator:a6718d2978792d55091e0e97f136e21ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156eeccc922f93d044efc8ce1b55b5cc"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; rclcpp::CallbackGroup::WeakPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a156eeccc922f93d044efc8ce1b55b5cc">get_automatically_added_callback_groups_from_nodes</a> ()</td></tr>
<tr class="memdesc:a156eeccc922f93d044efc8ce1b55b5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get callback groups that belong to executor.  <a href="classrclcpp_1_1Executor.html#a156eeccc922f93d044efc8ce1b55b5cc">More...</a><br /></td></tr>
<tr class="separator:a156eeccc922f93d044efc8ce1b55b5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a5c14786aee651ce0f7d5f1bfd098f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a84a5c14786aee651ce0f7d5f1bfd098f">remove_callback_group</a> (rclcpp::CallbackGroup::SharedPtr group_ptr, bool notify=true)</td></tr>
<tr class="memdesc:a84a5c14786aee651ce0f7d5f1bfd098f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a callback group from the executor.  <a href="classrclcpp_1_1Executor.html#a84a5c14786aee651ce0f7d5f1bfd098f">More...</a><br /></td></tr>
<tr class="separator:a84a5c14786aee651ce0f7d5f1bfd098f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f9649e4c2f3593c930f4d191e7e208"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a53f9649e4c2f3593c930f4d191e7e208">add_node</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr, bool notify=true)</td></tr>
<tr class="memdesc:a53f9649e4c2f3593c930f4d191e7e208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node to the executor.  <a href="classrclcpp_1_1Executor.html#a53f9649e4c2f3593c930f4d191e7e208">More...</a><br /></td></tr>
<tr class="separator:a53f9649e4c2f3593c930f4d191e7e208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a2b87b3a60d3fd8525d18879cec14c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a83a2b87b3a60d3fd8525d18879cec14c">add_node</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1Node.html">rclcpp::Node</a> &gt; node_ptr, bool notify=true)</td></tr>
<tr class="memdesc:a83a2b87b3a60d3fd8525d18879cec14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface.  <a href="classrclcpp_1_1Executor.html#a83a2b87b3a60d3fd8525d18879cec14c">More...</a><br /></td></tr>
<tr class="separator:a83a2b87b3a60d3fd8525d18879cec14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660424725a58fc412fac8e86191b1f61"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a660424725a58fc412fac8e86191b1f61">remove_node</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr, bool notify=true)</td></tr>
<tr class="memdesc:a660424725a58fc412fac8e86191b1f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a node from the executor.  <a href="classrclcpp_1_1Executor.html#a660424725a58fc412fac8e86191b1f61">More...</a><br /></td></tr>
<tr class="separator:a660424725a58fc412fac8e86191b1f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0543bf6a85ae11a042cef13077ab364"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ae0543bf6a85ae11a042cef13077ab364">remove_node</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1Node.html">rclcpp::Node</a> &gt; node_ptr, bool notify=true)</td></tr>
<tr class="memdesc:ae0543bf6a85ae11a042cef13077ab364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface.  <a href="classrclcpp_1_1Executor.html#ae0543bf6a85ae11a042cef13077ab364">More...</a><br /></td></tr>
<tr class="separator:ae0543bf6a85ae11a042cef13077ab364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09dd5b81cc174fd7029fab65a726db9"><td class="memTemplParams" colspan="2">template&lt;typename RepT  = int64_t, typename T  = std::milli&gt; </td></tr>
<tr class="memitem:af09dd5b81cc174fd7029fab65a726db9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#af09dd5b81cc174fd7029fab65a726db9">spin_node_once</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node, std::chrono::duration&lt; RepT, T &gt; timeout=std::chrono::duration&lt; RepT, T &gt;(-1))</td></tr>
<tr class="memdesc:af09dd5b81cc174fd7029fab65a726db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node to executor, execute the next available unit of work, and remove the node.  <a href="classrclcpp_1_1Executor.html#af09dd5b81cc174fd7029fab65a726db9">More...</a><br /></td></tr>
<tr class="separator:af09dd5b81cc174fd7029fab65a726db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9791fd5812f06add439c9cca86d6226b"><td class="memTemplParams" colspan="2">template&lt;typename NodeT  = rclcpp::Node, typename RepT  = int64_t, typename T  = std::milli&gt; </td></tr>
<tr class="memitem:a9791fd5812f06add439c9cca86d6226b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a9791fd5812f06add439c9cca86d6226b">spin_node_once</a> (std::shared_ptr&lt; NodeT &gt; node, std::chrono::duration&lt; RepT, T &gt; timeout=std::chrono::duration&lt; RepT, T &gt;(-1))</td></tr>
<tr class="memdesc:a9791fd5812f06add439c9cca86d6226b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface.  <a href="classrclcpp_1_1Executor.html#a9791fd5812f06add439c9cca86d6226b">More...</a><br /></td></tr>
<tr class="separator:a9791fd5812f06add439c9cca86d6226b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49780b2217485638b0d7be720062e630"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a49780b2217485638b0d7be720062e630">spin_node_some</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node)</td></tr>
<tr class="memdesc:a49780b2217485638b0d7be720062e630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node, complete all immediately available work, and remove the node.  <a href="classrclcpp_1_1Executor.html#a49780b2217485638b0d7be720062e630">More...</a><br /></td></tr>
<tr class="separator:a49780b2217485638b0d7be720062e630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8f89d67464b75cfc63f1ddf56f8850"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a9c8f89d67464b75cfc63f1ddf56f8850">spin_node_some</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1Node.html">rclcpp::Node</a> &gt; node)</td></tr>
<tr class="memdesc:a9c8f89d67464b75cfc63f1ddf56f8850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface.  <a href="classrclcpp_1_1Executor.html#a9c8f89d67464b75cfc63f1ddf56f8850">More...</a><br /></td></tr>
<tr class="separator:a9c8f89d67464b75cfc63f1ddf56f8850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae821cd4cf1040fe2da521fb19a458fa1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ae821cd4cf1040fe2da521fb19a458fa1">spin_some</a> (std::chrono::nanoseconds max_duration=std::chrono::nanoseconds(0))</td></tr>
<tr class="memdesc:ae821cd4cf1040fe2da521fb19a458fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect work once and execute all available work, optionally within a duration.  <a href="classrclcpp_1_1Executor.html#ae821cd4cf1040fe2da521fb19a458fa1">More...</a><br /></td></tr>
<tr class="separator:ae821cd4cf1040fe2da521fb19a458fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e13b528a3f94a5d54ff139ec1f4a7cc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a5e13b528a3f94a5d54ff139ec1f4a7cc">spin_all</a> (std::chrono::nanoseconds max_duration)</td></tr>
<tr class="memdesc:a5e13b528a3f94a5d54ff139ec1f4a7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect and execute work repeatedly within a duration or until no more work is available.  <a href="classrclcpp_1_1Executor.html#a5e13b528a3f94a5d54ff139ec1f4a7cc">More...</a><br /></td></tr>
<tr class="separator:a5e13b528a3f94a5d54ff139ec1f4a7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4abb57eea7e1b6c95acc0e7abff62b2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ae4abb57eea7e1b6c95acc0e7abff62b2">spin_once</a> (std::chrono::nanoseconds timeout=std::chrono::nanoseconds(-1))</td></tr>
<tr class="separator:ae4abb57eea7e1b6c95acc0e7abff62b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a0c374568aae53dcca63eb29086327"><td class="memTemplParams" colspan="2">template&lt;typename FutureT , typename TimeRepT  = int64_t, typename TimeT  = std::milli&gt; </td></tr>
<tr class="memitem:a39a0c374568aae53dcca63eb29086327"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacerclcpp.html#a7b4ff5f1e516740d7e11ea97fe6f5532">FutureReturnCode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a39a0c374568aae53dcca63eb29086327">spin_until_future_complete</a> (const FutureT &amp;future, std::chrono::duration&lt; TimeRepT, TimeT &gt; timeout=std::chrono::duration&lt; TimeRepT, TimeT &gt;(-1))</td></tr>
<tr class="memdesc:a39a0c374568aae53dcca63eb29086327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spin (blocking) until the future is complete, it times out waiting, or rclcpp is interrupted.  <a href="classrclcpp_1_1Executor.html#a39a0c374568aae53dcca63eb29086327">More...</a><br /></td></tr>
<tr class="separator:a39a0c374568aae53dcca63eb29086327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb21996107bcf4e62f8330e8d201e70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a0fb21996107bcf4e62f8330e8d201e70">cancel</a> ()</td></tr>
<tr class="memdesc:a0fb21996107bcf4e62f8330e8d201e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel any running spin* function, causing it to return.  <a href="classrclcpp_1_1Executor.html#a0fb21996107bcf4e62f8330e8d201e70">More...</a><br /></td></tr>
<tr class="separator:a0fb21996107bcf4e62f8330e8d201e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41ca2b0358c875337ac13a8130987e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#aa41ca2b0358c875337ac13a8130987e9">set_memory_strategy</a> (memory_strategy::MemoryStrategy::SharedPtr memory_strategy)</td></tr>
<tr class="memdesc:aa41ca2b0358c875337ac13a8130987e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support dynamic switching of the memory strategy.  <a href="classrclcpp_1_1Executor.html#aa41ca2b0358c875337ac13a8130987e9">More...</a><br /></td></tr>
<tr class="separator:aa41ca2b0358c875337ac13a8130987e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476430345b9c7f2820290f272d2ef78f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a476430345b9c7f2820290f272d2ef78f">is_spinning</a> ()</td></tr>
<tr class="memdesc:a476430345b9c7f2820290f272d2ef78f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the executor is currently spinning.  <a href="classrclcpp_1_1Executor.html#a476430345b9c7f2820290f272d2ef78f">More...</a><br /></td></tr>
<tr class="separator:a476430345b9c7f2820290f272d2ef78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a3580d9e86d9ebb7e674e4270d485bef6"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; rclcpp::CallbackGroup::WeakPtr, const <a class="el" href="classrclcpp_1_1GuardCondition.html">rclcpp::GuardCondition</a> *, std::owner_less&lt; rclcpp::CallbackGroup::WeakPtr &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a3580d9e86d9ebb7e674e4270d485bef6">WeakCallbackGroupsToGuardConditionsMap</a></td></tr>
<tr class="separator:a3580d9e86d9ebb7e674e4270d485bef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a562cd027f960258673a737c9e8d3be75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a562cd027f960258673a737c9e8d3be75">spin_node_once_nanoseconds</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node, std::chrono::nanoseconds timeout)</td></tr>
<tr class="separator:a562cd027f960258673a737c9e8d3be75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdf3b5fb2a673346f45feed75a7cd11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a4cdf3b5fb2a673346f45feed75a7cd11">spin_some_impl</a> (std::chrono::nanoseconds max_duration, bool exhaustive)</td></tr>
<tr class="separator:a4cdf3b5fb2a673346f45feed75a7cd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915f4738cf48d6c08851be8264aad58d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a915f4738cf48d6c08851be8264aad58d">execute_any_executable</a> (<a class="el" href="structrclcpp_1_1AnyExecutable.html">AnyExecutable</a> &amp;any_exec)</td></tr>
<tr class="memdesc:a915f4738cf48d6c08851be8264aad58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the next available executable and do the work associated with it.  <a href="classrclcpp_1_1Executor.html#a915f4738cf48d6c08851be8264aad58d">More...</a><br /></td></tr>
<tr class="separator:a915f4738cf48d6c08851be8264aad58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af211465e15ae5b13bac0893ef9e0ed4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#af211465e15ae5b13bac0893ef9e0ed4e">wait_for_work</a> (std::chrono::nanoseconds timeout=std::chrono::nanoseconds(-1))</td></tr>
<tr class="separator:af211465e15ae5b13bac0893ef9e0ed4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4878997d1aba3efea583f307a22faa5"><td class="memItemLeft" align="right" valign="top">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#aa4878997d1aba3efea583f307a22faa5">get_node_by_group</a> (const <a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a> &amp;weak_groups_to_nodes, rclcpp::CallbackGroup::SharedPtr group)</td></tr>
<tr class="separator:aa4878997d1aba3efea583f307a22faa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552c54e50b71e3432366e15ef0536fef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a552c54e50b71e3432366e15ef0536fef">has_node</a> (const rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr, const <a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a> &amp;weak_groups_to_nodes) const</td></tr>
<tr class="memdesc:a552c54e50b71e3432366e15ef0536fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the node has been added to this executor.  <a href="classrclcpp_1_1Executor.html#a552c54e50b71e3432366e15ef0536fef">More...</a><br /></td></tr>
<tr class="separator:a552c54e50b71e3432366e15ef0536fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06baded5884fc91e6d36ab676f0b7fc3"><td class="memItemLeft" align="right" valign="top">rclcpp::CallbackGroup::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a06baded5884fc91e6d36ab676f0b7fc3">get_group_by_timer</a> (rclcpp::TimerBase::SharedPtr timer)</td></tr>
<tr class="separator:a06baded5884fc91e6d36ab676f0b7fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e030d927aa29b42d44f9c51a5335325"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a2e030d927aa29b42d44f9c51a5335325">add_callback_group_to_map</a> (rclcpp::CallbackGroup::SharedPtr group_ptr, rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr, <a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a> &amp;weak_groups_to_nodes, bool notify=true)</td></tr>
<tr class="memdesc:a2e030d927aa29b42d44f9c51a5335325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a callback group to an executor.  <a href="classrclcpp_1_1Executor.html#a2e030d927aa29b42d44f9c51a5335325">More...</a><br /></td></tr>
<tr class="separator:a2e030d927aa29b42d44f9c51a5335325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da65b29b968aa503df2df3eef091185"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a9da65b29b968aa503df2df3eef091185">remove_callback_group_from_map</a> (rclcpp::CallbackGroup::SharedPtr group_ptr, <a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a> &amp;weak_groups_to_nodes, bool notify=true)</td></tr>
<tr class="memdesc:a9da65b29b968aa503df2df3eef091185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a callback group from the executor.  <a href="classrclcpp_1_1Executor.html#a9da65b29b968aa503df2df3eef091185">More...</a><br /></td></tr>
<tr class="separator:a9da65b29b968aa503df2df3eef091185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3c92aec4730186388701398c84263b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#aad3c92aec4730186388701398c84263b">get_next_ready_executable</a> (<a class="el" href="structrclcpp_1_1AnyExecutable.html">AnyExecutable</a> &amp;any_executable)</td></tr>
<tr class="separator:aad3c92aec4730186388701398c84263b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e9721d4751ca0bd2b0faa1c9403255"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a36e9721d4751ca0bd2b0faa1c9403255">get_next_ready_executable_from_map</a> (<a class="el" href="structrclcpp_1_1AnyExecutable.html">AnyExecutable</a> &amp;any_executable, const <a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a> &amp;weak_groups_to_nodes)</td></tr>
<tr class="separator:a36e9721d4751ca0bd2b0faa1c9403255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b530d7459b579ca22044a5e7a37a50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a63b530d7459b579ca22044a5e7a37a50">get_next_executable</a> (<a class="el" href="structrclcpp_1_1AnyExecutable.html">AnyExecutable</a> &amp;any_executable, std::chrono::nanoseconds timeout=std::chrono::nanoseconds(-1))</td></tr>
<tr class="separator:a63b530d7459b579ca22044a5e7a37a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045379e6904e18e4bb3ff9f1aa039d46"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a045379e6904e18e4bb3ff9f1aa039d46">add_callback_groups_from_nodes_associated_to_executor</a> ()</td></tr>
<tr class="memdesc:a045379e6904e18e4bb3ff9f1aa039d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all callback groups that can be automatically added from associated nodes.  <a href="classrclcpp_1_1Executor.html#a045379e6904e18e4bb3ff9f1aa039d46">More...</a><br /></td></tr>
<tr class="separator:a045379e6904e18e4bb3ff9f1aa039d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcce1959f54430db201b5800ff9f61a6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#afcce1959f54430db201b5800ff9f61a6">spin_once_impl</a> (std::chrono::nanoseconds timeout)</td></tr>
<tr class="separator:afcce1959f54430db201b5800ff9f61a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a3f825d7a6d22eb8a6c2974d89d8bcebc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a3f825d7a6d22eb8a6c2974d89d8bcebc">execute_subscription</a> (rclcpp::SubscriptionBase::SharedPtr subscription)</td></tr>
<tr class="separator:a3f825d7a6d22eb8a6c2974d89d8bcebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e62a3a7c60ab1569659aeaa47886b7e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a6e62a3a7c60ab1569659aeaa47886b7e">execute_timer</a> (rclcpp::TimerBase::SharedPtr timer)</td></tr>
<tr class="separator:a6e62a3a7c60ab1569659aeaa47886b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2e10441f4ad3c566c84f44e8d697d8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a8c2e10441f4ad3c566c84f44e8d697d8">execute_service</a> (rclcpp::ServiceBase::SharedPtr service)</td></tr>
<tr class="separator:a8c2e10441f4ad3c566c84f44e8d697d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488790ad5eccaf4a7dc2b6eab6862147"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a488790ad5eccaf4a7dc2b6eab6862147">execute_client</a> (rclcpp::ClientBase::SharedPtr client)</td></tr>
<tr class="separator:a488790ad5eccaf4a7dc2b6eab6862147"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:afe759d8451caa0752e2209bb0863dbcd"><td class="memItemLeft" align="right" valign="top">std::atomic_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#afe759d8451caa0752e2209bb0863dbcd">spinning</a></td></tr>
<tr class="memdesc:afe759d8451caa0752e2209bb0863dbcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spinning state, used to prevent multi threaded calls to spin and to cancel blocking spins.  <a href="classrclcpp_1_1Executor.html#afe759d8451caa0752e2209bb0863dbcd">More...</a><br /></td></tr>
<tr class="separator:afe759d8451caa0752e2209bb0863dbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab940062f9fdfe52fc4d6f6b9948951a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1GuardCondition.html">rclcpp::GuardCondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ab940062f9fdfe52fc4d6f6b9948951a4">interrupt_guard_condition_</a></td></tr>
<tr class="memdesc:ab940062f9fdfe52fc4d6f6b9948951a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guard condition for signaling the rmw layer to wake up for special events.  <a href="classrclcpp_1_1Executor.html#ab940062f9fdfe52fc4d6f6b9948951a4">More...</a><br /></td></tr>
<tr class="separator:ab940062f9fdfe52fc4d6f6b9948951a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7ffa426ec1e9629d6744cd06b95d1e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1GuardCondition.html">rclcpp::GuardCondition</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#afc7ffa426ec1e9629d6744cd06b95d1e">shutdown_guard_condition_</a></td></tr>
<tr class="separator:afc7ffa426ec1e9629d6744cd06b95d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bb6ff536c37f44a5c05f3ba5c300ee"><td class="memItemLeft" align="right" valign="top">rcl_wait_set_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a07bb6ff536c37f44a5c05f3ba5c300ee">wait_set_</a> = rcl_get_zero_initialized_wait_set()</td></tr>
<tr class="memdesc:a07bb6ff536c37f44a5c05f3ba5c300ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait set for managing entities that the rmw layer waits on.  <a href="classrclcpp_1_1Executor.html#a07bb6ff536c37f44a5c05f3ba5c300ee">More...</a><br /></td></tr>
<tr class="separator:a07bb6ff536c37f44a5c05f3ba5c300ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad851c542268bfdc461fc37d5be4d1b3b"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ad851c542268bfdc461fc37d5be4d1b3b">mutex_</a></td></tr>
<tr class="separator:ad851c542268bfdc461fc37d5be4d1b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d31b355624a35e3a806e5533084f78"><td class="memItemLeft" align="right" valign="top">memory_strategy::MemoryStrategy::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#aa1d31b355624a35e3a806e5533084f78">memory_strategy_</a></td></tr>
<tr class="memdesc:aa1d31b355624a35e3a806e5533084f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">The memory strategy: an interface for handling user-defined memory allocation strategies.  <a href="classrclcpp_1_1Executor.html#aa1d31b355624a35e3a806e5533084f78">More...</a><br /></td></tr>
<tr class="separator:aa1d31b355624a35e3a806e5533084f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb729b9e8a7e925e08fb0a9d6244282"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1Context.html">rclcpp::Context</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a9cb729b9e8a7e925e08fb0a9d6244282">context_</a></td></tr>
<tr class="memdesc:a9cb729b9e8a7e925e08fb0a9d6244282"><td class="mdescLeft">&#160;</td><td class="mdescRight">The context associated with this executor.  <a href="classrclcpp_1_1Executor.html#a9cb729b9e8a7e925e08fb0a9d6244282">More...</a><br /></td></tr>
<tr class="separator:a9cb729b9e8a7e925e08fb0a9d6244282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d97fbf87035b86717a0c6573030b9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1Executor.html#a3580d9e86d9ebb7e674e4270d485bef6">WeakCallbackGroupsToGuardConditionsMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a76d97fbf87035b86717a0c6573030b9f">weak_groups_to_guard_conditions_</a></td></tr>
<tr class="memdesc:a76d97fbf87035b86717a0c6573030b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps callback groups to guard conditions  <a href="classrclcpp_1_1Executor.html#a76d97fbf87035b86717a0c6573030b9f">More...</a><br /></td></tr>
<tr class="separator:a76d97fbf87035b86717a0c6573030b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e4e0095bcfef72436151e32040a653"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a80e4e0095bcfef72436151e32040a653">weak_groups_associated_with_executor_to_nodes_</a></td></tr>
<tr class="memdesc:a80e4e0095bcfef72436151e32040a653"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps callback groups associated to nodes  <a href="classrclcpp_1_1Executor.html#a80e4e0095bcfef72436151e32040a653">More...</a><br /></td></tr>
<tr class="separator:a80e4e0095bcfef72436151e32040a653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7eb596c5102555c0189a9ea430cd36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#acd7eb596c5102555c0189a9ea430cd36">weak_groups_to_nodes_associated_with_executor_</a></td></tr>
<tr class="memdesc:acd7eb596c5102555c0189a9ea430cd36"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps callback groups to nodes associated with executor  <a href="classrclcpp_1_1Executor.html#acd7eb596c5102555c0189a9ea430cd36">More...</a><br /></td></tr>
<tr class="separator:acd7eb596c5102555c0189a9ea430cd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8af8318254071752bb2c89c044ed56c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ae8af8318254071752bb2c89c044ed56c">weak_groups_to_nodes_</a></td></tr>
<tr class="memdesc:ae8af8318254071752bb2c89c044ed56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps all callback groups to nodes  <a href="classrclcpp_1_1Executor.html#ae8af8318254071752bb2c89c044ed56c">More...</a><br /></td></tr>
<tr class="separator:ae8af8318254071752bb2c89c044ed56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83944e8c14cee34664cf40d1bc29e058"><td class="memItemLeft" align="right" valign="top">std::list&lt; rclcpp::node_interfaces::NodeBaseInterface::WeakPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a83944e8c14cee34664cf40d1bc29e058">weak_nodes_</a></td></tr>
<tr class="memdesc:a83944e8c14cee34664cf40d1bc29e058"><td class="mdescLeft">&#160;</td><td class="mdescRight">nodes that are associated with the executor  <a href="classrclcpp_1_1Executor.html#a83944e8c14cee34664cf40d1bc29e058">More...</a><br /></td></tr>
<tr class="separator:a83944e8c14cee34664cf40d1bc29e058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fadf16c2cd579d8fc6d4da00a6d372"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerclcpp.html#a5da79bfb6561c87736d5b49f30a4d0f2">rclcpp::OnShutdownCallbackHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ac6fadf16c2cd579d8fc6d4da00a6d372">shutdown_callback_handle_</a></td></tr>
<tr class="memdesc:ac6fadf16c2cd579d8fc6d4da00a6d372"><td class="mdescLeft">&#160;</td><td class="mdescRight">shutdown callback handle registered to <a class="el" href="classrclcpp_1_1Context.html" title="Context which encapsulates shared state between nodes and other similar entities.">Context</a>  <a href="classrclcpp_1_1Executor.html#ac6fadf16c2cd579d8fc6d4da00a6d372">More...</a><br /></td></tr>
<tr class="separator:ac6fadf16c2cd579d8fc6d4da00a6d372"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Coordinate the order and timing of available communication tasks. </p>
<p><a class="el" href="classrclcpp_1_1Executor.html" title="Coordinate the order and timing of available communication tasks.">Executor</a> provides spin functions (including spin_node_once and spin_some). It coordinates the nodes and callback groups by looking for available work and completing it, based on the threading or concurrency scheme provided by the subclass implementation. An example of available work is executing a subscription callback, or a timer callback. The executor structure allows for a decoupling of the communication graph and the execution model. See SingleThreadedExecutor and MultiThreadedExecutor for examples of execution paradigms. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3580d9e86d9ebb7e674e4270d485bef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3580d9e86d9ebb7e674e4270d485bef6">&#9670;&nbsp;</a></span>WeakCallbackGroupsToGuardConditionsMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;rclcpp::CallbackGroup::WeakPtr, const <a class="el" href="classrclcpp_1_1GuardCondition.html">rclcpp::GuardCondition</a> *, std::owner_less&lt;rclcpp::CallbackGroup::WeakPtr&gt; &gt; <a class="el" href="classrclcpp_1_1Executor.html#a3580d9e86d9ebb7e674e4270d485bef6">rclcpp::Executor::WeakCallbackGroupsToGuardConditionsMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3d28d13a7233751c9b7b023528f10228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d28d13a7233751c9b7b023528f10228">&#9670;&nbsp;</a></span>Executor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::Executor::Executor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrclcpp_1_1ExecutorOptions.html">rclcpp::ExecutorOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structrclcpp_1_1ExecutorOptions.html">rclcpp::ExecutorOptions</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Options used to configure the executor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a946f5bfe58cb0ee5f52a98455248ed66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946f5bfe58cb0ee5f52a98455248ed66">&#9670;&nbsp;</a></span>~Executor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual rclcpp::Executor::~Executor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad096fec6846af2169ee97cd2d23e96ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad096fec6846af2169ee97cd2d23e96ca">&#9670;&nbsp;</a></span>spin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Executor::spin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do work periodically as it becomes available to us. Blocking call, may block indefinitely. </p>

<p>Implemented in <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a1cec9027c4c69e49a6e15398f01b7c47">rclcpp::executors::StaticSingleThreadedExecutor</a>, <a class="el" href="classrclcpp_1_1executors_1_1SingleThreadedExecutor.html#a77218fef5f77a2084a251e7b885fd3d0">rclcpp::executors::SingleThreadedExecutor</a>, and <a class="el" href="classrclcpp_1_1executors_1_1MultiThreadedExecutor.html#a7f14b56a547fb58ebe9aa49fc07a83cf">rclcpp::executors::MultiThreadedExecutor</a>.</p>

</div>
</div>
<a id="a6bb97eed174e54946d42ea83cf72a5a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb97eed174e54946d42ea83cf72a5a9">&#9670;&nbsp;</a></span>add_callback_group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Executor::add_callback_group </td>
          <td>(</td>
          <td class="paramtype">rclcpp::CallbackGroup::SharedPtr&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a callback group to an executor. </p>
<p>An executor can have zero or more callback groups which provide work during <code>spin</code> functions. When an executor attempts to add a callback group, the executor checks to see if it is already associated with another executor, and if it has been, then an exception is thrown. Otherwise, the callback group is added to the executor.</p>
<p>Adding a callback group with this method does not associate its node with this executor in any way</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group_ptr</td><td>a shared ptr that points to a callback group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node_ptr</td><td>a shared pointer that points to a node base interface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notify</td><td>True to trigger the interrupt guard condition during this function. If the executor is blocked at the rmw layer while waiting for work and it is notified that a new callback group was added, it will wake up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the callback group is associated to an executor </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a7641a44b0e95911a08c9961f7cd6963c">rclcpp::executors::StaticSingleThreadedExecutor</a>.</p>

</div>
</div>
<a id="aa37926d32654ae54f95bd6676005901c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa37926d32654ae54f95bd6676005901c">&#9670;&nbsp;</a></span>get_all_callback_groups()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;rclcpp::CallbackGroup::WeakPtr&gt; rclcpp::Executor::get_all_callback_groups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get callback groups that belong to executor. </p>
<p>This function returns a vector of weak pointers that point to callback groups that were associated with the executor. The callback groups associated with this executor may have been added with <code>add_callback_group</code>, or added when a node was added to the executor with <code>add_node</code>, or automatically added when it created by a node already associated with this executor and the automatically_add_to_executor_with_node parameter was true.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector of weak pointers that point to callback groups that are associated with the executor </dd></dl>

<p>Reimplemented in <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a90eebd217c5102fb470508f3ad9698a7">rclcpp::executors::StaticSingleThreadedExecutor</a>.</p>

</div>
</div>
<a id="a6718d2978792d55091e0e97f136e21ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6718d2978792d55091e0e97f136e21ba">&#9670;&nbsp;</a></span>get_manually_added_callback_groups()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;rclcpp::CallbackGroup::WeakPtr&gt; rclcpp::Executor::get_manually_added_callback_groups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get callback groups that belong to executor. </p>
<p>This function returns a vector of weak pointers that point to callback groups that were associated with the executor. The callback groups associated with this executor have been added with <code>add_callback_group</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector of weak pointers that point to callback groups that are associated with the executor </dd></dl>

<p>Reimplemented in <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#abe0584c4a5c8a34c6e4b9d649174e64d">rclcpp::executors::StaticSingleThreadedExecutor</a>.</p>

</div>
</div>
<a id="a156eeccc922f93d044efc8ce1b55b5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156eeccc922f93d044efc8ce1b55b5cc">&#9670;&nbsp;</a></span>get_automatically_added_callback_groups_from_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;rclcpp::CallbackGroup::WeakPtr&gt; rclcpp::Executor::get_automatically_added_callback_groups_from_nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get callback groups that belong to executor. </p>
<p>This function returns a vector of weak pointers that point to callback groups that were added from a node that is associated with the executor. The callback groups are added when a node is added to the executor with <code>add_node</code>, or automatically if they are created in the future by that node and have the automatically_add_to_executor_with_node argument set to true.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector of weak pointers that point to callback groups from a node associated with the executor </dd></dl>

<p>Reimplemented in <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#ab28350f023e1e9ac738557000eb70ac8">rclcpp::executors::StaticSingleThreadedExecutor</a>.</p>

</div>
</div>
<a id="a84a5c14786aee651ce0f7d5f1bfd098f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a5c14786aee651ce0f7d5f1bfd098f">&#9670;&nbsp;</a></span>remove_callback_group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Executor::remove_callback_group </td>
          <td>(</td>
          <td class="paramtype">rclcpp::CallbackGroup::SharedPtr&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a callback group from the executor. </p>
<p>The callback group is removed from and disassociated with the executor. If the callback group removed was the last callback group from the node that is associated with the executor, the interrupt guard condition is triggered and node's guard condition is removed from the executor.</p>
<p>This function only removes a callback group that was manually added with <a class="el" href="classrclcpp_1_1Executor.html#a6bb97eed174e54946d42ea83cf72a5a9" title="Add a callback group to an executor.">rclcpp::Executor::add_callback_group</a>. To remove callback groups that were added from a node using <a class="el" href="classrclcpp_1_1Executor.html#a53f9649e4c2f3593c930f4d191e7e208" title="Add a node to the executor.">rclcpp::Executor::add_node</a>, use <a class="el" href="classrclcpp_1_1Executor.html#a660424725a58fc412fac8e86191b1f61" title="Remove a node from the executor.">rclcpp::Executor::remove_node</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group_ptr</td><td>Shared pointer to the callback group to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notify</td><td>True to trigger the interrupt guard condition during this function. If the executor is blocked at the rmw layer while waiting for work and it is notified that a callback group was removed, it will wake up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if node is deleted before callback group </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the callback group is not associated with the executor </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#ac5142581ba7090734726cf6c471d084e">rclcpp::executors::StaticSingleThreadedExecutor</a>.</p>

</div>
</div>
<a id="a53f9649e4c2f3593c930f4d191e7e208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f9649e4c2f3593c930f4d191e7e208">&#9670;&nbsp;</a></span>add_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Executor::add_node </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a node to the executor. </p>
<p>Nodes have associated callback groups, and this method adds any of those callback groups to this executor which have their automatically_add_to_executor_with_node parameter true. The node is also associated with the executor so that future callback groups which are created on the node with the automatically_add_to_executor_with_node parameter set to true are also automatically associated with this executor.</p>
<p>Callback groups with the automatically_add_to_executor_with_node parameter set to false must be manually added to an executor using the <a class="el" href="classrclcpp_1_1Executor.html#a6bb97eed174e54946d42ea83cf72a5a9" title="Add a callback group to an executor.">rclcpp::Executor::add_callback_group</a> method.</p>
<p>If a node is already associated with an executor, this method throws an exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_ptr</td><td>Shared pointer to the node to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notify</td><td>True to trigger the interrupt guard condition during this function. If the executor is blocked at the rmw layer while waiting for work and it is notified that a new node was added, it will wake up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if a node is already associated to an executor </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a5c04102c89554658c021dceb1555af2f">rclcpp::executors::StaticSingleThreadedExecutor</a>.</p>

</div>
</div>
<a id="a83a2b87b3a60d3fd8525d18879cec14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a2b87b3a60d3fd8525d18879cec14c">&#9670;&nbsp;</a></span>add_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Executor::add_node </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1Node.html">rclcpp::Node</a> &gt;&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Executor.html#a53f9649e4c2f3593c930f4d191e7e208" title="Add a node to the executor.">rclcpp::Executor::add_node</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#acc40d425a0b14000dcec22b93a5ba194">rclcpp::executors::StaticSingleThreadedExecutor</a>.</p>

</div>
</div>
<a id="a660424725a58fc412fac8e86191b1f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660424725a58fc412fac8e86191b1f61">&#9670;&nbsp;</a></span>remove_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Executor::remove_node </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a node from the executor. </p>
<p>Any callback groups automatically added when this node was added with <a class="el" href="classrclcpp_1_1Executor.html#a53f9649e4c2f3593c930f4d191e7e208" title="Add a node to the executor.">rclcpp::Executor::add_node</a> are automatically removed, and the node is no longer associated with this executor.</p>
<p>This also means that future callback groups created by the given node are no longer automatically added to this executor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_ptr</td><td>Shared pointer to the node to remove. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notify</td><td>True to trigger the interrupt guard condition and wake up the executor. This is useful if the last node was removed from the executor while the executor was blocked waiting for work in another thread, because otherwise the executor would never be notified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the node is not associated with an executor. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the node is not associated with this executor. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#ad0c159ea2f81661d52b06b1e8a4edbd0">rclcpp::executors::StaticSingleThreadedExecutor</a>.</p>

</div>
</div>
<a id="ae0543bf6a85ae11a042cef13077ab364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0543bf6a85ae11a042cef13077ab364">&#9670;&nbsp;</a></span>remove_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Executor::remove_node </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1Node.html">rclcpp::Node</a> &gt;&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Executor.html#a660424725a58fc412fac8e86191b1f61" title="Remove a node from the executor.">rclcpp::Executor::remove_node</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a9578b4ab98dda3b6493d35b87c302af4">rclcpp::executors::StaticSingleThreadedExecutor</a>.</p>

</div>
</div>
<a id="af09dd5b81cc174fd7029fab65a726db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09dd5b81cc174fd7029fab65a726db9">&#9670;&nbsp;</a></span>spin_node_once() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RepT  = int64_t, typename T  = std::milli&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Executor::spin_node_once </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; RepT, T &gt;&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::duration&lt;RepT,&#160;T&gt;(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a node to executor, execute the next available unit of work, and remove the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Shared pointer to the node to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>How long to wait for work to become available. Negative values cause spin_node_once to block indefinitely (the default behavior). A timeout of 0 causes this function to be non-blocking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9791fd5812f06add439c9cca86d6226b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9791fd5812f06add439c9cca86d6226b">&#9670;&nbsp;</a></span>spin_node_once() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeT  = rclcpp::Node, typename RepT  = int64_t, typename T  = std::milli&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Executor::spin_node_once </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; NodeT &gt;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; RepT, T &gt;&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::duration&lt;RepT,&#160;T&gt;(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface. </p>

</div>
</div>
<a id="a49780b2217485638b0d7be720062e630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49780b2217485638b0d7be720062e630">&#9670;&nbsp;</a></span>spin_node_some() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Executor::spin_node_some </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a node, complete all immediately available work, and remove the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Shared pointer to the node to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c8f89d67464b75cfc63f1ddf56f8850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8f89d67464b75cfc63f1ddf56f8850">&#9670;&nbsp;</a></span>spin_node_some() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Executor::spin_node_some </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1Node.html">rclcpp::Node</a> &gt;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface. </p>

</div>
</div>
<a id="ae821cd4cf1040fe2da521fb19a458fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae821cd4cf1040fe2da521fb19a458fa1">&#9670;&nbsp;</a></span>spin_some()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Executor::spin_some </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>max_duration</em> = <code>std::chrono::nanoseconds(0)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collect work once and execute all available work, optionally within a duration. </p>
<p>This function can be overridden. The default implementation is suitable for a single-threaded model of execution. Adding subscriptions, timers, services, etc. with blocking callbacks will cause this function to block (which may have unintended consequences).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_duration</td><td>The maximum amount of time to spend executing work, or 0 for no limit. Note that <a class="el" href="classrclcpp_1_1Executor.html#ae821cd4cf1040fe2da521fb19a458fa1" title="Collect work once and execute all available work, optionally within a duration.">spin_some()</a> may take longer than this time as it only returns once max_duration has been exceeded. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a38723cc9e16bddd7b4be5400c3125a99">rclcpp::executors::StaticSingleThreadedExecutor</a>.</p>

</div>
</div>
<a id="a5e13b528a3f94a5d54ff139ec1f4a7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e13b528a3f94a5d54ff139ec1f4a7cc">&#9670;&nbsp;</a></span>spin_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Executor::spin_all </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>max_duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collect and execute work repeatedly within a duration or until no more work is available. </p>
<p>This function can be overridden. The default implementation is suitable for a single-threaded model of execution. Adding subscriptions, timers, services, etc. with blocking callbacks will cause this function to block (which may have unintended consequences). If the time that waitables take to be executed is longer than the period on which new waitables become ready, this method will execute work repeatedly until <code>max_duration</code> has elapsed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_duration</td><td>The maximum amount of time to spend executing work, must be &gt;= 0. <code>0</code> is potentially block forever until no more work is available. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if max_duration is less than 0. Note that <a class="el" href="classrclcpp_1_1Executor.html#a5e13b528a3f94a5d54ff139ec1f4a7cc" title="Collect and execute work repeatedly within a duration or until no more work is available.">spin_all()</a> may take longer than this time as it only returns once max_duration has been exceeded. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a642edbabbbe955174256300db23b25fc">rclcpp::executors::StaticSingleThreadedExecutor</a>.</p>

</div>
</div>
<a id="ae4abb57eea7e1b6c95acc0e7abff62b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4abb57eea7e1b6c95acc0e7abff62b2">&#9670;&nbsp;</a></span>spin_once()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Executor::spin_once </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::nanoseconds(-1)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a39a0c374568aae53dcca63eb29086327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a0c374568aae53dcca63eb29086327">&#9670;&nbsp;</a></span>spin_until_future_complete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FutureT , typename TimeRepT  = int64_t, typename TimeT  = std::milli&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerclcpp.html#a7b4ff5f1e516740d7e11ea97fe6f5532">FutureReturnCode</a> rclcpp::Executor::spin_until_future_complete </td>
          <td>(</td>
          <td class="paramtype">const FutureT &amp;&#160;</td>
          <td class="paramname"><em>future</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; TimeRepT, TimeT &gt;&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::duration&lt;TimeRepT,&#160;TimeT&gt;(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Spin (blocking) until the future is complete, it times out waiting, or rclcpp is interrupted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">future</td><td>The future to wait on. If this function returns SUCCESS, the future can be accessed without blocking (though it may still throw an exception). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Optional timeout parameter, which gets passed to <a class="el" href="classrclcpp_1_1Executor.html#af09dd5b81cc174fd7029fab65a726db9" title="Add a node to executor, execute the next available unit of work, and remove the node.">Executor::spin_node_once</a>. <code>-1</code> is block forever, <code>0</code> is non-blocking. If the time spent inside the blocking loop exceeds this timeout, return a TIMEOUT return code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return code, one of <code>SUCCESS</code>, <code>INTERRUPTED</code>, or <code>TIMEOUT</code>. </dd></dl>

</div>
</div>
<a id="a0fb21996107bcf4e62f8330e8d201e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb21996107bcf4e62f8330e8d201e70">&#9670;&nbsp;</a></span>cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Executor::cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel any running spin* function, causing it to return. </p>
<p>This function can be called asynchonously from any thread. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is an issue triggering the guard condition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa41ca2b0358c875337ac13a8130987e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41ca2b0358c875337ac13a8130987e9">&#9670;&nbsp;</a></span>set_memory_strategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Executor::set_memory_strategy </td>
          <td>(</td>
          <td class="paramtype">memory_strategy::MemoryStrategy::SharedPtr&#160;</td>
          <td class="paramname"><em>memory_strategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Support dynamic switching of the memory strategy. </p>
<p>Switching the memory strategy while the executor is spinning in another threading could have unintended consequences. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="namespacerclcpp_1_1memory__strategy.html">memory_strategy</a></td><td>Shared pointer to the memory strategy to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <a class="el" href="namespacerclcpp_1_1memory__strategy.html">memory_strategy</a> is null </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a476430345b9c7f2820290f272d2ef78f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476430345b9c7f2820290f272d2ef78f">&#9670;&nbsp;</a></span>is_spinning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::Executor::is_spinning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the executor is currently spinning. </p>
<p>This function can be called asynchronously from any thread. </p><dl class="section return"><dt>Returns</dt><dd>True if the executor is currently spinning. </dd></dl>

</div>
</div>
<a id="a562cd027f960258673a737c9e8d3be75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562cd027f960258673a737c9e8d3be75">&#9670;&nbsp;</a></span>spin_node_once_nanoseconds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Executor::spin_node_once_nanoseconds </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4cdf3b5fb2a673346f45feed75a7cd11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cdf3b5fb2a673346f45feed75a7cd11">&#9670;&nbsp;</a></span>spin_some_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Executor::spin_some_impl </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>max_duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exhaustive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a915f4738cf48d6c08851be8264aad58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915f4738cf48d6c08851be8264aad58d">&#9670;&nbsp;</a></span>execute_any_executable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Executor::execute_any_executable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrclcpp_1_1AnyExecutable.html">AnyExecutable</a> &amp;&#160;</td>
          <td class="paramname"><em>any_exec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the next available executable and do the work associated with it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">any_exec</td><td>Union structure that can hold any executable type (timer, subscription, service, client). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is an issue triggering the guard condition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f825d7a6d22eb8a6c2974d89d8bcebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f825d7a6d22eb8a6c2974d89d8bcebc">&#9670;&nbsp;</a></span>execute_subscription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rclcpp::Executor::execute_subscription </td>
          <td>(</td>
          <td class="paramtype">rclcpp::SubscriptionBase::SharedPtr&#160;</td>
          <td class="paramname"><em>subscription</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e62a3a7c60ab1569659aeaa47886b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e62a3a7c60ab1569659aeaa47886b7e">&#9670;&nbsp;</a></span>execute_timer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rclcpp::Executor::execute_timer </td>
          <td>(</td>
          <td class="paramtype">rclcpp::TimerBase::SharedPtr&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c2e10441f4ad3c566c84f44e8d697d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2e10441f4ad3c566c84f44e8d697d8">&#9670;&nbsp;</a></span>execute_service()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rclcpp::Executor::execute_service </td>
          <td>(</td>
          <td class="paramtype">rclcpp::ServiceBase::SharedPtr&#160;</td>
          <td class="paramname"><em>service</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a488790ad5eccaf4a7dc2b6eab6862147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488790ad5eccaf4a7dc2b6eab6862147">&#9670;&nbsp;</a></span>execute_client()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rclcpp::Executor::execute_client </td>
          <td>(</td>
          <td class="paramtype">rclcpp::ClientBase::SharedPtr&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af211465e15ae5b13bac0893ef9e0ed4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af211465e15ae5b13bac0893ef9e0ed4e">&#9670;&nbsp;</a></span>wait_for_work()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Executor::wait_for_work </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::nanoseconds(-1)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the wait set can be cleared </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4878997d1aba3efea583f307a22faa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4878997d1aba3efea583f307a22faa5">&#9670;&nbsp;</a></span>get_node_by_group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr rclcpp::Executor::get_node_by_group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a> &amp;&#160;</td>
          <td class="paramname"><em>weak_groups_to_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rclcpp::CallbackGroup::SharedPtr&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a552c54e50b71e3432366e15ef0536fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a552c54e50b71e3432366e15ef0536fef">&#9670;&nbsp;</a></span>has_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::Executor::has_node </td>
          <td>(</td>
          <td class="paramtype">const rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a> &amp;&#160;</td>
          <td class="paramname"><em>weak_groups_to_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the node has been added to this executor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_ptr</td><td>a shared pointer that points to a node base interface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weak_groups_to_nodes</td><td>map to nodes to lookup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node is associated with the executor, otherwise false </dd></dl>

</div>
</div>
<a id="a06baded5884fc91e6d36ab676f0b7fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06baded5884fc91e6d36ab676f0b7fc3">&#9670;&nbsp;</a></span>get_group_by_timer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::CallbackGroup::SharedPtr rclcpp::Executor::get_group_by_timer </td>
          <td>(</td>
          <td class="paramtype">rclcpp::TimerBase::SharedPtr&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e030d927aa29b42d44f9c51a5335325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e030d927aa29b42d44f9c51a5335325">&#9670;&nbsp;</a></span>add_callback_group_to_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Executor::add_callback_group_to_map </td>
          <td>(</td>
          <td class="paramtype">rclcpp::CallbackGroup::SharedPtr&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a> &amp;&#160;</td>
          <td class="paramname"><em>weak_groups_to_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a callback group to an executor. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Executor.html#a6bb97eed174e54946d42ea83cf72a5a9" title="Add a callback group to an executor.">rclcpp::Executor::add_callback_group</a> </dd></dl>

</div>
</div>
<a id="a9da65b29b968aa503df2df3eef091185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da65b29b968aa503df2df3eef091185">&#9670;&nbsp;</a></span>remove_callback_group_from_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Executor::remove_callback_group_from_map </td>
          <td>(</td>
          <td class="paramtype">rclcpp::CallbackGroup::SharedPtr&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a> &amp;&#160;</td>
          <td class="paramname"><em>weak_groups_to_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a callback group from the executor. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Executor.html#a84a5c14786aee651ce0f7d5f1bfd098f" title="Remove a callback group from the executor.">rclcpp::Executor::remove_callback_group</a> </dd></dl>

</div>
</div>
<a id="aad3c92aec4730186388701398c84263b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3c92aec4730186388701398c84263b">&#9670;&nbsp;</a></span>get_next_ready_executable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::Executor::get_next_ready_executable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrclcpp_1_1AnyExecutable.html">AnyExecutable</a> &amp;&#160;</td>
          <td class="paramname"><em>any_executable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a36e9721d4751ca0bd2b0faa1c9403255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e9721d4751ca0bd2b0faa1c9403255">&#9670;&nbsp;</a></span>get_next_ready_executable_from_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::Executor::get_next_ready_executable_from_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrclcpp_1_1AnyExecutable.html">AnyExecutable</a> &amp;&#160;</td>
          <td class="paramname"><em>any_executable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a> &amp;&#160;</td>
          <td class="paramname"><em>weak_groups_to_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63b530d7459b579ca22044a5e7a37a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b530d7459b579ca22044a5e7a37a50">&#9670;&nbsp;</a></span>get_next_executable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::Executor::get_next_executable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrclcpp_1_1AnyExecutable.html">AnyExecutable</a> &amp;&#160;</td>
          <td class="paramname"><em>any_executable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::nanoseconds(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a045379e6904e18e4bb3ff9f1aa039d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045379e6904e18e4bb3ff9f1aa039d46">&#9670;&nbsp;</a></span>add_callback_groups_from_nodes_associated_to_executor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Executor::add_callback_groups_from_nodes_associated_to_executor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add all callback groups that can be automatically added from associated nodes. </p>
<p>The executor, before collecting entities, verifies if any callback group from nodes associated with the executor, which is not already associated to an executor, can be automatically added to this executor. This takes care of any callback group that has been added to a node but not explicitly added to the executor. It is important to note that in order for the callback groups to be automatically added to an executor through this function, the node of the callback groups needs to have been added through the <code>add_node</code> method. </p>

</div>
</div>
<a id="afcce1959f54430db201b5800ff9f61a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcce1959f54430db201b5800ff9f61a6">&#9670;&nbsp;</a></span>spin_once_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Executor::spin_once_impl </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a4e2a7699ba52bb2d6a8323b36ad858dc">rclcpp::executors::StaticSingleThreadedExecutor</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="afe759d8451caa0752e2209bb0863dbcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe759d8451caa0752e2209bb0863dbcd">&#9670;&nbsp;</a></span>spinning</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic_bool rclcpp::Executor::spinning</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Spinning state, used to prevent multi threaded calls to spin and to cancel blocking spins. </p>

</div>
</div>
<a id="ab940062f9fdfe52fc4d6f6b9948951a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab940062f9fdfe52fc4d6f6b9948951a4">&#9670;&nbsp;</a></span>interrupt_guard_condition_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1GuardCondition.html">rclcpp::GuardCondition</a> rclcpp::Executor::interrupt_guard_condition_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Guard condition for signaling the rmw layer to wake up for special events. </p>

</div>
</div>
<a id="afc7ffa426ec1e9629d6744cd06b95d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7ffa426ec1e9629d6744cd06b95d1e">&#9670;&nbsp;</a></span>shutdown_guard_condition_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classrclcpp_1_1GuardCondition.html">rclcpp::GuardCondition</a>&gt; rclcpp::Executor::shutdown_guard_condition_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07bb6ff536c37f44a5c05f3ba5c300ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07bb6ff536c37f44a5c05f3ba5c300ee">&#9670;&nbsp;</a></span>wait_set_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rcl_wait_set_t rclcpp::Executor::wait_set_ = rcl_get_zero_initialized_wait_set()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait set for managing entities that the rmw layer waits on. </p>

</div>
</div>
<a id="ad851c542268bfdc461fc37d5be4d1b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad851c542268bfdc461fc37d5be4d1b3b">&#9670;&nbsp;</a></span>mutex_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex rclcpp::Executor::mutex_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1d31b355624a35e3a806e5533084f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d31b355624a35e3a806e5533084f78">&#9670;&nbsp;</a></span>memory_strategy_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">memory_strategy::MemoryStrategy::SharedPtr rclcpp::Executor::memory_strategy_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The memory strategy: an interface for handling user-defined memory allocation strategies. </p>

</div>
</div>
<a id="a9cb729b9e8a7e925e08fb0a9d6244282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb729b9e8a7e925e08fb0a9d6244282">&#9670;&nbsp;</a></span>context_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classrclcpp_1_1Context.html">rclcpp::Context</a>&gt; rclcpp::Executor::context_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The context associated with this executor. </p>

</div>
</div>
<a id="a76d97fbf87035b86717a0c6573030b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d97fbf87035b86717a0c6573030b9f">&#9670;&nbsp;</a></span>weak_groups_to_guard_conditions_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1Executor.html#a3580d9e86d9ebb7e674e4270d485bef6">WeakCallbackGroupsToGuardConditionsMap</a> rclcpp::Executor::weak_groups_to_guard_conditions_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maps callback groups to guard conditions </p>

</div>
</div>
<a id="a80e4e0095bcfef72436151e32040a653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e4e0095bcfef72436151e32040a653">&#9670;&nbsp;</a></span>weak_groups_associated_with_executor_to_nodes_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a> rclcpp::Executor::weak_groups_associated_with_executor_to_nodes_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maps callback groups associated to nodes </p>

</div>
</div>
<a id="acd7eb596c5102555c0189a9ea430cd36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7eb596c5102555c0189a9ea430cd36">&#9670;&nbsp;</a></span>weak_groups_to_nodes_associated_with_executor_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a> rclcpp::Executor::weak_groups_to_nodes_associated_with_executor_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maps callback groups to nodes associated with executor </p>

</div>
</div>
<a id="ae8af8318254071752bb2c89c044ed56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8af8318254071752bb2c89c044ed56c">&#9670;&nbsp;</a></span>weak_groups_to_nodes_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a> rclcpp::Executor::weak_groups_to_nodes_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maps all callback groups to nodes </p>

</div>
</div>
<a id="a83944e8c14cee34664cf40d1bc29e058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83944e8c14cee34664cf40d1bc29e058">&#9670;&nbsp;</a></span>weak_nodes_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;rclcpp::node_interfaces::NodeBaseInterface::WeakPtr&gt; rclcpp::Executor::weak_nodes_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>nodes that are associated with the executor </p>

</div>
</div>
<a id="ac6fadf16c2cd579d8fc6d4da00a6d372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6fadf16c2cd579d8fc6d4da00a6d372">&#9670;&nbsp;</a></span>shutdown_callback_handle_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerclcpp.html#a5da79bfb6561c87736d5b49f30a4d0f2">rclcpp::OnShutdownCallbackHandle</a> rclcpp::Executor::shutdown_callback_handle_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>shutdown callback handle registered to <a class="el" href="classrclcpp_1_1Context.html" title="Context which encapsulates shared state between nodes and other similar entities.">Context</a> </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/rclcpp/<a class="el" href="executor_8hpp_source.html">executor.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
