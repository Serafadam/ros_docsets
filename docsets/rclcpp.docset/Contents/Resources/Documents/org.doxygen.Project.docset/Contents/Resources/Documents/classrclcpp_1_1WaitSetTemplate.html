<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rclcpp: rclcpp::WaitSetTemplate&lt; SynchronizationPolicy, StoragePolicy &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rclcpp
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C++ ROS Client Library API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerclcpp.html">rclcpp</a></li><li class="navelem"><a class="el" href="classrclcpp_1_1WaitSetTemplate.html">WaitSetTemplate</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classrclcpp_1_1WaitSetTemplate-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rclcpp::WaitSetTemplate&lt; SynchronizationPolicy, StoragePolicy &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Encapsulates sets of waitable items which can be waited on as a group.  
 <a href="classrclcpp_1_1WaitSetTemplate.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="wait__set__template_8hpp_source.html">wait_set_template.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rclcpp::WaitSetTemplate&lt; SynchronizationPolicy, StoragePolicy &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1WaitSetTemplate__inherit__graph.png" border="0" usemap="#arclcpp_1_1WaitSetTemplate_3_01SynchronizationPolicy_00_01StoragePolicy_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="arclcpp_1_1WaitSetTemplate_3_01SynchronizationPolicy_00_01StoragePolicy_01_4_inherit__map" id="arclcpp_1_1WaitSetTemplate_3_01SynchronizationPolicy_00_01StoragePolicy_01_4_inherit__map">
<area shape="rect" title="Encapsulates sets of waitable items which can be waited on as a group." alt="" coords="77,80,261,136"/>
<area shape="rect" title=" " alt="" coords="5,5,171,32"/>
<area shape="rect" title=" " alt="" coords="195,5,306,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for rclcpp::WaitSetTemplate&lt; SynchronizationPolicy, StoragePolicy &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1WaitSetTemplate__coll__graph.png" border="0" usemap="#arclcpp_1_1WaitSetTemplate_3_01SynchronizationPolicy_00_01StoragePolicy_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="arclcpp_1_1WaitSetTemplate_3_01SynchronizationPolicy_00_01StoragePolicy_01_4_coll__map" id="arclcpp_1_1WaitSetTemplate_3_01SynchronizationPolicy_00_01StoragePolicy_01_4_coll__map">
<area shape="rect" title="Encapsulates sets of waitable items which can be waited on as a group." alt="" coords="77,80,261,136"/>
<area shape="rect" title=" " alt="" coords="5,5,171,32"/>
<area shape="rect" title=" " alt="" coords="195,5,306,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a53bf27a0dd8ec262e2ac2f36fa0c2b96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#a53bf27a0dd8ec262e2ac2f36fa0c2b96">WaitSetTemplate</a> (const typename StoragePolicy::SubscriptionsIterable &amp;subscriptions={}, const typename StoragePolicy::GuardConditionsIterable &amp;guard_conditions={}, const typename StoragePolicy::TimersIterable &amp;timers={}, const typename StoragePolicy::ClientsIterable &amp;clients={}, const typename StoragePolicy::ServicesIterable &amp;services={}, const typename StoragePolicy::WaitablesIterable &amp;waitables={}, rclcpp::Context::SharedPtr context=<a class="el" href="namespacerclcpp_1_1contexts.html#a18a2108b667f7e582db2c9ef216870a6">rclcpp::contexts::get_global_default_context</a>())</td></tr>
<tr class="memdesc:a53bf27a0dd8ec262e2ac2f36fa0c2b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a wait set with optional initial waitable entities and optional custom context.  <a name="//apple_ref/cpp/Method/WaitSetTemplate" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1WaitSetTemplate.html#a53bf27a0dd8ec262e2ac2f36fa0c2b96">More...</a><br /></td></tr>
<tr class="separator:a53bf27a0dd8ec262e2ac2f36fa0c2b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d1e940574b075583cad733b65e9733"><td class="memItemLeft" align="right" valign="top">const rcl_wait_set_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#af3d1e940574b075583cad733b65e9733">get_rcl_wait_set</a> () const</td></tr>
<tr class="memdesc:af3d1e940574b075583cad733b65e9733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the internal rcl wait set object.  <a name="//apple_ref/cpp/Method/get_rcl_wait_set" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1WaitSetTemplate.html#af3d1e940574b075583cad733b65e9733">More...</a><br /></td></tr>
<tr class="separator:af3d1e940574b075583cad733b65e9733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503c56f84276028350dd3d2287418727"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#a503c56f84276028350dd3d2287418727">add_subscription</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1SubscriptionBase.html">rclcpp::SubscriptionBase</a> &gt; subscription, <a class="el" href="classrclcpp_1_1SubscriptionWaitSetMask.html">rclcpp::SubscriptionWaitSetMask</a> mask={})</td></tr>
<tr class="memdesc:a503c56f84276028350dd3d2287418727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a subscription to this wait set.  <a name="//apple_ref/cpp/Method/add_subscription" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1WaitSetTemplate.html#a503c56f84276028350dd3d2287418727">More...</a><br /></td></tr>
<tr class="separator:a503c56f84276028350dd3d2287418727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87137037fcf21a6a1bcdf0cd3247c843"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#a87137037fcf21a6a1bcdf0cd3247c843">remove_subscription</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1SubscriptionBase.html">rclcpp::SubscriptionBase</a> &gt; subscription, <a class="el" href="classrclcpp_1_1SubscriptionWaitSetMask.html">rclcpp::SubscriptionWaitSetMask</a> mask={})</td></tr>
<tr class="memdesc:a87137037fcf21a6a1bcdf0cd3247c843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a subscription from this wait set.  <a name="//apple_ref/cpp/Method/remove_subscription" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1WaitSetTemplate.html#a87137037fcf21a6a1bcdf0cd3247c843">More...</a><br /></td></tr>
<tr class="separator:a87137037fcf21a6a1bcdf0cd3247c843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1773c9f262142c76657afbd290888e06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#a1773c9f262142c76657afbd290888e06">add_guard_condition</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1GuardCondition.html">rclcpp::GuardCondition</a> &gt; guard_condition)</td></tr>
<tr class="memdesc:a1773c9f262142c76657afbd290888e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a guard condition to this wait set.  <a name="//apple_ref/cpp/Method/add_guard_condition" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1WaitSetTemplate.html#a1773c9f262142c76657afbd290888e06">More...</a><br /></td></tr>
<tr class="separator:a1773c9f262142c76657afbd290888e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1021de92357096cb92ffbb1e79996a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#aa1021de92357096cb92ffbb1e79996a3">remove_guard_condition</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1GuardCondition.html">rclcpp::GuardCondition</a> &gt; guard_condition)</td></tr>
<tr class="memdesc:aa1021de92357096cb92ffbb1e79996a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a guard condition from this wait set.  <a name="//apple_ref/cpp/Method/remove_guard_condition" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1WaitSetTemplate.html#aa1021de92357096cb92ffbb1e79996a3">More...</a><br /></td></tr>
<tr class="separator:aa1021de92357096cb92ffbb1e79996a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc813b4cb6f18dd707269097acec26e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#acc813b4cb6f18dd707269097acec26e7">add_timer</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1TimerBase.html">rclcpp::TimerBase</a> &gt; timer)</td></tr>
<tr class="memdesc:acc813b4cb6f18dd707269097acec26e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a timer to this wait set.  <a name="//apple_ref/cpp/Method/add_timer" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1WaitSetTemplate.html#acc813b4cb6f18dd707269097acec26e7">More...</a><br /></td></tr>
<tr class="separator:acc813b4cb6f18dd707269097acec26e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cef3f62dc2c7412c9e530ee48f8376"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#aa3cef3f62dc2c7412c9e530ee48f8376">remove_timer</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1TimerBase.html">rclcpp::TimerBase</a> &gt; timer)</td></tr>
<tr class="memdesc:aa3cef3f62dc2c7412c9e530ee48f8376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a timer from this wait set.  <a name="//apple_ref/cpp/Method/remove_timer" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1WaitSetTemplate.html#aa3cef3f62dc2c7412c9e530ee48f8376">More...</a><br /></td></tr>
<tr class="separator:aa3cef3f62dc2c7412c9e530ee48f8376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9669ab3069967f0972d48d2fefee8bcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#a9669ab3069967f0972d48d2fefee8bcb">add_client</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1ClientBase.html">rclcpp::ClientBase</a> &gt; client)</td></tr>
<tr class="memdesc:a9669ab3069967f0972d48d2fefee8bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a client to this wait set.  <a name="//apple_ref/cpp/Method/add_client" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1WaitSetTemplate.html#a9669ab3069967f0972d48d2fefee8bcb">More...</a><br /></td></tr>
<tr class="separator:a9669ab3069967f0972d48d2fefee8bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50bb31d6746db9fcc530d26288b59366"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#a50bb31d6746db9fcc530d26288b59366">remove_client</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1ClientBase.html">rclcpp::ClientBase</a> &gt; client)</td></tr>
<tr class="memdesc:a50bb31d6746db9fcc530d26288b59366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a client from this wait set.  <a name="//apple_ref/cpp/Method/remove_client" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1WaitSetTemplate.html#a50bb31d6746db9fcc530d26288b59366">More...</a><br /></td></tr>
<tr class="separator:a50bb31d6746db9fcc530d26288b59366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36acee7f542fc5c58fa7064ab4fd55b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#a36acee7f542fc5c58fa7064ab4fd55b0">add_service</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1ServiceBase.html">rclcpp::ServiceBase</a> &gt; service)</td></tr>
<tr class="memdesc:a36acee7f542fc5c58fa7064ab4fd55b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a service to this wait set.  <a name="//apple_ref/cpp/Method/add_service" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1WaitSetTemplate.html#a36acee7f542fc5c58fa7064ab4fd55b0">More...</a><br /></td></tr>
<tr class="separator:a36acee7f542fc5c58fa7064ab4fd55b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4d08ac5c17cebf9b9fb8d4a7e92bcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#ada4d08ac5c17cebf9b9fb8d4a7e92bcd">remove_service</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1ServiceBase.html">rclcpp::ServiceBase</a> &gt; service)</td></tr>
<tr class="memdesc:ada4d08ac5c17cebf9b9fb8d4a7e92bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a service from this wait set.  <a name="//apple_ref/cpp/Method/remove_service" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1WaitSetTemplate.html#ada4d08ac5c17cebf9b9fb8d4a7e92bcd">More...</a><br /></td></tr>
<tr class="separator:ada4d08ac5c17cebf9b9fb8d4a7e92bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636ab1de60af6d9659ffa60fa4a700fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#a636ab1de60af6d9659ffa60fa4a700fb">add_waitable</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1Waitable.html">rclcpp::Waitable</a> &gt; waitable, std::shared_ptr&lt; void &gt; associated_entity=nullptr)</td></tr>
<tr class="memdesc:a636ab1de60af6d9659ffa60fa4a700fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a waitable to this wait set.  <a name="//apple_ref/cpp/Method/add_waitable" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1WaitSetTemplate.html#a636ab1de60af6d9659ffa60fa4a700fb">More...</a><br /></td></tr>
<tr class="separator:a636ab1de60af6d9659ffa60fa4a700fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22120ae19bd980fc1029b233be72f2ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#a22120ae19bd980fc1029b233be72f2ff">remove_waitable</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1Waitable.html">rclcpp::Waitable</a> &gt; waitable)</td></tr>
<tr class="memdesc:a22120ae19bd980fc1029b233be72f2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a waitable from this wait set.  <a name="//apple_ref/cpp/Method/remove_waitable" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1WaitSetTemplate.html#a22120ae19bd980fc1029b233be72f2ff">More...</a><br /></td></tr>
<tr class="separator:a22120ae19bd980fc1029b233be72f2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090483821f8ebb4f45f3d20ee41fe182"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#a090483821f8ebb4f45f3d20ee41fe182">prune_deleted_entities</a> ()</td></tr>
<tr class="memdesc:a090483821f8ebb4f45f3d20ee41fe182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove any destroyed entities from the wait set.  <a name="//apple_ref/cpp/Method/prune_deleted_entities" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1WaitSetTemplate.html#a090483821f8ebb4f45f3d20ee41fe182">More...</a><br /></td></tr>
<tr class="separator:a090483821f8ebb4f45f3d20ee41fe182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a88a2709971a414409dde6839378f69"><td class="memTemplParams" colspan="2">template&lt;class Rep  = int64_t, class Period  = std::milli&gt; </td></tr>
<tr class="memitem:a4a88a2709971a414409dde6839378f69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1WaitResult.html">WaitResult</a>&lt; <a class="el" href="classrclcpp_1_1WaitSetTemplate.html">WaitSetTemplate</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#a4a88a2709971a414409dde6839378f69">wait</a> (std::chrono::duration&lt; Rep, Period &gt; time_to_wait=std::chrono::duration&lt; Rep, Period &gt;(-1))</td></tr>
<tr class="memdesc:a4a88a2709971a414409dde6839378f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for any of the entities in the wait set to be ready, or a period of time to pass.  <a name="//apple_ref/cpp/Method/wait" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1WaitSetTemplate.html#a4a88a2709971a414409dde6839378f69">More...</a><br /></td></tr>
<tr class="separator:a4a88a2709971a414409dde6839378f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class SynchronizationPolicy, class StoragePolicy&gt;<br />
class rclcpp::WaitSetTemplate&lt; SynchronizationPolicy, StoragePolicy &gt;</h3>

<p>Encapsulates sets of waitable items which can be waited on as a group. </p>
<p>This class uses the rcl_wait_set_t as storage, but it also helps manage the ownership of associated rclcpp types. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a53bf27a0dd8ec262e2ac2f36fa0c2b96"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/WaitSetTemplate" class="dashAnchor">&nbsp;</a><a href="#a53bf27a0dd8ec262e2ac2f36fa0c2b96">&#9670;&nbsp;</a></span>WaitSetTemplate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SynchronizationPolicy , class StoragePolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1WaitSetTemplate.html">rclcpp::WaitSetTemplate</a>&lt; SynchronizationPolicy, StoragePolicy &gt;::<a class="el" href="classrclcpp_1_1WaitSetTemplate.html">WaitSetTemplate</a> </td>
          <td>(</td>
          <td class="paramtype">const typename StoragePolicy::SubscriptionsIterable &amp;&#160;</td>
          <td class="paramname"><em>subscriptions</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename StoragePolicy::GuardConditionsIterable &amp;&#160;</td>
          <td class="paramname"><em>guard_conditions</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename StoragePolicy::TimersIterable &amp;&#160;</td>
          <td class="paramname"><em>timers</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename StoragePolicy::ClientsIterable &amp;&#160;</td>
          <td class="paramname"><em>clients</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename StoragePolicy::ServicesIterable &amp;&#160;</td>
          <td class="paramname"><em>services</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename StoragePolicy::WaitablesIterable &amp;&#160;</td>
          <td class="paramname"><em>waitables</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rclcpp::Context::SharedPtr&#160;</td>
          <td class="paramname"><em>context</em> = <code><a class="el" href="namespacerclcpp_1_1contexts.html#a18a2108b667f7e582db2c9ef216870a6">rclcpp::contexts::get_global_default_context</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a wait set with optional initial waitable entities and optional custom context. </p>
<p>For the waitables, they have additionally an "associated" entity, which you can read more about in the add and remove functions for those types in this class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscriptions</td><td>Vector of subscriptions to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">guard_conditions</td><td>Vector of guard conditions to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timers</td><td>Vector of timers to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clients</td><td>Vector of clients and their associated entity to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">services</td><td>Vector of services and their associated entity to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waitables</td><td>Vector of waitables and their associated entity to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Custom context to be used, defaults to global default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If context is nullptr. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af3d1e940574b075583cad733b65e9733"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/get_rcl_wait_set" class="dashAnchor">&nbsp;</a><a href="#af3d1e940574b075583cad733b65e9733">&#9670;&nbsp;</a></span>get_rcl_wait_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SynchronizationPolicy , class StoragePolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const rcl_wait_set_t&amp; <a class="el" href="classrclcpp_1_1WaitSetTemplate.html">rclcpp::WaitSetTemplate</a>&lt; SynchronizationPolicy, StoragePolicy &gt;::get_rcl_wait_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the internal rcl wait set object. </p>
<p>This method provides no thread-safety when accessing this structure. The state of this structure can be updated at anytime by methods like <a class="el" href="classrclcpp_1_1WaitSetTemplate.html#a4a88a2709971a414409dde6839378f69" title="Wait for any of the entities in the wait set to be ready, or a period of time to pass.">wait()</a>, add_*(), remove_*(), etc. </p>

</div>
</div>
<a id="a503c56f84276028350dd3d2287418727"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/add_subscription" class="dashAnchor">&nbsp;</a><a href="#a503c56f84276028350dd3d2287418727">&#9670;&nbsp;</a></span>add_subscription()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SynchronizationPolicy , class StoragePolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrclcpp_1_1WaitSetTemplate.html">rclcpp::WaitSetTemplate</a>&lt; SynchronizationPolicy, StoragePolicy &gt;::add_subscription </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1SubscriptionBase.html">rclcpp::SubscriptionBase</a> &gt;&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1SubscriptionWaitSetMask.html">rclcpp::SubscriptionWaitSetMask</a>&#160;</td>
          <td class="paramname"><em>mask</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a subscription to this wait set. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#a1773c9f262142c76657afbd290888e06" title="Add a guard condition to this wait set.">add_guard_condition()</a> for details of how this method works.</dd></dl>
<p>Additionally to the documentation for add_guard_condition, this method has a mask parameter which allows you to control which parts of the subscription is added to the wait set with this call. For example, you might want to include the actual subscription to this wait set, but add the intra-process waitable to another wait set. If intra-process is disabled, no error will occur, it will just be skipped.</p>
<p>When introspecting after waiting, this subscription's shared pointer will be the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a>'s (intra-process or the <a class="el" href="classrclcpp_1_1QoS.html" title="Encapsulation of Quality of Service settings.">QoS</a> Events) "associated entity" pointer, for more easily figuring out which subscription which waitable goes with afterwards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td><a class="el" href="classrclcpp_1_1Subscription.html" title="Subscription implementation, templated on the type of message this subscription receives.">Subscription</a> to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>A class which controls which parts of the subscription to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if subscription is nullptr. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if subscription has already been added or is associated with another wait set. </td></tr>
    <tr><td class="paramname">exceptions</td><td>based on the policies used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87137037fcf21a6a1bcdf0cd3247c843"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/remove_subscription" class="dashAnchor">&nbsp;</a><a href="#a87137037fcf21a6a1bcdf0cd3247c843">&#9670;&nbsp;</a></span>remove_subscription()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SynchronizationPolicy , class StoragePolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrclcpp_1_1WaitSetTemplate.html">rclcpp::WaitSetTemplate</a>&lt; SynchronizationPolicy, StoragePolicy &gt;::remove_subscription </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1SubscriptionBase.html">rclcpp::SubscriptionBase</a> &gt;&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1SubscriptionWaitSetMask.html">rclcpp::SubscriptionWaitSetMask</a>&#160;</td>
          <td class="paramname"><em>mask</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a subscription from this wait set. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#aa1021de92357096cb92ffbb1e79996a3" title="Remove a guard condition from this wait set.">remove_guard_condition()</a> for details of how this method works.</dd></dl>
<p>Additionally to the documentation for add_guard_condition, this method has a mask parameter which allows you to control which parts of the subscription is added to the wait set with this call. You may remove items selectively from the wait set in a different order than they were added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td><a class="el" href="classrclcpp_1_1Subscription.html" title="Subscription implementation, templated on the type of message this subscription receives.">Subscription</a> to be removed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>A class which controls which parts of the subscription to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if subscription is nullptr. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if subscription is not part of the wait set. </td></tr>
    <tr><td class="paramname">exceptions</td><td>based on the policies used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1773c9f262142c76657afbd290888e06"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/add_guard_condition" class="dashAnchor">&nbsp;</a><a href="#a1773c9f262142c76657afbd290888e06">&#9670;&nbsp;</a></span>add_guard_condition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SynchronizationPolicy , class StoragePolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrclcpp_1_1WaitSetTemplate.html">rclcpp::WaitSetTemplate</a>&lt; SynchronizationPolicy, StoragePolicy &gt;::add_guard_condition </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1GuardCondition.html">rclcpp::GuardCondition</a> &gt;&#160;</td>
          <td class="paramname"><em>guard_condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a guard condition to this wait set. </p>
<p>Guard condition is added to the wait set, and shared ownership is held while waiting. However, if between calls to <a class="el" href="classrclcpp_1_1WaitSetTemplate.html#a4a88a2709971a414409dde6839378f69" title="Wait for any of the entities in the wait set to be ready, or a period of time to pass.">wait()</a> the guard condition's reference count goes to zero, it will be implicitly removed on the next call to <a class="el" href="classrclcpp_1_1WaitSetTemplate.html#a4a88a2709971a414409dde6839378f69" title="Wait for any of the entities in the wait set to be ready, or a period of time to pass.">wait()</a>.</p>
<p>Except in the case of a fixed sized storage, where changes to the wait set cannot occur after construction, in which case it holds shared ownership at all times until the wait set is destroy, but this method also does not exist on a fixed sized wait set.</p>
<p>This function may be thread-safe depending on the SynchronizationPolicy used with this class. Using the ThreadSafeWaitSetPolicy will ensure that <a class="el" href="classrclcpp_1_1WaitSetTemplate.html#a4a88a2709971a414409dde6839378f69" title="Wait for any of the entities in the wait set to be ready, or a period of time to pass.">wait()</a> is interrupted and returns before this function adds the guard condition. Otherwise, it is not safe to call this function concurrently with <a class="el" href="classrclcpp_1_1WaitSetTemplate.html#a4a88a2709971a414409dde6839378f69" title="Wait for any of the entities in the wait set to be ready, or a period of time to pass.">wait()</a>.</p>
<p>This function will not be enabled (will not be available) if the StoragePolicy does not allow editing of the wait set after initialization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">guard_condition</td><td>Guard condition to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if guard_condition is nullptr. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if guard_condition has already been added or is associated with another wait set. </td></tr>
    <tr><td class="paramname">exceptions</td><td>based on the policies used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1021de92357096cb92ffbb1e79996a3"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/remove_guard_condition" class="dashAnchor">&nbsp;</a><a href="#aa1021de92357096cb92ffbb1e79996a3">&#9670;&nbsp;</a></span>remove_guard_condition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SynchronizationPolicy , class StoragePolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrclcpp_1_1WaitSetTemplate.html">rclcpp::WaitSetTemplate</a>&lt; SynchronizationPolicy, StoragePolicy &gt;::remove_guard_condition </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1GuardCondition.html">rclcpp::GuardCondition</a> &gt;&#160;</td>
          <td class="paramname"><em>guard_condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a guard condition from this wait set. </p>
<p>Guard condition is removed from the wait set, and if needed the shared ownership is released.</p>
<p>This function may be thread-safe depending on the SynchronizationPolicy used with this class. Using the ThreadSafeWaitSetPolicy will ensure that <a class="el" href="classrclcpp_1_1WaitSetTemplate.html#a4a88a2709971a414409dde6839378f69" title="Wait for any of the entities in the wait set to be ready, or a period of time to pass.">wait()</a> is interrupted and returns before this function removes the guard condition. Otherwise, it is not safe to call this function concurrently with <a class="el" href="classrclcpp_1_1WaitSetTemplate.html#a4a88a2709971a414409dde6839378f69" title="Wait for any of the entities in the wait set to be ready, or a period of time to pass.">wait()</a>.</p>
<p>This function will not be enabled (will not be available) if the StoragePolicy does not allow editing of the wait set after initialization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">guard_condition</td><td>Guard condition to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if guard_condition is nullptr. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if guard_condition is not part of the wait set. </td></tr>
    <tr><td class="paramname">exceptions</td><td>based on the policies used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc813b4cb6f18dd707269097acec26e7"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/add_timer" class="dashAnchor">&nbsp;</a><a href="#acc813b4cb6f18dd707269097acec26e7">&#9670;&nbsp;</a></span>add_timer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SynchronizationPolicy , class StoragePolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrclcpp_1_1WaitSetTemplate.html">rclcpp::WaitSetTemplate</a>&lt; SynchronizationPolicy, StoragePolicy &gt;::add_timer </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1TimerBase.html">rclcpp::TimerBase</a> &gt;&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a timer to this wait set. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#a1773c9f262142c76657afbd290888e06" title="Add a guard condition to this wait set.">add_guard_condition()</a> for details of how this method works.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>Timer to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if timer is nullptr. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if timer has already been added or is associated with another wait set. </td></tr>
    <tr><td class="paramname">exceptions</td><td>based on the policies used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3cef3f62dc2c7412c9e530ee48f8376"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/remove_timer" class="dashAnchor">&nbsp;</a><a href="#aa3cef3f62dc2c7412c9e530ee48f8376">&#9670;&nbsp;</a></span>remove_timer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SynchronizationPolicy , class StoragePolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrclcpp_1_1WaitSetTemplate.html">rclcpp::WaitSetTemplate</a>&lt; SynchronizationPolicy, StoragePolicy &gt;::remove_timer </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1TimerBase.html">rclcpp::TimerBase</a> &gt;&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a timer from this wait set. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#aa1021de92357096cb92ffbb1e79996a3" title="Remove a guard condition from this wait set.">remove_guard_condition()</a> for details of how this method works.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>Timer to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if timer is nullptr. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if timer is not part of the wait set. </td></tr>
    <tr><td class="paramname">exceptions</td><td>based on the policies used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9669ab3069967f0972d48d2fefee8bcb"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/add_client" class="dashAnchor">&nbsp;</a><a href="#a9669ab3069967f0972d48d2fefee8bcb">&#9670;&nbsp;</a></span>add_client()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SynchronizationPolicy , class StoragePolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrclcpp_1_1WaitSetTemplate.html">rclcpp::WaitSetTemplate</a>&lt; SynchronizationPolicy, StoragePolicy &gt;::add_client </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1ClientBase.html">rclcpp::ClientBase</a> &gt;&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a client to this wait set. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#a1773c9f262142c76657afbd290888e06" title="Add a guard condition to this wait set.">add_guard_condition()</a> for details of how this method works.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">client</td><td><a class="el" href="classrclcpp_1_1Client.html">Client</a> to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if client is nullptr. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if client has already been added or is associated with another wait set. </td></tr>
    <tr><td class="paramname">exceptions</td><td>based on the policies used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50bb31d6746db9fcc530d26288b59366"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/remove_client" class="dashAnchor">&nbsp;</a><a href="#a50bb31d6746db9fcc530d26288b59366">&#9670;&nbsp;</a></span>remove_client()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SynchronizationPolicy , class StoragePolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrclcpp_1_1WaitSetTemplate.html">rclcpp::WaitSetTemplate</a>&lt; SynchronizationPolicy, StoragePolicy &gt;::remove_client </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1ClientBase.html">rclcpp::ClientBase</a> &gt;&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a client from this wait set. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#aa1021de92357096cb92ffbb1e79996a3" title="Remove a guard condition from this wait set.">remove_guard_condition()</a> for details of how this method works.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">client</td><td><a class="el" href="classrclcpp_1_1Client.html">Client</a> to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if client is nullptr. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if client is not part of the wait set. </td></tr>
    <tr><td class="paramname">exceptions</td><td>based on the policies used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36acee7f542fc5c58fa7064ab4fd55b0"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/add_service" class="dashAnchor">&nbsp;</a><a href="#a36acee7f542fc5c58fa7064ab4fd55b0">&#9670;&nbsp;</a></span>add_service()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SynchronizationPolicy , class StoragePolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrclcpp_1_1WaitSetTemplate.html">rclcpp::WaitSetTemplate</a>&lt; SynchronizationPolicy, StoragePolicy &gt;::add_service </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1ServiceBase.html">rclcpp::ServiceBase</a> &gt;&#160;</td>
          <td class="paramname"><em>service</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a service to this wait set. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#a1773c9f262142c76657afbd290888e06" title="Add a guard condition to this wait set.">add_guard_condition()</a> for details of how this method works.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">service</td><td><a class="el" href="classrclcpp_1_1Service.html">Service</a> to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if service is nullptr. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if service has already been added or is associated with another wait set. </td></tr>
    <tr><td class="paramname">exceptions</td><td>based on the policies used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada4d08ac5c17cebf9b9fb8d4a7e92bcd"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/remove_service" class="dashAnchor">&nbsp;</a><a href="#ada4d08ac5c17cebf9b9fb8d4a7e92bcd">&#9670;&nbsp;</a></span>remove_service()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SynchronizationPolicy , class StoragePolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrclcpp_1_1WaitSetTemplate.html">rclcpp::WaitSetTemplate</a>&lt; SynchronizationPolicy, StoragePolicy &gt;::remove_service </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1ServiceBase.html">rclcpp::ServiceBase</a> &gt;&#160;</td>
          <td class="paramname"><em>service</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a service from this wait set. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#aa1021de92357096cb92ffbb1e79996a3" title="Remove a guard condition from this wait set.">remove_guard_condition()</a> for details of how this method works.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">service</td><td><a class="el" href="classrclcpp_1_1Service.html">Service</a> to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if service is nullptr. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if service is not part of the wait set. </td></tr>
    <tr><td class="paramname">exceptions</td><td>based on the policies used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a636ab1de60af6d9659ffa60fa4a700fb"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/add_waitable" class="dashAnchor">&nbsp;</a><a href="#a636ab1de60af6d9659ffa60fa4a700fb">&#9670;&nbsp;</a></span>add_waitable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SynchronizationPolicy , class StoragePolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrclcpp_1_1WaitSetTemplate.html">rclcpp::WaitSetTemplate</a>&lt; SynchronizationPolicy, StoragePolicy &gt;::add_waitable </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1Waitable.html">rclcpp::Waitable</a> &gt;&#160;</td>
          <td class="paramname"><em>waitable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; void &gt;&#160;</td>
          <td class="paramname"><em>associated_entity</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a waitable to this wait set. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#a1773c9f262142c76657afbd290888e06" title="Add a guard condition to this wait set.">add_guard_condition()</a> for details of how this method works.</dd></dl>
<p>Additionally, this function has an optional parameter which can be used to more quickly associate this waitable with an entity when it is ready, and so that the ownership maybe held in order to keep the waitable's parent in scope while waiting. If it is set to nullptr it will be ignored. The destruction of the associated entity's shared pointer will not cause the waitable to be removed, but it will cause the associated entity pointer to be nullptr when introspecting this waitable after waiting.</p>
<p>Note that <a class="el" href="classrclcpp_1_1QOSEventHandlerBase.html">rclcpp::QOSEventHandlerBase</a> are just a special case of <a class="el" href="classrclcpp_1_1Waitable.html">rclcpp::Waitable</a> and can be added with this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">waitable</td><td><a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">associated_entity</td><td>Type erased shared pointer associated with the waitable. This may be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if waitable is nullptr. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if waitable has already been added or is associated with another wait set. </td></tr>
    <tr><td class="paramname">exceptions</td><td>based on the policies used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22120ae19bd980fc1029b233be72f2ff"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/remove_waitable" class="dashAnchor">&nbsp;</a><a href="#a22120ae19bd980fc1029b233be72f2ff">&#9670;&nbsp;</a></span>remove_waitable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SynchronizationPolicy , class StoragePolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrclcpp_1_1WaitSetTemplate.html">rclcpp::WaitSetTemplate</a>&lt; SynchronizationPolicy, StoragePolicy &gt;::remove_waitable </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1Waitable.html">rclcpp::Waitable</a> &gt;&#160;</td>
          <td class="paramname"><em>waitable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a waitable from this wait set. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1WaitSetTemplate.html#aa1021de92357096cb92ffbb1e79996a3" title="Remove a guard condition from this wait set.">remove_guard_condition()</a> for details of how this method works.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">waitable</td><td><a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if waitable is nullptr. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if waitable is not part of the wait set. </td></tr>
    <tr><td class="paramname">exceptions</td><td>based on the policies used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a090483821f8ebb4f45f3d20ee41fe182"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/prune_deleted_entities" class="dashAnchor">&nbsp;</a><a href="#a090483821f8ebb4f45f3d20ee41fe182">&#9670;&nbsp;</a></span>prune_deleted_entities()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SynchronizationPolicy , class StoragePolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrclcpp_1_1WaitSetTemplate.html">rclcpp::WaitSetTemplate</a>&lt; SynchronizationPolicy, StoragePolicy &gt;::prune_deleted_entities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove any destroyed entities from the wait set. </p>
<p>When the storage policy does not maintain shared ownership for the life of the wait set, e.g. the DynamicStorage policy, it is possible for an entity to go out of scope and be deleted without this wait set noticing. Therefore there are weak references in this wait set which need to be periodically cleared. This function performs that clean up.</p>
<p>Since this involves removing entities from the wait set, and is only needed if the wait set does not keep ownership of the added entities, the storage policies which are static will not need this function and therefore do not provide this function.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exceptions</td><td>based on the policies used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a88a2709971a414409dde6839378f69"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/wait" class="dashAnchor">&nbsp;</a><a href="#a4a88a2709971a414409dde6839378f69">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SynchronizationPolicy , class StoragePolicy &gt; </div>
<div class="memtemplate">
template&lt;class Rep  = int64_t, class Period  = std::milli&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1WaitResult.html">WaitResult</a>&lt;<a class="el" href="classrclcpp_1_1WaitSetTemplate.html">WaitSetTemplate</a>&gt; <a class="el" href="classrclcpp_1_1WaitSetTemplate.html">rclcpp::WaitSetTemplate</a>&lt; SynchronizationPolicy, StoragePolicy &gt;::wait </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt;&#160;</td>
          <td class="paramname"><em>time_to_wait</em> = <code>std::chrono::duration&lt;Rep,&#160;Period&gt;(-1)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for any of the entities in the wait set to be ready, or a period of time to pass. </p>
<p>This function will return when either one of the entities within this wait set is ready, or a period of time has passed, which ever is first. The term "ready" means different things for different entities, but generally it means some condition is met asynchronously for which this function waits.</p>
<p>This function can either wait for a period of time, do no waiting (non-blocking), or wait indefinitely, all based on the value of the time_to_wait parameter. Waiting is always measured against the std::chrono::steady_clock. If waiting indefinitely, the Timeout result is not possible. There is no "cancel wait" function on this class, but if you want to wait indefinitely but have a way to asynchronously interrupt this method, then you can use a dedicated <a class="el" href="classrclcpp_1_1GuardCondition.html" title="A condition that can be waited on in a single wait set and asynchronously triggered.">rclcpp::GuardCondition</a> for that purpose.</p>
<p>This function will modify the internal rcl_wait_set_t, so introspecting the wait set during a call to wait is never safe. You should always wait, then introspect, and then, only when done introspecting, wait again.</p>
<p>It may be thread-safe to add and remove entities to the wait set concurrently with this function, depending on the SynchronizationPolicy that is used. With the <a class="el" href="classrclcpp_1_1wait__set__policies_1_1ThreadSafeSynchronization.html" title="WaitSet policy that provides thread-safe synchronization for the wait set.">rclcpp::wait_set_policies::ThreadSafeSynchronization</a> policy this function will stop waiting to allow add or remove of an entity, and then resume waiting, so long as the timeout has not been reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time_to_wait</td><td>If &gt; 0, time to wait for entities to be ready, if == 0, check if anything is ready without blocking, or if &lt; 0, wait indefinitely until one of the items is ready. Default is -1, so wait indefinitely. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Ready when one of the entities is ready, or </dd>
<dd>
Timeout when the given time to wait is exceeded, not possible when time_to_wait is &lt; 0, or </dd>
<dd>
Empty if the wait set is empty, avoiding the possibility of waiting indefinitely on an empty wait set. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1exceptions_1_1RCLError.html" title="Created when the return code does not match one of the other specialized exceptions.">rclcpp::exceptions::RCLError</a></td><td>on unhandled rcl errors or, </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if unknown WaitResultKind </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/rclcpp/<a class="el" href="wait__set__template_8hpp_source.html">wait_set_template.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
