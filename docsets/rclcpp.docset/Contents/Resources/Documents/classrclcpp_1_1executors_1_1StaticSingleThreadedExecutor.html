<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rclcpp: rclcpp::executors::StaticSingleThreadedExecutor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rclcpp
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C++ ROS Client Library API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerclcpp.html">rclcpp</a></li><li class="navelem"><a class="el" href="namespacerclcpp_1_1executors.html">executors</a></li><li class="navelem"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html">StaticSingleThreadedExecutor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rclcpp::executors::StaticSingleThreadedExecutor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Static executor implementation.  
 <a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="static__single__threaded__executor_8hpp_source.html">static_single_threaded_executor.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rclcpp::executors::StaticSingleThreadedExecutor:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor__inherit__graph.png" border="0" usemap="#arclcpp_1_1executors_1_1StaticSingleThreadedExecutor_inherit__map" alt="Inheritance graph"/></div>
<map name="arclcpp_1_1executors_1_1StaticSingleThreadedExecutor_inherit__map" id="arclcpp_1_1executors_1_1StaticSingleThreadedExecutor_inherit__map">
<area shape="rect" title="Static executor implementation." alt="" coords="5,80,221,121"/>
<area shape="rect" href="classrclcpp_1_1Executor.html" title="Coordinate the order and timing of available communication tasks." alt="" coords="51,5,176,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for rclcpp::executors::StaticSingleThreadedExecutor:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor__coll__graph.png" border="0" usemap="#arclcpp_1_1executors_1_1StaticSingleThreadedExecutor_coll__map" alt="Collaboration graph"/></div>
<map name="arclcpp_1_1executors_1_1StaticSingleThreadedExecutor_coll__map" id="arclcpp_1_1executors_1_1StaticSingleThreadedExecutor_coll__map">
<area shape="rect" title="Static executor implementation." alt="" coords="87,185,303,227"/>
<area shape="rect" href="classrclcpp_1_1Executor.html" title="Coordinate the order and timing of available communication tasks." alt="" coords="132,109,257,136"/>
<area shape="rect" href="classrclcpp_1_1GuardCondition.html" title="A condition that can be waited on in a single wait set and asynchronously triggered." alt="" coords="5,13,176,39"/>
<area shape="rect" href="classrclcpp_1_1ShutdownCallbackHandle.html" title=" " alt="" coords="205,5,395,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6ee69a543c46f731a74a8d33fe6bf3e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a6ee69a543c46f731a74a8d33fe6bf3e5">StaticSingleThreadedExecutor</a> (const <a class="el" href="structrclcpp_1_1ExecutorOptions.html">rclcpp::ExecutorOptions</a> &amp;options=<a class="el" href="structrclcpp_1_1ExecutorOptions.html">rclcpp::ExecutorOptions</a>())</td></tr>
<tr class="memdesc:a6ee69a543c46f731a74a8d33fe6bf3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. See the default constructor for <a class="el" href="classrclcpp_1_1Executor.html" title="Coordinate the order and timing of available communication tasks.">Executor</a>.  <a name="//apple_ref/cpp/Method/StaticSingleThreadedExecutor" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a6ee69a543c46f731a74a8d33fe6bf3e5">More...</a><br /></td></tr>
<tr class="separator:a6ee69a543c46f731a74a8d33fe6bf3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfba5ffd5adf68e26137f49a8587ad9e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#acfba5ffd5adf68e26137f49a8587ad9e">~StaticSingleThreadedExecutor</a> ()</td></tr>
<tr class="memdesc:acfba5ffd5adf68e26137f49a8587ad9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destrcutor.  <a name="//apple_ref/cpp/Method/~StaticSingleThreadedExecutor" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#acfba5ffd5adf68e26137f49a8587ad9e">More...</a><br /></td></tr>
<tr class="separator:acfba5ffd5adf68e26137f49a8587ad9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cec9027c4c69e49a6e15398f01b7c47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a1cec9027c4c69e49a6e15398f01b7c47">spin</a> () override</td></tr>
<tr class="memdesc:a1cec9027c4c69e49a6e15398f01b7c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static executor implementation of spin.  <a name="//apple_ref/cpp/Method/spin" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a1cec9027c4c69e49a6e15398f01b7c47">More...</a><br /></td></tr>
<tr class="separator:a1cec9027c4c69e49a6e15398f01b7c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38723cc9e16bddd7b4be5400c3125a99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a38723cc9e16bddd7b4be5400c3125a99">spin_some</a> (std::chrono::nanoseconds max_duration=std::chrono::nanoseconds(0)) override</td></tr>
<tr class="memdesc:a38723cc9e16bddd7b4be5400c3125a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static executor implementation of spin some.  <a name="//apple_ref/cpp/Method/spin_some" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a38723cc9e16bddd7b4be5400c3125a99">More...</a><br /></td></tr>
<tr class="separator:a38723cc9e16bddd7b4be5400c3125a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642edbabbbe955174256300db23b25fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a642edbabbbe955174256300db23b25fc">spin_all</a> (std::chrono::nanoseconds max_duration) override</td></tr>
<tr class="memdesc:a642edbabbbe955174256300db23b25fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static executor implementation of spin all.  <a name="//apple_ref/cpp/Method/spin_all" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a642edbabbbe955174256300db23b25fc">More...</a><br /></td></tr>
<tr class="separator:a642edbabbbe955174256300db23b25fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7641a44b0e95911a08c9961f7cd6963c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a7641a44b0e95911a08c9961f7cd6963c">add_callback_group</a> (rclcpp::CallbackGroup::SharedPtr group_ptr, rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr, bool notify=true) override</td></tr>
<tr class="memdesc:a7641a44b0e95911a08c9961f7cd6963c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a callback group to an executor.  <a name="//apple_ref/cpp/Method/add_callback_group" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a7641a44b0e95911a08c9961f7cd6963c">More...</a><br /></td></tr>
<tr class="separator:a7641a44b0e95911a08c9961f7cd6963c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5142581ba7090734726cf6c471d084e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#ac5142581ba7090734726cf6c471d084e">remove_callback_group</a> (rclcpp::CallbackGroup::SharedPtr group_ptr, bool notify=true) override</td></tr>
<tr class="memdesc:ac5142581ba7090734726cf6c471d084e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove callback group from the executor.  <a name="//apple_ref/cpp/Method/remove_callback_group" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#ac5142581ba7090734726cf6c471d084e">More...</a><br /></td></tr>
<tr class="separator:ac5142581ba7090734726cf6c471d084e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c04102c89554658c021dceb1555af2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a5c04102c89554658c021dceb1555af2f">add_node</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr, bool notify=true) override</td></tr>
<tr class="memdesc:a5c04102c89554658c021dceb1555af2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node to the executor.  <a name="//apple_ref/cpp/Method/add_node" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a5c04102c89554658c021dceb1555af2f">More...</a><br /></td></tr>
<tr class="separator:a5c04102c89554658c021dceb1555af2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc40d425a0b14000dcec22b93a5ba194"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#acc40d425a0b14000dcec22b93a5ba194">add_node</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1Node.html">rclcpp::Node</a> &gt; node_ptr, bool notify=true) override</td></tr>
<tr class="memdesc:acc40d425a0b14000dcec22b93a5ba194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface.  <a name="//apple_ref/cpp/Method/add_node" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#acc40d425a0b14000dcec22b93a5ba194">More...</a><br /></td></tr>
<tr class="separator:acc40d425a0b14000dcec22b93a5ba194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c159ea2f81661d52b06b1e8a4edbd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#ad0c159ea2f81661d52b06b1e8a4edbd0">remove_node</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr, bool notify=true) override</td></tr>
<tr class="memdesc:ad0c159ea2f81661d52b06b1e8a4edbd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a node from the executor.  <a name="//apple_ref/cpp/Method/remove_node" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#ad0c159ea2f81661d52b06b1e8a4edbd0">More...</a><br /></td></tr>
<tr class="separator:ad0c159ea2f81661d52b06b1e8a4edbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9578b4ab98dda3b6493d35b87c302af4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a9578b4ab98dda3b6493d35b87c302af4">remove_node</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1Node.html">rclcpp::Node</a> &gt; node_ptr, bool notify=true) override</td></tr>
<tr class="memdesc:a9578b4ab98dda3b6493d35b87c302af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface.  <a name="//apple_ref/cpp/Method/remove_node" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a9578b4ab98dda3b6493d35b87c302af4">More...</a><br /></td></tr>
<tr class="separator:a9578b4ab98dda3b6493d35b87c302af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90eebd217c5102fb470508f3ad9698a7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; rclcpp::CallbackGroup::WeakPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a90eebd217c5102fb470508f3ad9698a7">get_all_callback_groups</a> () override</td></tr>
<tr class="memdesc:a90eebd217c5102fb470508f3ad9698a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get callback groups that belong to executor.  <a name="//apple_ref/cpp/Method/get_all_callback_groups" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a90eebd217c5102fb470508f3ad9698a7">More...</a><br /></td></tr>
<tr class="separator:a90eebd217c5102fb470508f3ad9698a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0584c4a5c8a34c6e4b9d649174e64d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; rclcpp::CallbackGroup::WeakPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#abe0584c4a5c8a34c6e4b9d649174e64d">get_manually_added_callback_groups</a> () override</td></tr>
<tr class="memdesc:abe0584c4a5c8a34c6e4b9d649174e64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get callback groups that belong to executor.  <a name="//apple_ref/cpp/Method/get_manually_added_callback_groups" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#abe0584c4a5c8a34c6e4b9d649174e64d">More...</a><br /></td></tr>
<tr class="separator:abe0584c4a5c8a34c6e4b9d649174e64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28350f023e1e9ac738557000eb70ac8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; rclcpp::CallbackGroup::WeakPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#ab28350f023e1e9ac738557000eb70ac8">get_automatically_added_callback_groups_from_nodes</a> () override</td></tr>
<tr class="memdesc:ab28350f023e1e9ac738557000eb70ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get callback groups that belong to executor.  <a name="//apple_ref/cpp/Method/get_automatically_added_callback_groups_from_nodes" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#ab28350f023e1e9ac738557000eb70ac8">More...</a><br /></td></tr>
<tr class="separator:ab28350f023e1e9ac738557000eb70ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classrclcpp_1_1Executor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrclcpp_1_1Executor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classrclcpp_1_1Executor.html">rclcpp::Executor</a></td></tr>
<tr class="memitem:a3d28d13a7233751c9b7b023528f10228 inherit pub_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a3d28d13a7233751c9b7b023528f10228">Executor</a> (const <a class="el" href="structrclcpp_1_1ExecutorOptions.html">rclcpp::ExecutorOptions</a> &amp;options=<a class="el" href="structrclcpp_1_1ExecutorOptions.html">rclcpp::ExecutorOptions</a>())</td></tr>
<tr class="memdesc:a3d28d13a7233751c9b7b023528f10228 inherit pub_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classrclcpp_1_1Executor.html#a3d28d13a7233751c9b7b023528f10228">More...</a><br /></td></tr>
<tr class="separator:a3d28d13a7233751c9b7b023528f10228 inherit pub_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946f5bfe58cb0ee5f52a98455248ed66 inherit pub_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a946f5bfe58cb0ee5f52a98455248ed66">~Executor</a> ()</td></tr>
<tr class="memdesc:a946f5bfe58cb0ee5f52a98455248ed66 inherit pub_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="classrclcpp_1_1Executor.html#a946f5bfe58cb0ee5f52a98455248ed66">More...</a><br /></td></tr>
<tr class="separator:a946f5bfe58cb0ee5f52a98455248ed66 inherit pub_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09dd5b81cc174fd7029fab65a726db9 inherit pub_methods_classrclcpp_1_1Executor"><td class="memTemplParams" colspan="2">template&lt;typename RepT  = int64_t, typename T  = std::milli&gt; </td></tr>
<tr class="memitem:af09dd5b81cc174fd7029fab65a726db9 inherit pub_methods_classrclcpp_1_1Executor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#af09dd5b81cc174fd7029fab65a726db9">spin_node_once</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node, std::chrono::duration&lt; RepT, T &gt; timeout=std::chrono::duration&lt; RepT, T &gt;(-1))</td></tr>
<tr class="memdesc:af09dd5b81cc174fd7029fab65a726db9 inherit pub_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node to executor, execute the next available unit of work, and remove the node.  <a href="classrclcpp_1_1Executor.html#af09dd5b81cc174fd7029fab65a726db9">More...</a><br /></td></tr>
<tr class="separator:af09dd5b81cc174fd7029fab65a726db9 inherit pub_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9791fd5812f06add439c9cca86d6226b inherit pub_methods_classrclcpp_1_1Executor"><td class="memTemplParams" colspan="2">template&lt;typename NodeT  = rclcpp::Node, typename RepT  = int64_t, typename T  = std::milli&gt; </td></tr>
<tr class="memitem:a9791fd5812f06add439c9cca86d6226b inherit pub_methods_classrclcpp_1_1Executor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a9791fd5812f06add439c9cca86d6226b">spin_node_once</a> (std::shared_ptr&lt; NodeT &gt; node, std::chrono::duration&lt; RepT, T &gt; timeout=std::chrono::duration&lt; RepT, T &gt;(-1))</td></tr>
<tr class="memdesc:a9791fd5812f06add439c9cca86d6226b inherit pub_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface.  <a href="classrclcpp_1_1Executor.html#a9791fd5812f06add439c9cca86d6226b">More...</a><br /></td></tr>
<tr class="separator:a9791fd5812f06add439c9cca86d6226b inherit pub_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49780b2217485638b0d7be720062e630 inherit pub_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a49780b2217485638b0d7be720062e630">spin_node_some</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node)</td></tr>
<tr class="memdesc:a49780b2217485638b0d7be720062e630 inherit pub_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node, complete all immediately available work, and remove the node.  <a href="classrclcpp_1_1Executor.html#a49780b2217485638b0d7be720062e630">More...</a><br /></td></tr>
<tr class="separator:a49780b2217485638b0d7be720062e630 inherit pub_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8f89d67464b75cfc63f1ddf56f8850 inherit pub_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a9c8f89d67464b75cfc63f1ddf56f8850">spin_node_some</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1Node.html">rclcpp::Node</a> &gt; node)</td></tr>
<tr class="memdesc:a9c8f89d67464b75cfc63f1ddf56f8850 inherit pub_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface.  <a href="classrclcpp_1_1Executor.html#a9c8f89d67464b75cfc63f1ddf56f8850">More...</a><br /></td></tr>
<tr class="separator:a9c8f89d67464b75cfc63f1ddf56f8850 inherit pub_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4abb57eea7e1b6c95acc0e7abff62b2 inherit pub_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ae4abb57eea7e1b6c95acc0e7abff62b2">spin_once</a> (std::chrono::nanoseconds timeout=std::chrono::nanoseconds(-1))</td></tr>
<tr class="separator:ae4abb57eea7e1b6c95acc0e7abff62b2 inherit pub_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a0c374568aae53dcca63eb29086327 inherit pub_methods_classrclcpp_1_1Executor"><td class="memTemplParams" colspan="2">template&lt;typename FutureT , typename TimeRepT  = int64_t, typename TimeT  = std::milli&gt; </td></tr>
<tr class="memitem:a39a0c374568aae53dcca63eb29086327 inherit pub_methods_classrclcpp_1_1Executor"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacerclcpp.html#a7b4ff5f1e516740d7e11ea97fe6f5532">FutureReturnCode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a39a0c374568aae53dcca63eb29086327">spin_until_future_complete</a> (const FutureT &amp;future, std::chrono::duration&lt; TimeRepT, TimeT &gt; timeout=std::chrono::duration&lt; TimeRepT, TimeT &gt;(-1))</td></tr>
<tr class="memdesc:a39a0c374568aae53dcca63eb29086327 inherit pub_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spin (blocking) until the future is complete, it times out waiting, or rclcpp is interrupted.  <a href="classrclcpp_1_1Executor.html#a39a0c374568aae53dcca63eb29086327">More...</a><br /></td></tr>
<tr class="separator:a39a0c374568aae53dcca63eb29086327 inherit pub_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb21996107bcf4e62f8330e8d201e70 inherit pub_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a0fb21996107bcf4e62f8330e8d201e70">cancel</a> ()</td></tr>
<tr class="memdesc:a0fb21996107bcf4e62f8330e8d201e70 inherit pub_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel any running spin* function, causing it to return.  <a href="classrclcpp_1_1Executor.html#a0fb21996107bcf4e62f8330e8d201e70">More...</a><br /></td></tr>
<tr class="separator:a0fb21996107bcf4e62f8330e8d201e70 inherit pub_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41ca2b0358c875337ac13a8130987e9 inherit pub_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#aa41ca2b0358c875337ac13a8130987e9">set_memory_strategy</a> (memory_strategy::MemoryStrategy::SharedPtr memory_strategy)</td></tr>
<tr class="memdesc:aa41ca2b0358c875337ac13a8130987e9 inherit pub_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support dynamic switching of the memory strategy.  <a href="classrclcpp_1_1Executor.html#aa41ca2b0358c875337ac13a8130987e9">More...</a><br /></td></tr>
<tr class="separator:aa41ca2b0358c875337ac13a8130987e9 inherit pub_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476430345b9c7f2820290f272d2ef78f inherit pub_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a476430345b9c7f2820290f272d2ef78f">is_spinning</a> ()</td></tr>
<tr class="memdesc:a476430345b9c7f2820290f272d2ef78f inherit pub_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the executor is currently spinning.  <a href="classrclcpp_1_1Executor.html#a476430345b9c7f2820290f272d2ef78f">More...</a><br /></td></tr>
<tr class="separator:a476430345b9c7f2820290f272d2ef78f inherit pub_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae4b27be117016dcc6e1b98124b41e0d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#ae4b27be117016dcc6e1b98124b41e0d3">execute_ready_executables</a> (bool <a class="el" href="classrclcpp_1_1Executor.html#ae4abb57eea7e1b6c95acc0e7abff62b2">spin_once</a>=false)</td></tr>
<tr class="memdesc:ae4b27be117016dcc6e1b98124b41e0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes ready executables from wait set.  <a name="//apple_ref/cpp/Method/execute_ready_executables" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#ae4b27be117016dcc6e1b98124b41e0d3">More...</a><br /></td></tr>
<tr class="separator:ae4b27be117016dcc6e1b98124b41e0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80fffc6734a60b03eca5763e32a84b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#af80fffc6734a60b03eca5763e32a84b6">spin_some_impl</a> (std::chrono::nanoseconds max_duration, bool exhaustive)</td></tr>
<tr class="separator:af80fffc6734a60b03eca5763e32a84b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2a7699ba52bb2d6a8323b36ad858dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a4e2a7699ba52bb2d6a8323b36ad858dc">spin_once_impl</a> (std::chrono::nanoseconds timeout) override</td></tr>
<tr class="separator:a4e2a7699ba52bb2d6a8323b36ad858dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classrclcpp_1_1Executor"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classrclcpp_1_1Executor')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classrclcpp_1_1Executor.html">rclcpp::Executor</a></td></tr>
<tr class="memitem:a562cd027f960258673a737c9e8d3be75 inherit pro_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a562cd027f960258673a737c9e8d3be75">spin_node_once_nanoseconds</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node, std::chrono::nanoseconds timeout)</td></tr>
<tr class="separator:a562cd027f960258673a737c9e8d3be75 inherit pro_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdf3b5fb2a673346f45feed75a7cd11 inherit pro_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a4cdf3b5fb2a673346f45feed75a7cd11">spin_some_impl</a> (std::chrono::nanoseconds max_duration, bool exhaustive)</td></tr>
<tr class="separator:a4cdf3b5fb2a673346f45feed75a7cd11 inherit pro_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915f4738cf48d6c08851be8264aad58d inherit pro_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a915f4738cf48d6c08851be8264aad58d">execute_any_executable</a> (<a class="el" href="structrclcpp_1_1AnyExecutable.html">AnyExecutable</a> &amp;any_exec)</td></tr>
<tr class="memdesc:a915f4738cf48d6c08851be8264aad58d inherit pro_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the next available executable and do the work associated with it.  <a href="classrclcpp_1_1Executor.html#a915f4738cf48d6c08851be8264aad58d">More...</a><br /></td></tr>
<tr class="separator:a915f4738cf48d6c08851be8264aad58d inherit pro_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af211465e15ae5b13bac0893ef9e0ed4e inherit pro_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#af211465e15ae5b13bac0893ef9e0ed4e">wait_for_work</a> (std::chrono::nanoseconds timeout=std::chrono::nanoseconds(-1))</td></tr>
<tr class="separator:af211465e15ae5b13bac0893ef9e0ed4e inherit pro_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4878997d1aba3efea583f307a22faa5 inherit pro_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#aa4878997d1aba3efea583f307a22faa5">get_node_by_group</a> (const <a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a> &amp;weak_groups_to_nodes, rclcpp::CallbackGroup::SharedPtr group)</td></tr>
<tr class="separator:aa4878997d1aba3efea583f307a22faa5 inherit pro_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552c54e50b71e3432366e15ef0536fef inherit pro_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a552c54e50b71e3432366e15ef0536fef">has_node</a> (const rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr, const <a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a> &amp;weak_groups_to_nodes) const</td></tr>
<tr class="memdesc:a552c54e50b71e3432366e15ef0536fef inherit pro_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the node has been added to this executor.  <a href="classrclcpp_1_1Executor.html#a552c54e50b71e3432366e15ef0536fef">More...</a><br /></td></tr>
<tr class="separator:a552c54e50b71e3432366e15ef0536fef inherit pro_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06baded5884fc91e6d36ab676f0b7fc3 inherit pro_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">rclcpp::CallbackGroup::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a06baded5884fc91e6d36ab676f0b7fc3">get_group_by_timer</a> (rclcpp::TimerBase::SharedPtr timer)</td></tr>
<tr class="separator:a06baded5884fc91e6d36ab676f0b7fc3 inherit pro_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e030d927aa29b42d44f9c51a5335325 inherit pro_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a2e030d927aa29b42d44f9c51a5335325">add_callback_group_to_map</a> (rclcpp::CallbackGroup::SharedPtr group_ptr, rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr, <a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a> &amp;weak_groups_to_nodes, bool notify=true)</td></tr>
<tr class="memdesc:a2e030d927aa29b42d44f9c51a5335325 inherit pro_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a callback group to an executor.  <a href="classrclcpp_1_1Executor.html#a2e030d927aa29b42d44f9c51a5335325">More...</a><br /></td></tr>
<tr class="separator:a2e030d927aa29b42d44f9c51a5335325 inherit pro_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da65b29b968aa503df2df3eef091185 inherit pro_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a9da65b29b968aa503df2df3eef091185">remove_callback_group_from_map</a> (rclcpp::CallbackGroup::SharedPtr group_ptr, <a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a> &amp;weak_groups_to_nodes, bool notify=true)</td></tr>
<tr class="memdesc:a9da65b29b968aa503df2df3eef091185 inherit pro_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a callback group from the executor.  <a href="classrclcpp_1_1Executor.html#a9da65b29b968aa503df2df3eef091185">More...</a><br /></td></tr>
<tr class="separator:a9da65b29b968aa503df2df3eef091185 inherit pro_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3c92aec4730186388701398c84263b inherit pro_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#aad3c92aec4730186388701398c84263b">get_next_ready_executable</a> (<a class="el" href="structrclcpp_1_1AnyExecutable.html">AnyExecutable</a> &amp;any_executable)</td></tr>
<tr class="separator:aad3c92aec4730186388701398c84263b inherit pro_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e9721d4751ca0bd2b0faa1c9403255 inherit pro_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a36e9721d4751ca0bd2b0faa1c9403255">get_next_ready_executable_from_map</a> (<a class="el" href="structrclcpp_1_1AnyExecutable.html">AnyExecutable</a> &amp;any_executable, const <a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a> &amp;weak_groups_to_nodes)</td></tr>
<tr class="separator:a36e9721d4751ca0bd2b0faa1c9403255 inherit pro_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b530d7459b579ca22044a5e7a37a50 inherit pro_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a63b530d7459b579ca22044a5e7a37a50">get_next_executable</a> (<a class="el" href="structrclcpp_1_1AnyExecutable.html">AnyExecutable</a> &amp;any_executable, std::chrono::nanoseconds timeout=std::chrono::nanoseconds(-1))</td></tr>
<tr class="separator:a63b530d7459b579ca22044a5e7a37a50 inherit pro_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045379e6904e18e4bb3ff9f1aa039d46 inherit pro_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a045379e6904e18e4bb3ff9f1aa039d46">add_callback_groups_from_nodes_associated_to_executor</a> ()</td></tr>
<tr class="memdesc:a045379e6904e18e4bb3ff9f1aa039d46 inherit pro_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all callback groups that can be automatically added from associated nodes.  <a href="classrclcpp_1_1Executor.html#a045379e6904e18e4bb3ff9f1aa039d46">More...</a><br /></td></tr>
<tr class="separator:a045379e6904e18e4bb3ff9f1aa039d46 inherit pro_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_classrclcpp_1_1Executor"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classrclcpp_1_1Executor')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classrclcpp_1_1Executor.html">rclcpp::Executor</a></td></tr>
<tr class="memitem:a3580d9e86d9ebb7e674e4270d485bef6 inherit pro_types_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; rclcpp::CallbackGroup::WeakPtr, const <a class="el" href="classrclcpp_1_1GuardCondition.html">rclcpp::GuardCondition</a> *, std::owner_less&lt; rclcpp::CallbackGroup::WeakPtr &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a3580d9e86d9ebb7e674e4270d485bef6">WeakCallbackGroupsToGuardConditionsMap</a></td></tr>
<tr class="separator:a3580d9e86d9ebb7e674e4270d485bef6 inherit pro_types_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classrclcpp_1_1Executor"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classrclcpp_1_1Executor')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classrclcpp_1_1Executor.html">rclcpp::Executor</a></td></tr>
<tr class="memitem:a3f825d7a6d22eb8a6c2974d89d8bcebc inherit pro_static_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a3f825d7a6d22eb8a6c2974d89d8bcebc">execute_subscription</a> (rclcpp::SubscriptionBase::SharedPtr subscription)</td></tr>
<tr class="separator:a3f825d7a6d22eb8a6c2974d89d8bcebc inherit pro_static_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e62a3a7c60ab1569659aeaa47886b7e inherit pro_static_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a6e62a3a7c60ab1569659aeaa47886b7e">execute_timer</a> (rclcpp::TimerBase::SharedPtr timer)</td></tr>
<tr class="separator:a6e62a3a7c60ab1569659aeaa47886b7e inherit pro_static_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2e10441f4ad3c566c84f44e8d697d8 inherit pro_static_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a8c2e10441f4ad3c566c84f44e8d697d8">execute_service</a> (rclcpp::ServiceBase::SharedPtr service)</td></tr>
<tr class="separator:a8c2e10441f4ad3c566c84f44e8d697d8 inherit pro_static_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488790ad5eccaf4a7dc2b6eab6862147 inherit pro_static_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a488790ad5eccaf4a7dc2b6eab6862147">execute_client</a> (rclcpp::ClientBase::SharedPtr client)</td></tr>
<tr class="separator:a488790ad5eccaf4a7dc2b6eab6862147 inherit pro_static_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classrclcpp_1_1Executor"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classrclcpp_1_1Executor')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classrclcpp_1_1Executor.html">rclcpp::Executor</a></td></tr>
<tr class="memitem:afe759d8451caa0752e2209bb0863dbcd inherit pro_attribs_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">std::atomic_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#afe759d8451caa0752e2209bb0863dbcd">spinning</a></td></tr>
<tr class="memdesc:afe759d8451caa0752e2209bb0863dbcd inherit pro_attribs_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spinning state, used to prevent multi threaded calls to spin and to cancel blocking spins.  <a href="classrclcpp_1_1Executor.html#afe759d8451caa0752e2209bb0863dbcd">More...</a><br /></td></tr>
<tr class="separator:afe759d8451caa0752e2209bb0863dbcd inherit pro_attribs_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab940062f9fdfe52fc4d6f6b9948951a4 inherit pro_attribs_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1GuardCondition.html">rclcpp::GuardCondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ab940062f9fdfe52fc4d6f6b9948951a4">interrupt_guard_condition_</a></td></tr>
<tr class="memdesc:ab940062f9fdfe52fc4d6f6b9948951a4 inherit pro_attribs_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guard condition for signaling the rmw layer to wake up for special events.  <a href="classrclcpp_1_1Executor.html#ab940062f9fdfe52fc4d6f6b9948951a4">More...</a><br /></td></tr>
<tr class="separator:ab940062f9fdfe52fc4d6f6b9948951a4 inherit pro_attribs_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7ffa426ec1e9629d6744cd06b95d1e inherit pro_attribs_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1GuardCondition.html">rclcpp::GuardCondition</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#afc7ffa426ec1e9629d6744cd06b95d1e">shutdown_guard_condition_</a></td></tr>
<tr class="separator:afc7ffa426ec1e9629d6744cd06b95d1e inherit pro_attribs_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bb6ff536c37f44a5c05f3ba5c300ee inherit pro_attribs_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">rcl_wait_set_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a07bb6ff536c37f44a5c05f3ba5c300ee">wait_set_</a> = rcl_get_zero_initialized_wait_set()</td></tr>
<tr class="memdesc:a07bb6ff536c37f44a5c05f3ba5c300ee inherit pro_attribs_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait set for managing entities that the rmw layer waits on.  <a href="classrclcpp_1_1Executor.html#a07bb6ff536c37f44a5c05f3ba5c300ee">More...</a><br /></td></tr>
<tr class="separator:a07bb6ff536c37f44a5c05f3ba5c300ee inherit pro_attribs_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad851c542268bfdc461fc37d5be4d1b3b inherit pro_attribs_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ad851c542268bfdc461fc37d5be4d1b3b">mutex_</a></td></tr>
<tr class="separator:ad851c542268bfdc461fc37d5be4d1b3b inherit pro_attribs_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d31b355624a35e3a806e5533084f78 inherit pro_attribs_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">memory_strategy::MemoryStrategy::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#aa1d31b355624a35e3a806e5533084f78">memory_strategy_</a></td></tr>
<tr class="memdesc:aa1d31b355624a35e3a806e5533084f78 inherit pro_attribs_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">The memory strategy: an interface for handling user-defined memory allocation strategies.  <a href="classrclcpp_1_1Executor.html#aa1d31b355624a35e3a806e5533084f78">More...</a><br /></td></tr>
<tr class="separator:aa1d31b355624a35e3a806e5533084f78 inherit pro_attribs_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb729b9e8a7e925e08fb0a9d6244282 inherit pro_attribs_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1Context.html">rclcpp::Context</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a9cb729b9e8a7e925e08fb0a9d6244282">context_</a></td></tr>
<tr class="memdesc:a9cb729b9e8a7e925e08fb0a9d6244282 inherit pro_attribs_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">The context associated with this executor.  <a href="classrclcpp_1_1Executor.html#a9cb729b9e8a7e925e08fb0a9d6244282">More...</a><br /></td></tr>
<tr class="separator:a9cb729b9e8a7e925e08fb0a9d6244282 inherit pro_attribs_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d97fbf87035b86717a0c6573030b9f inherit pro_attribs_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1Executor.html#a3580d9e86d9ebb7e674e4270d485bef6">WeakCallbackGroupsToGuardConditionsMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a76d97fbf87035b86717a0c6573030b9f">weak_groups_to_guard_conditions_</a></td></tr>
<tr class="memdesc:a76d97fbf87035b86717a0c6573030b9f inherit pro_attribs_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps callback groups to guard conditions  <a href="classrclcpp_1_1Executor.html#a76d97fbf87035b86717a0c6573030b9f">More...</a><br /></td></tr>
<tr class="separator:a76d97fbf87035b86717a0c6573030b9f inherit pro_attribs_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e4e0095bcfef72436151e32040a653 inherit pro_attribs_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a80e4e0095bcfef72436151e32040a653">weak_groups_associated_with_executor_to_nodes_</a></td></tr>
<tr class="memdesc:a80e4e0095bcfef72436151e32040a653 inherit pro_attribs_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps callback groups associated to nodes  <a href="classrclcpp_1_1Executor.html#a80e4e0095bcfef72436151e32040a653">More...</a><br /></td></tr>
<tr class="separator:a80e4e0095bcfef72436151e32040a653 inherit pro_attribs_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7eb596c5102555c0189a9ea430cd36 inherit pro_attribs_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#acd7eb596c5102555c0189a9ea430cd36">weak_groups_to_nodes_associated_with_executor_</a></td></tr>
<tr class="memdesc:acd7eb596c5102555c0189a9ea430cd36 inherit pro_attribs_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps callback groups to nodes associated with executor  <a href="classrclcpp_1_1Executor.html#acd7eb596c5102555c0189a9ea430cd36">More...</a><br /></td></tr>
<tr class="separator:acd7eb596c5102555c0189a9ea430cd36 inherit pro_attribs_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8af8318254071752bb2c89c044ed56c inherit pro_attribs_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerclcpp.html#a5de5071053a1993f126aaa3a907ae649">WeakCallbackGroupsToNodesMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ae8af8318254071752bb2c89c044ed56c">weak_groups_to_nodes_</a></td></tr>
<tr class="memdesc:ae8af8318254071752bb2c89c044ed56c inherit pro_attribs_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps all callback groups to nodes  <a href="classrclcpp_1_1Executor.html#ae8af8318254071752bb2c89c044ed56c">More...</a><br /></td></tr>
<tr class="separator:ae8af8318254071752bb2c89c044ed56c inherit pro_attribs_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83944e8c14cee34664cf40d1bc29e058 inherit pro_attribs_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">std::list&lt; rclcpp::node_interfaces::NodeBaseInterface::WeakPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a83944e8c14cee34664cf40d1bc29e058">weak_nodes_</a></td></tr>
<tr class="memdesc:a83944e8c14cee34664cf40d1bc29e058 inherit pro_attribs_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">nodes that are associated with the executor  <a href="classrclcpp_1_1Executor.html#a83944e8c14cee34664cf40d1bc29e058">More...</a><br /></td></tr>
<tr class="separator:a83944e8c14cee34664cf40d1bc29e058 inherit pro_attribs_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fadf16c2cd579d8fc6d4da00a6d372 inherit pro_attribs_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerclcpp.html#a5da79bfb6561c87736d5b49f30a4d0f2">rclcpp::OnShutdownCallbackHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ac6fadf16c2cd579d8fc6d4da00a6d372">shutdown_callback_handle_</a></td></tr>
<tr class="memdesc:ac6fadf16c2cd579d8fc6d4da00a6d372 inherit pro_attribs_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">shutdown callback handle registered to <a class="el" href="classrclcpp_1_1Context.html" title="Context which encapsulates shared state between nodes and other similar entities.">Context</a>  <a href="classrclcpp_1_1Executor.html#ac6fadf16c2cd579d8fc6d4da00a6d372">More...</a><br /></td></tr>
<tr class="separator:ac6fadf16c2cd579d8fc6d4da00a6d372 inherit pro_attribs_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Static executor implementation. </p>
<p>This executor is a static version of the original single threaded executor. It's static because it doesn't reconstruct the executable list for every iteration. All nodes, callbackgroups, timers, subscriptions etc. are created before <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a1cec9027c4c69e49a6e15398f01b7c47" title="Static executor implementation of spin.">spin()</a> is called, and modified only when an entity is added/removed to/from a node.</p>
<p>To run this executor instead of <a class="el" href="classrclcpp_1_1executors_1_1SingleThreadedExecutor.html" title="Single-threaded executor implementation.">SingleThreadedExecutor</a> replace: <a class="el" href="classrclcpp_1_1executors_1_1SingleThreadedExecutor.html" title="Single-threaded executor implementation.">rclcpp::executors::SingleThreadedExecutor</a> exec; by <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html" title="Static executor implementation.">rclcpp::executors::StaticSingleThreadedExecutor</a> exec; in your source code and spin node(s) in the following way: exec.add_node(node); <a class="el" href="namespacerclcpp.html#a21e13577f5bcc5992de1d7dd08d8652b" title="Create a default single-threaded executor and spin the specified node.">exec.spin()</a>; exec.remove_node(node); </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6ee69a543c46f731a74a8d33fe6bf3e5"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/StaticSingleThreadedExecutor" class="dashAnchor">&nbsp;</a><a href="#a6ee69a543c46f731a74a8d33fe6bf3e5">&#9670;&nbsp;</a></span>StaticSingleThreadedExecutor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::executors::StaticSingleThreadedExecutor::StaticSingleThreadedExecutor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrclcpp_1_1ExecutorOptions.html">rclcpp::ExecutorOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structrclcpp_1_1ExecutorOptions.html">rclcpp::ExecutorOptions</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. See the default constructor for <a class="el" href="classrclcpp_1_1Executor.html" title="Coordinate the order and timing of available communication tasks.">Executor</a>. </p>

</div>
</div>
<a id="acfba5ffd5adf68e26137f49a8587ad9e"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/~StaticSingleThreadedExecutor" class="dashAnchor">&nbsp;</a><a href="#acfba5ffd5adf68e26137f49a8587ad9e">&#9670;&nbsp;</a></span>~StaticSingleThreadedExecutor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual rclcpp::executors::StaticSingleThreadedExecutor::~StaticSingleThreadedExecutor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destrcutor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1cec9027c4c69e49a6e15398f01b7c47"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/spin" class="dashAnchor">&nbsp;</a><a href="#a1cec9027c4c69e49a6e15398f01b7c47">&#9670;&nbsp;</a></span>spin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executors::StaticSingleThreadedExecutor::spin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static executor implementation of spin. </p>
<p>This function will block until work comes in, execute it, and keep blocking. It will only be interrupted by a CTRL-C (managed by the global signal handler). </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>when <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a1cec9027c4c69e49a6e15398f01b7c47" title="Static executor implementation of spin.">spin()</a> called while already spinning </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classrclcpp_1_1Executor.html#ad096fec6846af2169ee97cd2d23e96ca">rclcpp::Executor</a>.</p>

</div>
</div>
<a id="a38723cc9e16bddd7b4be5400c3125a99"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/spin_some" class="dashAnchor">&nbsp;</a><a href="#a38723cc9e16bddd7b4be5400c3125a99">&#9670;&nbsp;</a></span>spin_some()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executors::StaticSingleThreadedExecutor::spin_some </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>max_duration</em> = <code>std::chrono::nanoseconds(0)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static executor implementation of spin some. </p>
<p>This non-blocking function will execute entities that were ready when this API was called, until timeout or no more work available. Entities that got ready while executing work, won't be taken into account here.</p>
<p>Example: while(condition) { <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a38723cc9e16bddd7b4be5400c3125a99" title="Static executor implementation of spin some.">spin_some()</a>; sleep(); // User should have some sync work or // sleep to avoid a 100% CPU usage } </p>

<p>Reimplemented from <a class="el" href="classrclcpp_1_1Executor.html#ae821cd4cf1040fe2da521fb19a458fa1">rclcpp::Executor</a>.</p>

</div>
</div>
<a id="a642edbabbbe955174256300db23b25fc"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/spin_all" class="dashAnchor">&nbsp;</a><a href="#a642edbabbbe955174256300db23b25fc">&#9670;&nbsp;</a></span>spin_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executors::StaticSingleThreadedExecutor::spin_all </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>max_duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static executor implementation of spin all. </p>
<p>This non-blocking function will execute entities until timeout (must be &gt;= 0) or no more work available. If timeout is <code>0</code>, potentially it blocks forever until no more work is available. If new entities get ready while executing work available, they will be executed as long as the timeout hasn't expired.</p>
<p>Example: while(condition) { <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a642edbabbbe955174256300db23b25fc" title="Static executor implementation of spin all.">spin_all()</a>; sleep(); // User should have some sync work or // sleep to avoid a 100% CPU usage } </p>

<p>Reimplemented from <a class="el" href="classrclcpp_1_1Executor.html#a5e13b528a3f94a5d54ff139ec1f4a7cc">rclcpp::Executor</a>.</p>

</div>
</div>
<a id="a7641a44b0e95911a08c9961f7cd6963c"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/add_callback_group" class="dashAnchor">&nbsp;</a><a href="#a7641a44b0e95911a08c9961f7cd6963c">&#9670;&nbsp;</a></span>add_callback_group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executors::StaticSingleThreadedExecutor::add_callback_group </td>
          <td>(</td>
          <td class="paramtype">rclcpp::CallbackGroup::SharedPtr&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a callback group to an executor. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Executor.html#a6bb97eed174e54946d42ea83cf72a5a9" title="Add a callback group to an executor.">rclcpp::Executor::add_callback_group</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classrclcpp_1_1Executor.html#a6bb97eed174e54946d42ea83cf72a5a9">rclcpp::Executor</a>.</p>

</div>
</div>
<a id="ac5142581ba7090734726cf6c471d084e"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/remove_callback_group" class="dashAnchor">&nbsp;</a><a href="#ac5142581ba7090734726cf6c471d084e">&#9670;&nbsp;</a></span>remove_callback_group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executors::StaticSingleThreadedExecutor::remove_callback_group </td>
          <td>(</td>
          <td class="paramtype">rclcpp::CallbackGroup::SharedPtr&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove callback group from the executor. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Executor.html#a84a5c14786aee651ce0f7d5f1bfd098f" title="Remove a callback group from the executor.">rclcpp::Executor::remove_callback_group</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classrclcpp_1_1Executor.html#a84a5c14786aee651ce0f7d5f1bfd098f">rclcpp::Executor</a>.</p>

</div>
</div>
<a id="a5c04102c89554658c021dceb1555af2f"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/add_node" class="dashAnchor">&nbsp;</a><a href="#a5c04102c89554658c021dceb1555af2f">&#9670;&nbsp;</a></span>add_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executors::StaticSingleThreadedExecutor::add_node </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a node to the executor. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Executor.html#a53f9649e4c2f3593c930f4d191e7e208" title="Add a node to the executor.">rclcpp::Executor::add_node</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classrclcpp_1_1Executor.html#a53f9649e4c2f3593c930f4d191e7e208">rclcpp::Executor</a>.</p>

</div>
</div>
<a id="acc40d425a0b14000dcec22b93a5ba194"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/add_node" class="dashAnchor">&nbsp;</a><a href="#acc40d425a0b14000dcec22b93a5ba194">&#9670;&nbsp;</a></span>add_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executors::StaticSingleThreadedExecutor::add_node </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1Node.html">rclcpp::Node</a> &gt;&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface. </p>
<dl class="section see"><dt>See also</dt><dd>rclcpp::StaticSingleThreadedExecutor::add_node </dd></dl>

<p>Reimplemented from <a class="el" href="classrclcpp_1_1Executor.html#a83a2b87b3a60d3fd8525d18879cec14c">rclcpp::Executor</a>.</p>

</div>
</div>
<a id="ad0c159ea2f81661d52b06b1e8a4edbd0"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/remove_node" class="dashAnchor">&nbsp;</a><a href="#ad0c159ea2f81661d52b06b1e8a4edbd0">&#9670;&nbsp;</a></span>remove_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executors::StaticSingleThreadedExecutor::remove_node </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a node from the executor. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Executor.html#a660424725a58fc412fac8e86191b1f61" title="Remove a node from the executor.">rclcpp::Executor::remove_node</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classrclcpp_1_1Executor.html#a660424725a58fc412fac8e86191b1f61">rclcpp::Executor</a>.</p>

</div>
</div>
<a id="a9578b4ab98dda3b6493d35b87c302af4"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/remove_node" class="dashAnchor">&nbsp;</a><a href="#a9578b4ab98dda3b6493d35b87c302af4">&#9670;&nbsp;</a></span>remove_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executors::StaticSingleThreadedExecutor::remove_node </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1Node.html">rclcpp::Node</a> &gt;&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Executor.html#a660424725a58fc412fac8e86191b1f61" title="Remove a node from the executor.">rclcpp::Executor::remove_node</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classrclcpp_1_1Executor.html#ae0543bf6a85ae11a042cef13077ab364">rclcpp::Executor</a>.</p>

</div>
</div>
<a id="a90eebd217c5102fb470508f3ad9698a7"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/get_all_callback_groups" class="dashAnchor">&nbsp;</a><a href="#a90eebd217c5102fb470508f3ad9698a7">&#9670;&nbsp;</a></span>get_all_callback_groups()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;rclcpp::CallbackGroup::WeakPtr&gt; rclcpp::executors::StaticSingleThreadedExecutor::get_all_callback_groups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get callback groups that belong to executor. </p>
<p>This function returns a vector of weak pointers that point to callback groups that were associated with the executor. The callback groups associated with this executor may have been added with <code>add_callback_group</code>, or added when a node was added to the executor with <code>add_node</code>, or automatically added when it created by a node already associated with this executor and the automatically_add_to_executor_with_node parameter was true.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector of weak pointers that point to callback groups that are associated with the executor </dd></dl>

<p>Reimplemented from <a class="el" href="classrclcpp_1_1Executor.html#aa37926d32654ae54f95bd6676005901c">rclcpp::Executor</a>.</p>

</div>
</div>
<a id="abe0584c4a5c8a34c6e4b9d649174e64d"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/get_manually_added_callback_groups" class="dashAnchor">&nbsp;</a><a href="#abe0584c4a5c8a34c6e4b9d649174e64d">&#9670;&nbsp;</a></span>get_manually_added_callback_groups()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;rclcpp::CallbackGroup::WeakPtr&gt; rclcpp::executors::StaticSingleThreadedExecutor::get_manually_added_callback_groups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get callback groups that belong to executor. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Executor.html#a6718d2978792d55091e0e97f136e21ba" title="Get callback groups that belong to executor.">rclcpp::Executor::get_manually_added_callback_groups()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classrclcpp_1_1Executor.html#a6718d2978792d55091e0e97f136e21ba">rclcpp::Executor</a>.</p>

</div>
</div>
<a id="ab28350f023e1e9ac738557000eb70ac8"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/get_automatically_added_callback_groups_from_nodes" class="dashAnchor">&nbsp;</a><a href="#ab28350f023e1e9ac738557000eb70ac8">&#9670;&nbsp;</a></span>get_automatically_added_callback_groups_from_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;rclcpp::CallbackGroup::WeakPtr&gt; rclcpp::executors::StaticSingleThreadedExecutor::get_automatically_added_callback_groups_from_nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get callback groups that belong to executor. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Executor.html#a156eeccc922f93d044efc8ce1b55b5cc" title="Get callback groups that belong to executor.">rclcpp::Executor::get_automatically_added_callback_groups_from_nodes()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classrclcpp_1_1Executor.html#a156eeccc922f93d044efc8ce1b55b5cc">rclcpp::Executor</a>.</p>

</div>
</div>
<a id="ae4b27be117016dcc6e1b98124b41e0d3"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/execute_ready_executables" class="dashAnchor">&nbsp;</a><a href="#ae4b27be117016dcc6e1b98124b41e0d3">&#9670;&nbsp;</a></span>execute_ready_executables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::executors::StaticSingleThreadedExecutor::execute_ready_executables </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>spin_once</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes ready executables from wait set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spin_once</td><td>if true executes only the first ready executable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any executable was ready. </dd></dl>

</div>
</div>
<a id="af80fffc6734a60b03eca5763e32a84b6"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/spin_some_impl" class="dashAnchor">&nbsp;</a><a href="#af80fffc6734a60b03eca5763e32a84b6">&#9670;&nbsp;</a></span>spin_some_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executors::StaticSingleThreadedExecutor::spin_some_impl </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>max_duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exhaustive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e2a7699ba52bb2d6a8323b36ad858dc"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/spin_once_impl" class="dashAnchor">&nbsp;</a><a href="#a4e2a7699ba52bb2d6a8323b36ad858dc">&#9670;&nbsp;</a></span>spin_once_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executors::StaticSingleThreadedExecutor::spin_once_impl </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classrclcpp_1_1Executor.html#afcce1959f54430db201b5800ff9f61a6">rclcpp::Executor</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/rclcpp/executors/<a class="el" href="static__single__threaded__executor_8hpp_source.html">static_single_threaded_executor.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
