<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rclcpp: rclcpp::Waitable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rclcpp
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C++ ROS Client Library API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerclcpp.html">rclcpp</a></li><li class="navelem"><a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classrclcpp_1_1Waitable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rclcpp::Waitable Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="waitable_8hpp_source.html">waitable.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rclcpp::Waitable:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1Waitable__inherit__graph.png" border="0" usemap="#arclcpp_1_1Waitable_inherit__map" alt="Inheritance graph"/></div>
<map name="arclcpp_1_1Waitable_inherit__map" id="arclcpp_1_1Waitable_inherit__map">
<area shape="rect" title=" " alt="" coords="5,71,132,98"/>
<area shape="rect" href="classrclcpp_1_1QOSEventHandlerBase.html" title=" " alt="" coords="183,13,400,39"/>
<area shape="rect" href="classrclcpp_1_1executors_1_1StaticExecutorEntitiesCollector.html" title=" " alt="" coords="180,64,403,105"/>
<area shape="rect" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html" title=" " alt="" coords="180,129,403,171"/>
<area shape="rect" href="classrclcpp_1_1QOSEventHandler.html" title=" " alt="" coords="496,5,752,47"/>
<area shape="rect" href="classrclcpp_1_1experimental_1_1SubscriptionROSMsgIntraProcessBuffer.html" title=" " alt="" coords="451,74,797,218"/>
<area shape="rect" href="classrclcpp_1_1experimental_1_1SubscriptionROSMsgIntraProcessBuffer.html" title=" " alt="" coords="502,243,746,313"/>
<area shape="rect" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBuffer.html" title=" " alt="" coords="845,53,1171,138"/>
<area shape="rect" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBuffer.html" title=" " alt="" coords="889,163,1127,233"/>
<area shape="rect" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcess.html" title=" " alt="" coords="1219,53,1487,138"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a775475ffdec36b88279a0d671739cce2"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Waitable.html#a775475ffdec36b88279a0d671739cce2">~Waitable</a> ()=default</td></tr>
<tr class="separator:a775475ffdec36b88279a0d671739cce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f428f90de03558d8e5090b45fa96ac8"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Waitable.html#a4f428f90de03558d8e5090b45fa96ac8">get_number_of_ready_subscriptions</a> ()</td></tr>
<tr class="memdesc:a4f428f90de03558d8e5090b45fa96ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of ready subscriptions.  <a name="//apple_ref/cpp/Method/get_number_of_ready_subscriptions" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1Waitable.html#a4f428f90de03558d8e5090b45fa96ac8">More...</a><br /></td></tr>
<tr class="separator:a4f428f90de03558d8e5090b45fa96ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46ecd60ac2ddee1a76f280a05155334"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Waitable.html#af46ecd60ac2ddee1a76f280a05155334">get_number_of_ready_timers</a> ()</td></tr>
<tr class="memdesc:af46ecd60ac2ddee1a76f280a05155334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of ready timers.  <a name="//apple_ref/cpp/Method/get_number_of_ready_timers" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1Waitable.html#af46ecd60ac2ddee1a76f280a05155334">More...</a><br /></td></tr>
<tr class="separator:af46ecd60ac2ddee1a76f280a05155334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7d6a8213736f5a60d9c8f9290866a9"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Waitable.html#aeb7d6a8213736f5a60d9c8f9290866a9">get_number_of_ready_clients</a> ()</td></tr>
<tr class="memdesc:aeb7d6a8213736f5a60d9c8f9290866a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of ready clients.  <a name="//apple_ref/cpp/Method/get_number_of_ready_clients" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1Waitable.html#aeb7d6a8213736f5a60d9c8f9290866a9">More...</a><br /></td></tr>
<tr class="separator:aeb7d6a8213736f5a60d9c8f9290866a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441c473cb21623371b8ae0bc4d4ff7ce"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Waitable.html#a441c473cb21623371b8ae0bc4d4ff7ce">get_number_of_ready_events</a> ()</td></tr>
<tr class="memdesc:a441c473cb21623371b8ae0bc4d4ff7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of ready events.  <a name="//apple_ref/cpp/Method/get_number_of_ready_events" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1Waitable.html#a441c473cb21623371b8ae0bc4d4ff7ce">More...</a><br /></td></tr>
<tr class="separator:a441c473cb21623371b8ae0bc4d4ff7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49309417506cfee91923ce88ce95b63f"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Waitable.html#a49309417506cfee91923ce88ce95b63f">get_number_of_ready_services</a> ()</td></tr>
<tr class="memdesc:a49309417506cfee91923ce88ce95b63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of ready services.  <a name="//apple_ref/cpp/Method/get_number_of_ready_services" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1Waitable.html#a49309417506cfee91923ce88ce95b63f">More...</a><br /></td></tr>
<tr class="separator:a49309417506cfee91923ce88ce95b63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154b4cee45c24584485586cb4de10ee8"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Waitable.html#a154b4cee45c24584485586cb4de10ee8">get_number_of_ready_guard_conditions</a> ()</td></tr>
<tr class="memdesc:a154b4cee45c24584485586cb4de10ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of ready guard_conditions.  <a name="//apple_ref/cpp/Method/get_number_of_ready_guard_conditions" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1Waitable.html#a154b4cee45c24584485586cb4de10ee8">More...</a><br /></td></tr>
<tr class="separator:a154b4cee45c24584485586cb4de10ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cbdb05dd021b246413d0dd01072412"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Waitable.html#ae2cbdb05dd021b246413d0dd01072412">add_to_wait_set</a> (rcl_wait_set_t *wait_set)=0</td></tr>
<tr class="memdesc:ae2cbdb05dd021b246413d0dd01072412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> to a wait set.  <a name="//apple_ref/cpp/Method/add_to_wait_set" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1Waitable.html#ae2cbdb05dd021b246413d0dd01072412">More...</a><br /></td></tr>
<tr class="separator:ae2cbdb05dd021b246413d0dd01072412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a71a73b57677c3097012a0bb23b83d4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Waitable.html#a7a71a73b57677c3097012a0bb23b83d4">is_ready</a> (rcl_wait_set_t *wait_set)=0</td></tr>
<tr class="memdesc:a7a71a73b57677c3097012a0bb23b83d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> is ready.  <a name="//apple_ref/cpp/Method/is_ready" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1Waitable.html#a7a71a73b57677c3097012a0bb23b83d4">More...</a><br /></td></tr>
<tr class="separator:a7a71a73b57677c3097012a0bb23b83d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bc70332645461c9317bbb59468c94b"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Waitable.html#a69bc70332645461c9317bbb59468c94b">take_data</a> ()=0</td></tr>
<tr class="memdesc:a69bc70332645461c9317bbb59468c94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the data so that it can be consumed with <code>execute</code>.  <a name="//apple_ref/cpp/Method/take_data" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1Waitable.html#a69bc70332645461c9317bbb59468c94b">More...</a><br /></td></tr>
<tr class="separator:a69bc70332645461c9317bbb59468c94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3b5a6501ecbd76090ce032ce5f000c"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Waitable.html#a9c3b5a6501ecbd76090ce032ce5f000c">take_data_by_entity_id</a> (size_t id)</td></tr>
<tr class="memdesc:a9c3b5a6501ecbd76090ce032ce5f000c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the data so that it can be consumed with <code>execute</code>.  <a name="//apple_ref/cpp/Method/take_data_by_entity_id" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1Waitable.html#a9c3b5a6501ecbd76090ce032ce5f000c">More...</a><br /></td></tr>
<tr class="separator:a9c3b5a6501ecbd76090ce032ce5f000c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4aa39a931c99fb99c1ed1e9a50aaf97"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Waitable.html#aa4aa39a931c99fb99c1ed1e9a50aaf97">execute</a> (std::shared_ptr&lt; void &gt; &amp;data)=0</td></tr>
<tr class="memdesc:aa4aa39a931c99fb99c1ed1e9a50aaf97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute data that is passed in.  <a name="//apple_ref/cpp/Method/execute" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1Waitable.html#aa4aa39a931c99fb99c1ed1e9a50aaf97">More...</a><br /></td></tr>
<tr class="separator:aa4aa39a931c99fb99c1ed1e9a50aaf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73eeb074bfbbd858d5c559d6b185ff8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Waitable.html#aa73eeb074bfbbd858d5c559d6b185ff8">exchange_in_use_by_wait_set_state</a> (bool in_use_state)</td></tr>
<tr class="memdesc:aa73eeb074bfbbd858d5c559d6b185ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange the "in use by wait set" state for this timer.  <a name="//apple_ref/cpp/Method/exchange_in_use_by_wait_set_state" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1Waitable.html#aa73eeb074bfbbd858d5c559d6b185ff8">More...</a><br /></td></tr>
<tr class="separator:aa73eeb074bfbbd858d5c559d6b185ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48eae7264bbc8598ec5ee16a5c2035a4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Waitable.html#a48eae7264bbc8598ec5ee16a5c2035a4">set_on_ready_callback</a> (std::function&lt; void(size_t, int)&gt; callback)</td></tr>
<tr class="memdesc:a48eae7264bbc8598ec5ee16a5c2035a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a callback to be called whenever the waitable becomes ready.  <a name="//apple_ref/cpp/Method/set_on_ready_callback" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1Waitable.html#a48eae7264bbc8598ec5ee16a5c2035a4">More...</a><br /></td></tr>
<tr class="separator:a48eae7264bbc8598ec5ee16a5c2035a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81c97b4136b8aaf0a144b1981896eab"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Waitable.html#ac81c97b4136b8aaf0a144b1981896eab">clear_on_ready_callback</a> ()</td></tr>
<tr class="memdesc:ac81c97b4136b8aaf0a144b1981896eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unset any callback registered via set_on_ready_callback.  <a name="//apple_ref/cpp/Method/clear_on_ready_callback" class="dashAnchor">&nbsp;</a><a href="classrclcpp_1_1Waitable.html#ac81c97b4136b8aaf0a144b1981896eab">More...</a><br /></td></tr>
<tr class="separator:ac81c97b4136b8aaf0a144b1981896eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a775475ffdec36b88279a0d671739cce2"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/~Waitable" class="dashAnchor">&nbsp;</a><a href="#a775475ffdec36b88279a0d671739cce2">&#9670;&nbsp;</a></span>~Waitable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual rclcpp::Waitable::~Waitable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4f428f90de03558d8e5090b45fa96ac8"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/get_number_of_ready_subscriptions" class="dashAnchor">&nbsp;</a><a href="#a4f428f90de03558d8e5090b45fa96ac8">&#9670;&nbsp;</a></span>get_number_of_ready_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t rclcpp::Waitable::get_number_of_ready_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of ready subscriptions. </p>
<p>Returns a value of 0 by default. This should be overridden if the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> contains one or more subscriptions. </p><dl class="section return"><dt>Returns</dt><dd>The number of subscriptions associated with the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a>. </dd></dl>

</div>
</div>
<a id="af46ecd60ac2ddee1a76f280a05155334"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/get_number_of_ready_timers" class="dashAnchor">&nbsp;</a><a href="#af46ecd60ac2ddee1a76f280a05155334">&#9670;&nbsp;</a></span>get_number_of_ready_timers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t rclcpp::Waitable::get_number_of_ready_timers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of ready timers. </p>
<p>Returns a value of 0 by default. This should be overridden if the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> contains one or more timers. </p><dl class="section return"><dt>Returns</dt><dd>The number of timers associated with the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a>. </dd></dl>

</div>
</div>
<a id="aeb7d6a8213736f5a60d9c8f9290866a9"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/get_number_of_ready_clients" class="dashAnchor">&nbsp;</a><a href="#aeb7d6a8213736f5a60d9c8f9290866a9">&#9670;&nbsp;</a></span>get_number_of_ready_clients()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t rclcpp::Waitable::get_number_of_ready_clients </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of ready clients. </p>
<p>Returns a value of 0 by default. This should be overridden if the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> contains one or more clients. </p><dl class="section return"><dt>Returns</dt><dd>The number of clients associated with the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a>. </dd></dl>

</div>
</div>
<a id="a441c473cb21623371b8ae0bc4d4ff7ce"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/get_number_of_ready_events" class="dashAnchor">&nbsp;</a><a href="#a441c473cb21623371b8ae0bc4d4ff7ce">&#9670;&nbsp;</a></span>get_number_of_ready_events()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t rclcpp::Waitable::get_number_of_ready_events </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of ready events. </p>
<p>Returns a value of 0 by default. This should be overridden if the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> contains one or more events. </p><dl class="section return"><dt>Returns</dt><dd>The number of events associated with the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classrclcpp_1_1QOSEventHandlerBase.html#ab5dfa3202c159b8bb472da202eeb4351">rclcpp::QOSEventHandlerBase</a>.</p>

</div>
</div>
<a id="a49309417506cfee91923ce88ce95b63f"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/get_number_of_ready_services" class="dashAnchor">&nbsp;</a><a href="#a49309417506cfee91923ce88ce95b63f">&#9670;&nbsp;</a></span>get_number_of_ready_services()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t rclcpp::Waitable::get_number_of_ready_services </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of ready services. </p>
<p>Returns a value of 0 by default. This should be overridden if the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> contains one or more services. </p><dl class="section return"><dt>Returns</dt><dd>The number of services associated with the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a>. </dd></dl>

</div>
</div>
<a id="a154b4cee45c24584485586cb4de10ee8"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/get_number_of_ready_guard_conditions" class="dashAnchor">&nbsp;</a><a href="#a154b4cee45c24584485586cb4de10ee8">&#9670;&nbsp;</a></span>get_number_of_ready_guard_conditions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t rclcpp::Waitable::get_number_of_ready_guard_conditions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of ready guard_conditions. </p>
<p>Returns a value of 0 by default. This should be overridden if the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> contains one or more guard_conditions. </p><dl class="section return"><dt>Returns</dt><dd>The number of guard_conditions associated with the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#a9d59d6d0ae85ffdfc56c05f0f23d5729">rclcpp::experimental::SubscriptionIntraProcessBase</a>, and <a class="el" href="classrclcpp_1_1executors_1_1StaticExecutorEntitiesCollector.html#a9e9bdb0ad84b84a2b10798ebd92d178c">rclcpp::executors::StaticExecutorEntitiesCollector</a>.</p>

</div>
</div>
<a id="ae2cbdb05dd021b246413d0dd01072412"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/add_to_wait_set" class="dashAnchor">&nbsp;</a><a href="#ae2cbdb05dd021b246413d0dd01072412">&#9670;&nbsp;</a></span>add_to_wait_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Waitable::add_to_wait_set </td>
          <td>(</td>
          <td class="paramtype">rcl_wait_set_t *&#160;</td>
          <td class="paramname"><em>wait_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> to a wait set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_set</td><td>A handle to the wait set to add the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rclcpp::execptions::RCLError</td><td>from rcl_wait_set_add_*() </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classrclcpp_1_1QOSEventHandlerBase.html#a6d59a8857334747a01797b8a5333a8c1">rclcpp::QOSEventHandlerBase</a>, <a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#a4f0b3a9736b6f6079041f4875495757b">rclcpp::experimental::SubscriptionIntraProcessBase</a>, and <a class="el" href="classrclcpp_1_1executors_1_1StaticExecutorEntitiesCollector.html#a17f169a068c6512cf3e3758bef38c261">rclcpp::executors::StaticExecutorEntitiesCollector</a>.</p>

</div>
</div>
<a id="a7a71a73b57677c3097012a0bb23b83d4"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/is_ready" class="dashAnchor">&nbsp;</a><a href="#a7a71a73b57677c3097012a0bb23b83d4">&#9670;&nbsp;</a></span>is_ready()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool rclcpp::Waitable::is_ready </td>
          <td>(</td>
          <td class="paramtype">rcl_wait_set_t *&#160;</td>
          <td class="paramname"><em>wait_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> is ready. </p>
<p>The input wait set should be the same that was used in a previously call to <code><a class="el" href="classrclcpp_1_1Waitable.html#ae2cbdb05dd021b246413d0dd01072412" title="Add the Waitable to a wait set.">add_to_wait_set()</a></code>. The wait set should also have been previously waited on with <code>rcl_wait()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_set</td><td>A handle to the wait set the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> was previously added to and that has been waited on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> is ready, <code>false</code> otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#aee9168f87ed731367f4d698835c6b5c0">rclcpp::experimental::SubscriptionIntraProcessBase</a>, <a class="el" href="classrclcpp_1_1QOSEventHandlerBase.html#a5c49178629eb341b095c144546ab5a25">rclcpp::QOSEventHandlerBase</a>, <a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBuffer.html#a9e83f1869eba9804e8d53852fdda7c76">rclcpp::experimental::SubscriptionIntraProcessBuffer&lt; SubscribedType, Alloc, Deleter, ROSMessageType &gt;</a>, <a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBuffer.html#a9e83f1869eba9804e8d53852fdda7c76">rclcpp::experimental::SubscriptionIntraProcessBuffer&lt; SubscribedType, std::allocator&lt; SubscribedType &gt;, std::default_delete&lt; SubscribedType &gt;, SubscribedType &gt;</a>, and <a class="el" href="classrclcpp_1_1executors_1_1StaticExecutorEntitiesCollector.html#a5bc78d0279b71cdf42831c3ac003c28d">rclcpp::executors::StaticExecutorEntitiesCollector</a>.</p>

</div>
</div>
<a id="a69bc70332645461c9317bbb59468c94b"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/take_data" class="dashAnchor">&nbsp;</a><a href="#a69bc70332645461c9317bbb59468c94b">&#9670;&nbsp;</a></span>take_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;void&gt; rclcpp::Waitable::take_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take the data so that it can be consumed with <code>execute</code>. </p>
<p>NOTE: take_data is a partial fix to a larger design issue with the multithreaded executor. This method is likely to be removed when a more permanent fix is implemented. A longterm fix is currently being discussed here: <a href="https://github.com/ros2/rclcpp/pull/1276">https://github.com/ros2/rclcpp/pull/1276</a></p>
<p>This method takes the data from the underlying data structure and writes it to the void shared pointer <code>data</code> that is passed into the method. The <code>data</code> can then be executed with the <code>execute</code> method.</p>
<p>Before calling this method, the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> should be added to a wait set, waited on, and then updated.</p>
<p>Example usage:</p>
<div class="fragment"><div class="line"><span class="comment">// ... create a wait set and a Waitable</span></div>
<div class="line"><span class="comment">// Add the Waitable to the wait set</span></div>
<div class="line">waitable.add_to_wait_set(wait_set);</div>
<div class="line"><span class="comment">// Wait</span></div>
<div class="line">rcl_ret_t wait_ret = rcl_wait(wait_set);</div>
<div class="line"><span class="comment">// ... error handling</span></div>
<div class="line"><span class="comment">// Update the Waitable</span></div>
<div class="line">waitable.update(wait_set);</div>
<div class="line"><span class="comment">// Execute any entities of the Waitable that may be ready</span></div>
<div class="line">std::shared_ptr&lt;void&gt; data = waitable.take_data();</div>
</div><!-- fragment --> 
<p>Implemented in <a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#aefa71f4648efd0f70e937e60a94a31d9">rclcpp::experimental::SubscriptionIntraProcessBase</a>, <a class="el" href="classrclcpp_1_1QOSEventHandler.html#a24a2c63c521306200979fd33378cb230">rclcpp::QOSEventHandler&lt; EventCallbackT, ParentHandleT &gt;</a>, <a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcess.html#a4f2a998479d2b1f8ca001066953966eb">rclcpp::experimental::SubscriptionIntraProcess&lt; MessageT, SubscribedType, SubscribedTypeAlloc, SubscribedTypeDeleter, ROSMessageType, Alloc &gt;</a>, and <a class="el" href="classrclcpp_1_1executors_1_1StaticExecutorEntitiesCollector.html#aa122bdc9bb33f55474f41ad669afce1a">rclcpp::executors::StaticExecutorEntitiesCollector</a>.</p>

</div>
</div>
<a id="a9c3b5a6501ecbd76090ce032ce5f000c"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/take_data_by_entity_id" class="dashAnchor">&nbsp;</a><a href="#a9c3b5a6501ecbd76090ce032ce5f000c">&#9670;&nbsp;</a></span>take_data_by_entity_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;void&gt; rclcpp::Waitable::take_data_by_entity_id </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take the data so that it can be consumed with <code>execute</code>. </p>
<p>This function allows to specify an entity ID to take the data from. Entity IDs are identifiers that can be defined by waitable-derived classes that are composed of several distinct entities. The main use-case is in conjunction with the listener APIs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>the id of the entity from which to take </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-erased data taken from entity specified</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Waitable.html#a69bc70332645461c9317bbb59468c94b" title="Take the data so that it can be consumed with execute.">rclcpp::Waitable::take_data</a> </dd>
<dd>
<a class="el" href="classrclcpp_1_1Waitable.html#a48eae7264bbc8598ec5ee16a5c2035a4" title="Set a callback to be called whenever the waitable becomes ready.">rclcpp::Waitable::set_on_ready_callback</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classrclcpp_1_1QOSEventHandler.html#afe4a256abbb1e11bcf56a8287f22d027">rclcpp::QOSEventHandler&lt; EventCallbackT, ParentHandleT &gt;</a>, and <a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#a2f39a3d4af6aa06a4bae0367941c7ba3">rclcpp::experimental::SubscriptionIntraProcessBase</a>.</p>

</div>
</div>
<a id="aa4aa39a931c99fb99c1ed1e9a50aaf97"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/execute" class="dashAnchor">&nbsp;</a><a href="#aa4aa39a931c99fb99c1ed1e9a50aaf97">&#9670;&nbsp;</a></span>execute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Waitable::execute </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute data that is passed in. </p>
<p>Before calling this method, the <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> should be added to a wait set, waited on, and then updated - and the <code>take_data</code> method should be called.</p>
<p>Example usage:</p>
<div class="fragment"><div class="line"><span class="comment">// ... create a wait set and a Waitable</span></div>
<div class="line"><span class="comment">// Add the Waitable to the wait set</span></div>
<div class="line">waitable.add_to_wait_set(wait_set);</div>
<div class="line"><span class="comment">// Wait</span></div>
<div class="line">rcl_ret_t wait_ret = rcl_wait(wait_set);</div>
<div class="line"><span class="comment">// ... error handling</span></div>
<div class="line"><span class="comment">// Update the Waitable</span></div>
<div class="line">waitable.update(wait_set);</div>
<div class="line"><span class="comment">// Execute any entities of the Waitable that may be ready</span></div>
<div class="line">std::shared_ptr&lt;void&gt; data = waitable.take_data();</div>
<div class="line">waitable.execute(data);</div>
</div><!-- fragment --> 
<p>Implemented in <a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#a7ca4cd6e8f8fb1c5daee302661ac7c56">rclcpp::experimental::SubscriptionIntraProcessBase</a>, <a class="el" href="classrclcpp_1_1QOSEventHandler.html#a33ace2ad9257fa1b4819576cfbf51619">rclcpp::QOSEventHandler&lt; EventCallbackT, ParentHandleT &gt;</a>, <a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcess.html#a0c246e15b891b387c2dd7c98e705f650">rclcpp::experimental::SubscriptionIntraProcess&lt; MessageT, SubscribedType, SubscribedTypeAlloc, SubscribedTypeDeleter, ROSMessageType, Alloc &gt;</a>, and <a class="el" href="classrclcpp_1_1executors_1_1StaticExecutorEntitiesCollector.html#ad9ec72ee9cce5ae8b2ece06033ba4d80">rclcpp::executors::StaticExecutorEntitiesCollector</a>.</p>

</div>
</div>
<a id="aa73eeb074bfbbd858d5c559d6b185ff8"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/exchange_in_use_by_wait_set_state" class="dashAnchor">&nbsp;</a><a href="#aa73eeb074bfbbd858d5c559d6b185ff8">&#9670;&nbsp;</a></span>exchange_in_use_by_wait_set_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::Waitable::exchange_in_use_by_wait_set_state </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>in_use_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchange the "in use by wait set" state for this timer. </p>
<p>This is used to ensure this timer is not used by multiple wait sets at the same time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_use_state</td><td>the new state to exchange into the state, true indicates it is now in use by a wait set, and false is that it is no longer in use by a wait set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous state. </dd></dl>

</div>
</div>
<a id="a48eae7264bbc8598ec5ee16a5c2035a4"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/set_on_ready_callback" class="dashAnchor">&nbsp;</a><a href="#a48eae7264bbc8598ec5ee16a5c2035a4">&#9670;&nbsp;</a></span>set_on_ready_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Waitable::set_on_ready_callback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(size_t, int)&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a callback to be called whenever the waitable becomes ready. </p>
<p>The callback receives a size_t which is the number of times the waitable was ready since the last time this callback was called. Normally this is 1, but can be &gt; 1 if waitable was triggered before any callback was set.</p>
<p>The callback also receives an int identifier argument. This is needed because a <a class="el" href="classrclcpp_1_1Waitable.html">Waitable</a> may be composed of several distinct entities, such as subscriptions, services, etc. The application should provide a generic callback function that will be then forwarded by the waitable to all of its entities. Before forwarding, a different value for the identifier argument will be bond to the function. This implies that the provided callback can use the identifier to behave differently depending on which entity triggered the waitable to become ready.</p>
<p>Note: this function must be overridden with a proper implementation by the custom classes who inherit from <a class="el" href="classrclcpp_1_1Waitable.html">rclcpp::Waitable</a> if they want to use it.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Waitable.html#ac81c97b4136b8aaf0a144b1981896eab" title="Unset any callback registered via set_on_ready_callback.">rclcpp::Waitable::clear_on_ready_callback</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>functor to be called when the waitable becomes ready </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classrclcpp_1_1QOSEventHandlerBase.html#aa792523eeb1f79c02f73dec5643ed948">rclcpp::QOSEventHandlerBase</a>, and <a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#ab823457f413f244c6fe7492b12c7265b">rclcpp::experimental::SubscriptionIntraProcessBase</a>.</p>

</div>
</div>
<a id="ac81c97b4136b8aaf0a144b1981896eab"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/clear_on_ready_callback" class="dashAnchor">&nbsp;</a><a href="#ac81c97b4136b8aaf0a144b1981896eab">&#9670;&nbsp;</a></span>clear_on_ready_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Waitable::clear_on_ready_callback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unset any callback registered via set_on_ready_callback. </p>
<p>Note: this function must be overridden with a proper implementation by the custom classes who inherit from <a class="el" href="classrclcpp_1_1Waitable.html">rclcpp::Waitable</a> if they want to use it. </p>

<p>Reimplemented in <a class="el" href="classrclcpp_1_1QOSEventHandlerBase.html#ada3621eb8ed6f9ca1b184cab115687cb">rclcpp::QOSEventHandlerBase</a>, and <a class="el" href="classrclcpp_1_1experimental_1_1SubscriptionIntraProcessBase.html#a1c542a3e38db47bb6ed5c368ebd4d876">rclcpp::experimental::SubscriptionIntraProcessBase</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/rclcpp/<a class="el" href="waitable_8hpp_source.html">waitable.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
